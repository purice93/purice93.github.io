<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>123</title>
    <url>/2020/01/08/123/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>今晚的卫星</title>
    <url>/2019/07/27/%E4%BB%8A%E6%99%9A%E7%9A%84%E5%8D%AB%E6%98%9F/</url>
    <content><![CDATA[<p><em>有时候我希望两个人的交流方式，能够像TCP那样简单，只需要三次交手，但最后往往需要很多次交手，以至于打得不可开交</em></p>
<hr>
<p>就目前的科学发展而言，虽然在很多领域计算机还是无法达到人脑的地步，但是在某些方面，计算机却显现出无比的高效稳定。很多时候人受限于情感，即便是1+1=2这样的解答也有可能会回答错误，更不用说是一般的信息决策和判断，特别是在两个人的相处过程之中，太多的想象导致太多的猜忌，进而偏离航向，而计算机却永远不会，它是设计如此严密，以至于他只能给出百分百的结果，而不是一个猜测信息，要知道有时候，猜测错误所导致的召回率极低会引发重大的后果。</p>
<blockquote>
<p>2018/10/21/2:32</p>
</blockquote>
<p>我实在不想做一个啰嗦之人，但是如今这个情况，我找不到去解决的方式。我怕电话打多了你会把我拉黑，我怕啰嗦多了你会更烦，我怕我会再次说出不该说的话来伤了你的心。但是，我也怕这样的冷漠情况会延续下去，怕这样的相互不理解会越来越多，更怕由于异地而导致某些伤口可能会更加扩大。我不是那种会逗人开心的人，即便是在感情面前，到目前为止，我还是白痴一个，唯一学到的一点知识也只是和你相处的短暂几天，我不太会表达，即便是现在所发的这些信息也只有我想法很小的一部分，很多话，我不知道怎么说，也不知道如何才能让你感受得到。<br>    我曾跟你说过，我对未来想得很远，我会对当前的现状加以判断才会做出我的行为，我一直觉得我们两最大的障碍将是物质基础，这个短时间之内无从改变，但是我也希望通过感情来抵消物质所在的占比，但是异地这个困惑无数情侣的问题，我们始终没能摆脱，他还是让我们两产生了各方面的猜疑和情感交流障碍。但是，如同圣人所言，如果感情足够深，很多事情是不会出现的，但是我们却没有太多的前期相处，很多方面可能根本就没认真的了解过彼此，所以，我只能尽我之力，来填补其他可以弥补之处。</p>
<hr>
<p>在乎，特别是对于我，是一个不会挂在嘴边的东西，对我这样嘴烂的人来说更是如此，即便是想你，很多时候我都是通过亲亲的表情来表达。我真正在乎的是两年之后的我们，是否能解决外在的物质基础，是否能顺利的过上我心中的小康生活，不受困于父母，不劳于子女，不累于工作，我希望尽量避免那种以身体来挣钱而再以金钱养身体的生活，即便是有，我也希望只是我一个人的。你常说我是程序员，我们程序员里面流行一句话，“挣得多，死的早”就是这样的，即便现在我已经不是所谓的程序员，但是这种问题还是困扰着包括我在内的大多数中国人，特别是那种没有家庭背景的。所以，说的俗一点，我现在就想往钱看。</p>
<p>人们常评价一个人成功的标志是爱情事业双丰收，其实就目前而言，虽然我不知道你的想法如何，但是在我心中我其实已经把爱情作为丰收项了，我只是在努力让这个爱情显得更有价值，让别人、让对方在不远的将来不会觉得后悔，要知道失败的滋味一个人体味并不是很苦，如果未来是一个人流泪，我宁愿是一个人。但是成功的快乐两个人感受却会有双倍幸福。</p>
<p>另外相对于我们，我更在乎你，这个“更”字可能会让你觉得我很虚伪，要知道一个人除了父母之外，没有人会百分之百更在乎她，但是，我这里的在乎可能和父母的在乎有一定区别。或许我是真的很爱你很喜欢你，也或许我是已经把你当作未来的老婆来看待，作为我本身而言，可能是一种叫做自尊心的东西，我不希望看到我的亲人以后被人压着，没有自信，毫无自豪感。因而，我希望你以后会更快乐，这种快乐既包括做自己想做的工作，有闲暇时间做自己想做的事情，有一定的条件去做放松自己一切的事情，能够达到别人艳羡的程度，而不仅仅是一个妻子一个未来的母亲，一个可能奔波于各种琐事的劳苦人民。即便是如今的工作，我知道你工作很累我也很多时候对你说过找一个轻松的工作，但是最后我想了想，现阶段，我没实力养活你，我的这些话反倒成了一句句虚话、空(控)话，也就不再说了。最初的时候，我甚至想让你去考研，因为我自己始终觉得女生是不需要提早挣钱的，挣多了你给谁花呀，另外研究生也没有任何负担，三年的时间可能会让你选择一个既喜欢又轻松的工作，到时候的很多都是你选择未来而不是未来选你。</p>
<p>这两天也想了想你的话，你感觉不到我很在乎你，可能我确实对这方面的关心太过随意了，从心理上没有感觉到你是否需要这方面的关心，导致每天晚上我都是完事之后回到宿舍才想到给你打电话，这也就导致很多时候是你主动找的我，这方面确实我的错，我无法将其归罪于我的性格问题，而确确实实是因为我的心没有从往常的身份向男友的身份转变，这方面我会改变，就像做菜一样，我现在很差劲，还希望你能多调教。另外，你每次激我我的反应可能确实让你心冷了，但是这个确实是我当时的心理和你想的有所不同，我心情五味杂粮，又对你的想法猜错有误，才导致我没有做出任何回应，甚至有了糟糕的言行。所以以后这方面我会注意，也会更加在乎你的安慰。但是也请你多体谅你这个在你面前极度自卑的男友，尽量减少这方面的刺激。</p>
<p>我还有很多的话想对你说，但是时间很晚了，蚊子都睡醒了，屁股似乎也肿了，所以我现在只想多抱你几次，不想说太多的无用之语</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>心绪</tag>
      </tags>
  </entry>
  <entry>
    <title>一千公里</title>
    <url>/2018/10/29/%E4%B8%80%E5%8D%83%E5%85%AC%E9%87%8C/</url>
    <content><![CDATA[<blockquote>
<p>山随平野尽，江入大荒流。</p>
</blockquote>
<p>按理说，过去的两天是如此地劳累，以至于我今天应该提前下班，早早收场，大睡他一番。但是，突然之间，我总觉得需要做点什么，需要写点什么去记录两天的美好时光，需要再去回味一下两天里的情情景景。但是，突然提笔，才发现，心里想的和肚子里的墨水不在一个水平，粗鄙的词句完全无法畅快的表达我此刻的心情，更不用说是优美的文采，华丽的乐章。但是，我还是要写点什么的，就像一个人的成长一样，令人记忆犹新的往往并不是那些精彩绝伦的画面，相反确是那些尴尬无比的场景，在之后的很多年里作为回味的笑柄，作为家里人谈笑的谈资。</p>
<hr>
<p>起笔之前，我都不知道起个什么标题，“北京武汉两日游”显得太粗俗老套，“跨越千里的旅程”又太过娱乐化。稍作思忖，身为一个极简派之人，姑且标题也暂且极简吧，就定为“一千公里”。一千公里表面上指距离，其实更是时间，对于光速，它不到一秒，对于飞机，不过两三个小时，对于动车也只有五六个小时，但是，人生，总有那么些“挫折”，没钱，坐个直达就不错了，而且，有时候直达你都不一定买的上票。所以，人生之路还是很艰难，所以，现在定个小目标，好好奋斗吧，希望以后能够<em>暴富天天坐飞机</em>(不在两地跑)。</p>
<p>虽然路途有点遥远，但是遥远也带来另一番感受，其中的旅程能够让你真真切切体会到社会的差异以及地区的差异，另外加上各种阅历不同的人在其中产生的各种各样的奇异事件，偶尔会让你灵感大发。虽然很差钱，但是由于自己每天只啃一个包子，还是攒下了不少钱，所以，出发的选择还是锁定为高铁，522元软妹币，用出去的瞬间，我感觉我这一辈子的包子都被它吃光了！这样的话，以后还咋活，只能啃鸡腿度日了。但是高铁并没有我想象中的那么好，这里的好并不是指舒适度，而是，我感觉我的钱只是买来了节约的时间，却没有得到这段旅程的该有的收获，毕竟五个小时，我竟然看着旁边的“大佬”写了三个小时的ppt，还是英文的…（天呀，我有时候感觉做高铁的好像全是精英，不自觉的开始仰慕，但是环顾四周，发现还是有很多人像我一样盯着手机刷新闻，打游戏。说明，我们其实我已经融入这个群体。另外我发现，高铁打游戏并不是很卡，比普通列车强多了，这个钱花得也值-可能是错觉-o-）。与出发的顺利完全相反，返程的艰辛可能是我今生遇到的第二次（第一次我忘记是啥时候了，但是我敢保证这绝对不是第一次，毕竟还不算痛苦，我觉得我还可以再来一次-.-）。返程的票，提前一周就没有买到，还是买的中转+段尾补票（汉口-郑州，郑州-石家庄（中途补票直接坐到北京）），很不幸，不单单需要中转，两段路程全部为无座，天，真踏马舒服！估计这样下去我还能再长100mm，顺利突破180，迎娶白富美(小时候家里人说站着吃饭长得高)。还有另外一件极好的事是，之前买的马扎还可以继续用！真担心只用一次，那就太浪费了。</p>
<hr>
<p>返程虽然不太顺利，但是整体感觉还是蛮好的。因为，在这一路途上，我发现了很多的技巧，可以在将来继续使用。第一趟火车是从汉口出发前往郑州，可能是因为之前玩的太过亢奋，加上出发前没有午睡，导致到了站口，就掐不住了，此时的我未出发就先累倒，我已经开始为我的身体担忧担忧，我不知道我还能不能回到北京，还能不能吸上雾霾，还能不能再见城市的浮力唐璜，但是我还是强忍着喝了一罐椰奶，走上了“货”车。</p>
<p>对于不常坐火车，以及经常买不到票的同志，今天博客中也要分享一些我的经验：</p>
<ol>
<li>首先，所买的火车票如果没有，但是实在要回家，可以买当前列车的短程，或提前买几站，然后上车补票。</li>
<li>另外，即便是无座，早点上车，往卧铺方向走，找补票的列车员补票，很多时候都可以直接补到卧票或者坐票，可能很多人在这个时候会退票（具体原因不明，我当时上车无座，但是前前后后给十多个人补了卧票，排到我却没有了。但是我会守株待兔，不过多时又多出两个~），注意出门在外最好备两三百块现金，补票可能只收现金。</li>
<li>多余的：花10块买个板凳！我见到太多的人，买的长途无座，却不买板凳，等着上车补卧票。最后累得快要瘫痪。</li>
</ol>
<p>最后晒一张我的车票：</p>
<hr>
<p>做菜：<br>本打算回去做点啥，但是事情往往和你想的不一样。想起一个笑话：说一个贪婪之人突然得到一个神灯，神灯可以满足他一个愿望；于是此人便说：能否给我一点钱。上帝：一点是多少。此人回：一个亿。上帝沉思片刻觉得也就一个小目标的事，看了看手上的复古画表回：稍等我一会。此人问：一会是多久？上帝转身回眸：爱你的一万年。就像你所谓的一点只是一个亿，而上帝的一点却是一万年，一点时间一点钱。都是一点却含义不同。我以为我回去能做点宏伟的事情，却发现回去就只烧了两个菜：一个瘦肉茄子，一个韭菜鸡蛋饭。而正是这两道菜才终于让我认清了自我，让我知道其实我也能做个菜，做菜也能这么难吃，能把老抽当做白水，能把食盐当砂糖，却不知水多了能加热，糖多了只是甜。但是理论上来说，做菜步骤还是很完美的，出锅前的99%时间都是完美的，有时候色相甚至超过网上大厨，但是直到最后1%，我才体会到，原来做菜也是有二八定律的，往往最后的20%才是决定胜败的关键！</p>
<p>由于手机无电附图明日再传：</p>
<hr>
<p>还有啥事可写？我先想想。。。</p>
<p>好像没啥时候，总结下心情吧，记录下每时每刻的自己。<br>回望这两天，不知道我的选择是否对错，也不知道之后的发展能够向好，更不知道黑暗的世界到底是何样子，我不懂，对面也不懂，可能对面很懂，但是我却不懂，也可能我已经懂了，只是有点飘飘然如遗世独立，不知能否羽化而登仙。前途依旧动荡，心里依旧起伏，晚来的迟早会来，多余的所思，对于事态的演化是毫无作用的，顶多，也就减缓前进步伐，或是给无知的心脏多添几粒脂肪。</p>
<p><em>革命尚未成功，同志想要努力</em></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>北京</tag>
        <tag>武汉</tag>
        <tag>情感</tag>
      </tags>
  </entry>
  <entry>
    <title>tensorflow-seq2seq知识点梳理</title>
    <url>/2018/09/27/tensorflow-seq2seq%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>接触python已有两年之久，零散地使用tensorflow也将近一年。但是是指今日，如果让我重新建立一个项目，我仍是无能为力。有时候，我会有一种感觉，python这种语言就像是一个无底洞，你永远不知道它在不同的场景中有多少不同的变化，更可怕的是，你无法知晓其中的错误，它是如此的“灵活”，以至于很多的检查都需要依赖程序员自己，而这些错误有时候是很难检查的，特别是对于初学者而言。但是，这又是一个很容易入门的语言，因为，不管你是什么专业的人，你都可以用10行以内的代码做一些简单地事情，而不需要太多的系统知识或者规范。</p>
</blockquote>
<blockquote>
<p>由于python知识点太过散乱，往往是学了后面忘了前面，所以还是要写一些总结加深印象，由于系统的总结可能太过于漫无目的，而且时间成本过高，所以，暂且以一个小项目为首，将其中的流程知识点串起来</p>
</blockquote>
<ol>
<li><p>项目背景<br>项目为一个seq2seq架构，seq2seq架构是一种序列到序列的预测模型，即通过输入和输出都是序列。通常是用在自然语言处理中，比如翻译系统，输入为一维中文，输出为一维英文。改进版也使用在音频处理和图像处理上（这里面需要将音频特征、图像转化为序列形式）。</p>
<blockquote>
<p>输入为一个单词，输出为此单词的字母顺序排列；比如输入为hello，输出则为ehllo</p>
</blockquote>
</li>
<li><p>占位变量tf.placeholder</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">inputs = tf.placeholder(tf.int32, [<span class="literal">None</span>, <span class="literal">None</span>], name=<span class="string">'inputs'</span>)</span><br></pre></td></tr></table></figure>
<p>tensorflow中，由于我们是首先建立训练模型，后定义真实的输入数据。所有需要占位符来表示需要输入的未知变量，解析如下：<br>Args:<br>    dtype: 数据类型-The type of elements in the tensor to be fed.<br>    shape: 数据维度，一般为[批大小，序列长度,]-The shape of the tensor to be fed (optional). If the shape is not<br>      specified, you can feed a tensor of any shape.<br>    name: 数据名字-用于在tensorboard显示标注-A name for the operation (optional).</p>
<p> Returns:<br>    A <code>Tensor</code> that may be used as a handle for feeding a value, but not<br>    evaluated directly.</p>
<ol start="3">
<li>tf.contrib.layers.embed_sequence(ids, vocab_size,  embed_dim)<br>词嵌入，一种one-hot编码的改进版，即将单词映射成数字表示，然后将数字转换为嵌入矩阵向量。</li>
</ol>
<p>Args:<br>    ids: 形状为[batch_size, doc_length]的int32或int64张量，也就是经过预处理的输入数据。<br>    vocab_size: 输入数据的总词汇量，指的是总共有多少类词汇，不是总个数<br>    embed_dim：想要得到的嵌入矩阵的维度(自主设定，表示嵌入广度)</p>
<p> Returns: [batch_size, doc_length, embed_dim]<br>     Tensor of [batch_size, doc_length, embed_dim] with embedded sequences.</p>
<ol start="4">
<li>tf.nn.dynamic_rnn</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">encoder_output, encoder_state = tf.nn.dynamic_rnn(cell, encoder_embed_input,</span><br><span class="line">                                                      sequence_length=source_sequence_length, 			dtype=tf.float32)</span><br></pre></td></tr></table></figure>
<p>这里的dynamic_rnn即构造循环神经网络，但是相对于传统的RNN有一定的改进，对于一般的RNN，对于输入序列，我们是强制性统一到最大长度，对于短于最大长度的进行补齐，但是这样会带来一个计算问题，所以这里使用了dynamic，动态RNN，它增加了一sequence_length输入参数-序列长度，这样，计算时只取当前长度的数值进行计算，输出时只保留当前长度的输出<br>参考：<a href="https://blog.csdn.net/u010223750/article/details/71079036" target="_blank" rel="noopener">https://blog.csdn.net/u010223750/article/details/71079036</a></p>
<ol start="5">
<li>tf.strided_slice</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ending = tf.strided_slice(data, [<span class="number">0</span>, <span class="number">0</span>], [batch_size, <span class="number">-1</span>], [<span class="number">1</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p> Args:<br>    input_: A <code>Tensor</code>.<br>    begin: An <code>int32</code> or <code>int64</code> <code>Tensor</code>.<br>    end: An <code>int32</code> or <code>int64</code> <code>Tensor</code>.<br>    strides: An <code>int32</code> or <code>int64</code> <code>Tensor</code>.</p>
<p>对数据矩阵进行切片，strides一般为全1值，这里的意思相当于切除最后一个字母。<br><img src="http://osiy4s0ad.bkt.clouddn.com/soundblog/1538035875521.png" alt="enter description here"></p>
<ol start="6">
<li>tf.nn.embedding_lookup<br>输入张量映射</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 得到映射嵌入[128,?,15]/[128,length,15] = lookup([30,15],[128,legth])</span><br><span class="line">decoder_embed_input = tf.nn.embedding_lookup(decoder_embeddings, decoder_input)</span><br></pre></td></tr></table></figure>
<p>第一个参数为映射字典，第二个参数为映射索引</p>
<ol start="7">
<li><p>tf.identity(input, name=None)<br>tf.identity就是为了在计算图获取这个值而创建的虚拟节点，只是用来获取中间值</p>
</li>
<li><p>tf.contrib.seq2seq.sequence_loss<br>Args:<br> logits: 训练输出的概率矩阵-A Tensor of shape [batch_size, sequence_length, num_decoder_symbols] and dtype float. The logits correspond to the prediction across all classes at each timestep.<br> targets: 真是输出值-A Tensor of shape [batch_size, sequence_length] and dtype int. The target represents the true class at each timestep.<br>用于计算加权交叉熵损失，<a href="https://blog.csdn.net/chaipp0607/article/details/73392175" target="_blank" rel="noopener">加权交叉熵参考</a></p>
</li>
<li><p>梯度计算和网络更新</p>
<ul>
<li>梯度计算：gradients = optimizer.compute_gradients(cost)</li>
<li>网络更新：train_op = optimizer.apply_gradients(capped_gradients)<br>  将梯度应用在变量上，返回此操作。即：使用该梯度进行权重更新</li>
</ul>
</li>
<li><p>tf.clip_by_value(grad, -5., 5.）<br>数据截断，这里主要为了梯度裁剪：约束梯度值，防止梯度爆炸/跨度过大。是梯度范围限制在-5~5</p>
</li>
<li><p>sess.run()<br>Args:<br>  fetches: 元组：一些用于计算结果的张量，用于去除计算结果tensor （比如我们要求姐y=w*x中的w，这里的fetches相当于y）<br>  feed_dict: 字典：输入变量占位符 （这里的feed_dict相当于x）</p>
</li>
</ol>
]]></content>
      <categories>
        <category>ML/DL</category>
      </categories>
      <tags>
        <tag>端到端</tag>
        <tag>神经网络</tag>
        <tag>seq2seq</tag>
      </tags>
  </entry>
  <entry>
    <title>见多识广——再谈见识</title>
    <url>/2018/09/19/%E8%A7%81%E5%A4%9A%E8%AF%86%E5%B9%BF%E2%80%94%E2%80%94%E5%86%8D%E8%B0%88%E8%A7%81%E8%AF%86/</url>
    <content><![CDATA[<blockquote>
<p>一个人的一生时间极其短暂，如果仅仅凭借单纯的努力，即便劳苦一生，你可能连上一阶级的起跑点都达不到。有时候，如果没有一点见识，你做的许多选择都是错的，盲目的努力都是无用之功。</p>
</blockquote>
<p>最初看到这篇文章，是在一个公众号里面提到的，当时的感触之深，让我在半天之后就买了这本书，我向来不是一个特别喜欢读书的人，但是如果书的语言对口，再加上我感受到了真真切切的受益时，我就会无视腰包之空瘪。</p>
<p>书的内容核心其实只有一个，即见识。但是书的篇幅却有很多，实际上而言，很多篇幅是不需要存在的，但是这些篇幅的存在却恰恰是为了说明，见识的重要性。见识不仅仅是自己的人生阅历，也是别人的人生阅历，这也是学习真正的作用。你需要在最短的时间内积累前人的经验，而将其用在之后的经验之中。但是，经验的得来并不容易，读书其实是最容易的途径，但即便是这，超过80%的人都做不好，更不要提很多稀缺的资源，如父母亲戚的指导、朋友圈的影响等等。</p>
<p>由于我对本书只是通读一次，所以并不太熟，暂且按着类目来抒发自己的感受</p>
<hr>
<p>“命和运决定人的一生”——这是文章的开头语，基本上总结了一个人的一生，即：大多数人即便很努力也基本上不会有太大的改变，相反，如果规规矩矩，也不会差到哪去。即一个人的出生已经决定边界的返回，就像古希腊的城邦，很多人即便再多努力，也不会走出城邦的范围，因为当前的视野和周围的环境，已经限制了你，没人告诉你通往外界的道路，因为他们自个也不知道，他以为世界就这么大。但是，这句话本身也需要排除少数例外。</p>
<p>“自私”很重要，这是我对第一章提炼的观点。当然，这里的自私和平常所说的自私并不一致，但是也有相似之处。我所谓的自私，即一切以自我利益为中心，但是同时不伤害到他人的利益。。初看这句话，很多人些许会感到疑惑，觉得很多时候双方的利益一定是对立的。确实，这种情况也有，但是，如果这种对立的情况发生，我想完全有另一种方式来解决，比如，都放弃自己的利益，这样完全可行，毕竟很多利益是可以完全放弃的。（这里的思想类似于一个贪心算法，即为了全局的最大利益，最好的方法就是每个人是尽量得到自己的最大利益，那么，整体的利益即便不是最大值，也会接近最大值）<br>中国人向来把“大公无私”、“舍己为人”等作为自己的优秀精神，但是很多时候后这种无私，这种舍己，却导致了更加残酷的结果。多少人成年人为了救人自己舍命，却丢下一家老小；多少人为了减轻亲人负担，放弃了向上的机会，而这些机会将会在不远的未来给他们带来重大的改变，当前的辛苦也将结束。</p>
<p>见识的重要性。这几年，时常有个话题被提起，就是那些当年的高考状元，最后都销声匿迹了，很少有最初伟大成就的人。这导致很多人开始对我们的教育产生怀疑。但是，成功的前提是有很多因素决定的，很多时候，智力只起到一个基础作用，而那些真正成功的人，往往是把握时代节奏的人，而这些往往取决于见识。但是，这也并不是说，那些状元一无是处，既然能考上状元，其见识、眼界和思维方式，也不是一般人所能匹敌的，而这些人，大多数也活跃在社会的高层，虽然不是最高层,也够很多人“望其项背”的了。</p>
<p>以上写于2018.8.30，由于觉得言语太过繁琐，并未在写。今日，闲暇无事，又有了新的体会，暂且补充一二，发表了，以免以后再看到，心烦。</p>
<p>上周末，和本科舍友一起闲聊了一下，他所在学校正在北邮，所以我们就按心索路，溜到了旁侧的北师大，恰巧最近开学，当时学校也正在进行“百团大战”的招新，但与我们本科时遍布技术和行为艺术所不同，这里样板好像更多，琴棋书画自不必说，从地理、生理、心理、伦理到各种音乐舞蹈，但这里的音乐舞蹈又和我们所不同，他并不是单单是吉他，更多的是古琴、笛子还有二胡，如此，我更想到之前看台湾地区“领导人”马英九的一个娱乐活动，从言语中无不透露出一种儒生气质，一种极深文化修养，那种修养不仅仅是口头上的谈吐，更是一种言语中表现出的逻辑思维，这种逻辑思维，未有一点见识或者思想阅历是不能体味的。</p>
<p>因此，作为理科生，更有甚者作为一个IT届认识，有时候，我们很可悲，我们受限于一个理论的世界，而对外界的艺术气息一无所知；我们受限于我们自己的圈子，常常把IT行业的春天作为自己的春天，却不知很多领域四季如春；慢慢的我体会到一句话：如果你对别人的世界所致甚少，而他却却对你的世界了如指掌，那么你永远都可能是错的。所以，阅历很重要，如果你只是一个单纯的猿猴，一生沉迷在自己的数据结构里，那你永远都玩不转人生更多的算法，况且很多人连基本的数据结构都一无所知。</p>
<p>一个人的一生总是在经历后才知道错过了什么，而这之前往往不屑于顾。了解的越多，见识越大，你才会知道其中的对错。</p>
<hr>
<p><em>科学技术是第一生产力，但是生产仅仅是人一生中很小的一部分</em></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>成长</tag>
        <tag>眼界</tag>
        <tag>见识</tag>
        <tag>运气</tag>
        <tag>努力</tag>
      </tags>
  </entry>
  <entry>
    <title>电影感悟-豆瓣TOP3</title>
    <url>/2018/08/20/%E7%94%B5%E5%BD%B1%E6%84%9F%E6%82%9F-%E8%B1%86%E7%93%A3TOP3/</url>
    <content><![CDATA[<blockquote>
<p>物质基础决定上层建筑。而是多年的时间里，我慢慢认识到这句话的内在含义，也慢慢开始懂得，一个人的价值不仅仅是由其本身创造，还附带他所有的一起资源，即便是家庭背景、社会阅历、周边朋友，都是其价值的体现，所以，有时候，这个社会很多不公平其实是公平的，因为每个人都会不同，别人有的你没有，你有的别人也会没有，完全靠之后的努力，是否可以弥补。就像别人有背景，你没有，你有才华智力，别人可能第一点。如果找女朋友，别人并不比你高一等级，你也不要抱怨别人比你有钱，因为这两个分属不同的领域，都是你的价值体现，如果说，你的这个价值显得低了一些，只能说对方侧重点不同，或者别人在乎的重点不同。而价值本身并没有高低之分，也不存在公不公平</p>
</blockquote>
<hr>
<blockquote>
<p>从农村到硕士，二十多年的时间里，我像一滴水，从一滴汇入小溪，然后汇入小河、大河、小江、大江、最后进入长江，涌入大海，其中的经历，非常平淡，但是慢慢发现，很多一起的小伙伴都停止了下来。而其中的性格养成也变了，有时候我会发现，国家好的物质生活条件好像全都是为了城里人而培养的，从小学全部都是农村人；到了镇里，开始有了一部分城里人，但是也还是少数；初中，城里人开始在优等班占据过半席位；到了市里，班上城市人开始占据重要地位，但受到分数决定论的影响，这是席位并不是很多，因为很多城里人在分数上是拼不过农村人的，但是他们很多人都很有才艺，而这些高考并不占比重，有时候感觉高考对他们简直“太不公平”；进一步，进入了大学，一切都变了，大学唯才就有出头之日，农村人在其中开始寥寥无几，即便有部分农村人能够依靠自己的强大学识占据一定影响，但是很多的活跃确实由城里人创造，直到这个时候，我才发现，我的缺点众多，只会学习，琴棋书画一窍不通，不仅仅如此，对于大部分农村人而言，极低的眼界使得他们处处碰壁，这更加剧了他们的自卑、犯错。眼界是个很重要的东西，这种东西，需要长时间的教导培养，而身处乡下，很多父母都不会懂的这些，一个简单的例子，很多人会热衷于去兼职，去赚钱，但是，很多人仅仅是为了赚钱而已，如果只为了赚钱，读大学又是为了什么。有时候，我发现，农村人之所以越来越落后于城里人，在于一个根本原因，这些人，很多都连基本的价值都判断不了，他不知道取舍，不知道选择，不知道思考，不知道如何什么东西该做，什么东西不该做，那些是正事，哪些只是在浪费时间。</p>
</blockquote>
<hr>
<blockquote>
<p>因此，我希望从现在开始，不仅仅练习我的表达能力，也希望能够培养自己的阅历，培养自己的知识，培养自己的事物认知。对于我们，获得这些最短的途径就是书籍、电影、文化娱乐、等等。今天，先从电影开始。</p>
</blockquote>
<p>大学读了很多书，豆瓣电影大部分也都刷完了，但是很多东西如果不去总结，就认识不到其中的内涵，所以，暂且将其记录，获取能再次汲取新的东西</p>
<p>《肖生克的救赎》，主角讲述银行家安迪，被误判坐牢IDE，最后通过努力获取自由的故事。在谈论此片之前，我想先说下我的电影观。首先，任何一部电影，虽然其中的故事，大部分人都不会接触到，倒是，其中的很多道理确是大众性的，值得每个人去品位。看过本片，或者打开百科说明，都能知道本电影的主旨在讲自由，但是，今天我并不想讲自由，因为，自由这东西太难解释了，在不同的社会环境，不同的阶级条件下，对于不同的人，自由的体现也是不同的，基本上是很难去给一个和你不同频道的人去解释，有时候，反而会带了彼此的痛苦，戳伤历史的疤痕。与此相反，我想探讨一个积极的问题，即人的全才，全方位发展的人才。<br>人无完人，这是从小就知道的道理，但是对于一个向上发展的人来说，我们的目标确实是做一个完人，当然，今天我说的完人也并不是德智体美全面发展的“全人”，只是指那些可以为了实现一个目标，而去清除道路上的所有缺陷的人，就比如电影中的安迪。为了逃跑，他能够想出一切办法，他能够将其之前的所学应用到其他领域，来助其成功逃离。有时候，我会特别崇拜这种人，特别是在走过人生二十多年后的今天，身边的变化“触目惊心”，让我觉得那些生存在金字塔上方的人士，那些占国家2%的人群，其实是相当厉害的，而不仅仅是智商上的聪明而已。他们能在生活的各个领域达到顶峰，即便是再某一方面落后别人很多，也会通过在其他地方的优势弥补上来，如果理解了这一点，也就不难理解，为什么当今社会寒门再难出贵子。这其实是社会的必然，即便是出生于寒门的我，在今后的生活中我也不会过多的支持寒门，说实话，相反我可能会更支持那些生活条件好的，因为，出于我个人的理解和我的利益，我深知寒门所受到的限制，不仅仅是物质上，更是思维上，要知道，物质很容易改变提高，但是思维见识是很难在短期内得到提高的。就如同电影中的安迪，他的出生很大概率（概率）上不会出生于寒门，因为在其相对短的人生中，如果没有在前20年或者30年里积累大量的生活经验和知识，将很难应付之后的很多事，他不可能懂得这么多的法律，也不会了解很多的书籍，虽然这种事对于寒门并不难，但是很多潜在的知识，寒门子弟是很难体会到的，即便是简单地人事处理上，都可能没他那样处理细微。<br>全方位，这个词在中小学的教育中就已经提到过，但是很少人真正的实施了，或者根本没有实施的基础，而能够实施的都是那些城里的孩子。很多时候，回过头，我会发现，在上大学之前，很多时候都是凭借成绩来定胜负，但是到了大学，我突然发现，那些除了成绩啥也没有的，大多数时候都会没落，当然也有少数真的很努力拼搏的，但是对于大多数人而言，是受不了自卑带来的打击的（我说的并不仅仅我自己-.-）。之所以导致这个结果，根本在于一个人的教育，教育不仅仅只有成绩一个指标，它还应该包括艺术细胞的培养，文学细胞的形成，见识和思维的拓展，无数生活经验的积累（不是只有经历才是经验，读书就是获取经验最快捷的方式）。如果能完完全全做到这些，其实在生活中就是另一个安迪，将会游刃有余。</p>
<p>《霸王别姬》，这个电影时间跨度特别大，类似的影片还有《活着》，这种电影千万不要将其内涵固定在一个剧情点，而是要将其展开在历史的长河中，其实它就是一个人生的经历，每个人都可能经历的人生。即任何人的生活很大概率上都不会一帆风顺。<br>我虽然不熟悉历史，但是对于历史上的朝代战乱多少还是有一些了解，纵观中华三千多年的历史，能够保持在100年以内不出现动乱的很少很少，也就是说，这么长远的年代，没有多少人真正能够一帆风顺，这还不包括其他各种自然灾害。<br>所以，人生很长，如果稍不注意就会有你的好受；有时候即便注意，你也防不胜防。影片的年代历史基本上也和《活着》类似，从民国时的军阀动乱到建国后的文革时期，其中发生的各种惨案，大多数人都避免不了，这就相当于天灾一样吧，一段时间一个轮回，逃不脱也走不掉。所以有时候在想，即便今天人们的生活很舒适，但是细想一看，我们可能和唐朝的贞观之治执念差不多，以相对均方误差来看，我们也是很看尽近些年的幸福指数最好的时候。</p>
<p>《这个杀手不太冷》，这个电影我很喜欢，喜欢那个大叔，因为我发觉我有时候就是这种大叔的性格，但是我并没有大叔这种能力–。虽然本片是个讲述杀手的电影，但是有时候，我将其归为一种爱情或者生活的剧情。因为我始终觉得杀手也是一种职业，职业在我这里不存在好坏，只存在你是否触犯了法律。（可能有人对这句话有点懵逼，或者觉得我是个傻瓜。如果你是认真想一下我们的法律，或者法律的宗旨，就会明白，法律是为了使得所有人的利益都不受到侵害，如果被侵害了就要拿出一定的代价去赔偿），所以，有时候杀手为了保护更多的人或者为利益最大化的多数人（这里的利益不是简单地加减，比如一个人要干掉你全家，这种概率的发生已经很大了，特别是黑帮生活，那你就可以以死相拼）。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>人生</tag>
        <tag>成长</tag>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title>学期总结-2018年上</title>
    <url>/2018/07/22/%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93-2018%E5%B9%B4%E4%B8%8A/</url>
    <content><![CDATA[<blockquote>
<p>从现在开始，我需要养成一个写作的好习惯，之所以培养这个习惯，是因为：我开始发现我的一个重大缺陷——语言表达能力的欠缺。这种能力，在一般生活中并不会有太大的作用，而且很多时候，大部分人都体会不到其所带来的“破坏”，这种破坏，会让你的交际陷入阻塞，职场陷入瓶颈，生活面临窘境。</p>
</blockquote>
<p>我不太会写总结，每次写给导师的月报也都是在最后的几天草草完事。而且有时候，总结总得去找些有趣的、或者有意义的事，来丰富其中的内容，而对于宅男来说，这种事基本上是很难找到的。所幸，今年与往年有所不同，今年父母大丰收，环卫“地球”事业再创记录，而本人事业之“外”也达到了新的高峰，所以，也算值得庆贺。</p>
<p>我是个喜欢做规划的人，也是个喜欢做选择的人，所以，整个学期都是按照之前的规划，多多少少的按部就班完成，但是还是存在大量逾期、欠款。</p>
<p>学期开始，我就给自己制定了“三步走”的发展规划，即研究生语音分离方向只是稍微带一点，并不会倾注太多的“心血”，另一边我会集中力量去为了工作而学习，去学习自己觉得应该学习的东西，或者说是为了自己的前途、兴趣。我是个喜欢思考未来，并且会不断根据时势来进行选择的人，我不想去做未来行业的炮灰，对于我们这些没有深厚根基的人来说，失败对于我们来说只有一次，过后就没有再次尝试的机会。马某曾经说过，“光脚的不怕穿鞋的”，但是对我而言，我可不想在奋斗大半身之后还是个光脚的，而别人不光穿上了鞋，还穿上了阿迪达斯、耐克什么的。</p>
<p>所以，我另外一个目标就是学习大数据、或者数据分析方向，之所以选择这个方向，因为我有java相关的很多基础（数据库-机器学习），我希望在保有javaweb知识的基础上，稍微向着大数据数据分析方向发展，这些也不算是大的转行，而且也至少有一个保底的后台工作，进退都是可行的。所以，目前而言，我的研究生方向大概就是：语音分离、Java后台、大数据分析。而这三个都在这一学期中开始有了点滴前进。</p>
<p>语音分离：这是个很火的方向，相对于人工智能其他的方向，如图像，国内做的人还是“相对”少的，应该不会出现人才供大于求的状况（中国人太多了，一年时间，你还没反应过来，这个行业就已经差不多饱和了，后进来的就只能做一些数据标记的打杂工作）。但是令我真正担心的是这个方向本身的问题。对于方向本身的前景，我持怀疑态度，对于方向难度，研究生是否能够胜任，我也持怀疑态度，即便是对于目前语音方面做得最好的科大讯飞，他们的盈利情况，是否很大，我持大大的怀疑态度（一个靠吹气球膨胀的公司）。相对于图像而言，语音转文本的难度应该算是难很多吧，其中可能不仅仅涉及语音还要设计NLP方面的知识，而这些知识，即便对于一个博士生都是很难在学业期间完成的。另外，其中的市场到底有多大，难道只是个语音输入法？智能家居？也不算是，用处倒也是很广，但是目前的算法效果其实已经达到一定的顶峰。有时候，我也在想，毕业找工作也可以利用在深度学习领域的经验，向着其他AI行业发展，也是个不错的选择，但是，我对此行业太悲观了。这倒不是我根本不了解此行业，只因我看到太多的炮灰研究生博士生，他们利用无比黄金的三年亦或五年，研究的东西都是只停留在论文价值上，没有丝毫的实际价值，最后的工作也大多数与相关领域无关，即便有关，最后这很小的部分，中的大多数也是在其中打着酱油。（相关领域恐怕只有国内的top7能够做点实事）</p>
<p>AI方向确实做出很多成果，但是只限于少数的领域中的少数的场景，而且一定程度上而言，很多都不算是真正意义上的AI，只能算是数据分析或者传统的统计学领域。</p>
<p>后台开发：作为本科找工作的方向，这个方向的“从业”时间应该算是很多了，但是自身的问题也很大，对于自己的知识，最初学习java应该是在14、15年就开始了，但是在这大概三四年的时间里，我却并没有太大的进步，和毕业三年的人相比，我在800里开外。因此这方面还要再穿透点许多其他的知识，以巩固其核心地位。但是我也遇到了一个很大的问题，我总是不能够很仔细的看书，亦或是无法将书本的知识记忆下来，总是在一遍又一遍之后才能达到潜移默化的程度，导致花费了太多的时间做了太多的重复性劳作，而且，有时候感觉并无益处。</p>
<p>大数据分析：我记得我当时选专业时，准备报考经济方面的专业，为此我还买了本《经济学原理》。虽然那时并不是很懂这一行，但是我总是感觉我对金融数据很感兴趣，特别是数学。因此，在上了研之后，偶尔也会处理一些数据问题，开始慢慢发现，数据中的金币价值远大于其他行业的价值，而数据的价值在没有发觉之前是没法显现的。</p>
<p>下学期开始就要正式进入语音合成的领域了，困难倒还是有，但是最大的困难并不在于其理论有多复杂，而在于，我对这方向前景的担忧。有时候，如果你不做你的选择，你就会变成别人的棋子，一旦失败，对别人而言只是浪费了一个棋子，对你而言，可能是今后一生的前景。我需要选择那个方差最小的方向。</p>
<p><strong><em>多个方向多条路，少个方向，不用走岔路</em></strong></p>
]]></content>
      <categories>
        <category>时光回收</category>
      </categories>
      <tags>
        <tag>2018</tag>
        <tag>学习</tag>
        <tag>规划</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程实战15-重排序、happens-before</title>
    <url>/2018/04/17/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9815-%E9%87%8D%E6%8E%92%E5%BA%8F%E3%80%81happens-before%E3%80%81final/</url>
    <content><![CDATA[<ul>
<li>指令重排序<br>为了优化CPU的运行效率，在条件允许的情况下，直接运行当前有能力立即执行的后续指令，避开获取下一条指令所需数据时造成的等待3。通过乱序执行的技术，处理器可以大大提高执行效率。<br>比如：对于如下代码</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">int <span class="selector-tag">a</span> = <span class="number">10</span> <span class="comment">// 1 </span></span><br><span class="line">int <span class="selector-tag">b</span> = <span class="number">100</span> <span class="comment">// 2</span></span><br><span class="line">int c = <span class="selector-tag">a</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>实际的执行过程可能会是：1-3-2，而不是：1-2-3；因为第一步获取a的值后，第三部仍然需要使用，此时，由于第二步并不会干扰单线程下程序了逻辑，将会直接执行3，再执行2.避免二次读取a值。（只是说明可能的原理，例子并不一定正确）</p>
<ul>
<li><p>数据依赖性（as-if-serial）</p>
<ul>
<li>As-if-serial语义的意思是，所有的动作(Action)5都可以为了优化而被重排序，但是必须保证它们重排序后的结果和程序代码本身的应有结果是一致的。<br>即</li>
<li>即如果后续逻辑计算需要依赖之前的某个值a，那么a这个值的计算步骤不能跳过。如上代码：第3步，c的值需要使用a，所以不能跳过1直接执行3</li>
</ul>
</li>
<li><p>happens-before 规则<br>语义：如果A先发生于B，那么A所做的所有改变都能被B看到<br>Happens-before是用来指定两个操作之间的执行顺序。提供跨线程的内存可见性。在Java内存模型中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必然存在happens-before关系。</p>
</li>
</ul>
<p>遵循的规则：<br>    * 程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。<br>    * 监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。<br>    * volatile变量规则：对一个volatile域的写，happens- before 于任意后续对这个volatile域的读。<br>    * 传递性：如果A happens- before B，且B happens- before C，那么A happens- before C。</p>
<ul>
<li><p>锁和volatile的内存语义：（JMM）</p>
<ul>
<li>锁的获取：首先清空当前线程value内存，从主存中获取最新值；锁的释放：将当前线程内存value刷新到主内存</li>
<li>volatile的读写与锁的获取和释放对应，原理类似</li>
</ul>
</li>
<li><p>final域的重排序规则<br>对于final域，编译器和处理器要遵守两个重排序规则</p>
</li>
</ul>
<p>1&gt; 在构造函数内对一个final域的写入，与随后把这个构造函数的引用赋值给一个引用变量，两个操作不能重排序<br>2&gt; 初次读一个包含final域对象的引用，和随后初次读这个final域，这两个操作不能重排序  </p>
<p><a href="https://tech.meituan.com/java-memory-reordering.html" target="_blank" rel="noopener">美团点评博客-Java内存访问重排序的研究</a><br><a href="http://www.infoq.com/cn/articles/java-memory-model-5" target="_blank" rel="noopener">深入理解Java内存模型（五）——锁</a><br><a href="https://blog.csdn.net/ditto_zhou/article/details/78738197" target="_blank" rel="noopener">java多线程学习(九)final的内存语义</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>重排序</tag>
        <tag>happens-before</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程实战14-LongAdder统计加法器-计数器jdk8</title>
    <url>/2018/04/17/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9814-LongAdder%E7%BB%9F%E8%AE%A1%E5%8A%A0%E6%B3%95%E5%99%A8-%E8%AE%A1%E6%95%B0%E5%99%A8jdk8/</url>
    <content><![CDATA[<p>传统的原子锁AtomicLong/AtomicInt虽然也可以处理大量并发情况下的计数器，但是由于使用了自旋等待，当存在大量竞争时，会存在大量自旋等待，而导致CPU浪费，而有效计算很少，降低了计算效率。</p>
<p>而LongAdder是根据ConcurrentHashMap这类为并发设计的类的基本原理——锁分段，通过维护一个计数数组cells来保存多个计数副本，每个线程只对自己的副本进行操作，最后汇总来得到最终结果。</p>
<blockquote>
<p>Adder的英文意思为加法器，从字面意思上就可以理解，LongAdder的作用是用来进行统计计算的。比如，我们需要一个计数器，加入计数值为N，当大量的线程访问时，N的值将会出现并发安全，但是，我们并不打算在每个单独的子线程中去查看这个N值，只是在所有的子线程完毕后，才会统计N的总数，即相当于一种并行计算，但是我们不在乎中间结果，只在乎，中间计算都进行了就可以。因此，我们对可以变量创建一个副本N’，每个线程都有这个副本，只对这个副本进行操作，最后，将所有的副本进行汇总就是最终的N值，即：<code>N=N1&#39;+N2&#39;+N3&#39;...+Nn&#39;</code>。</p>
</blockquote>
<blockquote>
<p>详细原理：内部源码使用了一个cells的数组来保存每个线程的副本，第一个线程会初始化数组cells。新来到一个线程，会指向第一个cell，并检测是否有其他线程使用CAS，如果没有，则所有线程公用一个cel副本；否则，如果自旋等待，则当前线程新建一个cell副本，加入到数组cells，对副本进行操作。当所有操作完成后，使用sum函数就可以统计所有的操作。</p>
</blockquote>
<p><strong>这里也用到了cas操作，主要是为了防止多线程公用一个cell，导致一个cell数据并发出错，另外注意LongAdder的并不是细粒度的，所以不能使用中间值</strong></p>
<ol>
<li>线程副本cell<br>LongAdder继承自Striped64类，主要逻辑方法在Striped64中。<br>其中cell即为每个线程的副本变量，使用的是一个静态内部类Cell，维护了一个value变量</li>
</ol>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">@sun<span class="selector-class">.misc</span><span class="selector-class">.Contended</span> static final class Cell &#123;</span><br><span class="line">        volatile long value;</span><br><span class="line">        Cell(long x) &#123; value = x; &#125;</span><br><span class="line">        final boolean cas(long cmp, long val) &#123;</span><br><span class="line">            return UNSAFE.compareAndSwapLong(this, valueOffset, cmp, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Unsafe mechanics</span></span><br><span class="line">        private static final sun.misc.Unsafe UNSAFE;</span><br><span class="line">        private static final long valueOffset;</span><br><span class="line">        static &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">                Class&lt;?&gt; ak = Cell.class;</span><br><span class="line">                valueOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                    (ak.getDeclaredField("value"));</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                throw new Error(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>问题：既然Cell这么简单，为什么不直接用long value？<br>我的理解：可能要设计到Java值引用问题，如果直接使用long value，在线程B进行数组扩容后，线程A修改的value值将无法反映到线程B；而使用Cell对象对value进行包装后，由于线程A只会修改Cell对象的value值，不会修改Cell对象，所以线程B的Cell中的value也会跟着改变，就不会出现值问题。更具体的了解，可能需要了解一下java的值传递（java没有引用传递）</p>
<p> 2.Striped64主体代码<br> 主方法为longAccumulate方法，主要处理数组的扩容和冲突检查</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">abstract class Striped64 extends Number &#123;  </span><br><span class="line">    @sun<span class="selector-class">.misc</span><span class="selector-class">.Contended</span> static final class Cell &#123; ... &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** Number of CPUS, to place bound on table size */</span>  </span><br><span class="line">    static final int NCPU = Runtime.getRuntime().availableProcessors();  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// cell数组，长度一样要是2^n，可以类比为jdk1.7的ConcurrentHashMap中的segments数组  </span></span><br><span class="line">    transient volatile Cell[] cells;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 累积器的基本值，在两种情况下会使用：  </span></span><br><span class="line">    <span class="comment">// 1、没有遇到并发的情况，直接使用base，速度更快；  </span></span><br><span class="line">    <span class="comment">// 2、多线程并发初始化table数组时，必须要保证table数组只被初始化一次，因此只有一个线程能够竞争成功，这种情况下竞争失败的线程会尝试在base上进行一次累积操作  </span></span><br><span class="line">    transient volatile long base;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 自旋标识，在对cells进行初始化，或者后续扩容时，需要通过CAS操作把此标识设置为1（busy，忙标识，相当于加锁），取消busy时可以直接使用cellsBusy = 0，相当于释放锁  </span></span><br><span class="line">    transient volatile int cellsBusy;  </span><br><span class="line">  </span><br><span class="line">    Striped64() &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 使用CAS更新base的值  </span></span><br><span class="line">    final boolean casBase(long cmp, long val) &#123;  </span><br><span class="line">        return UNSAFE.compareAndSwapLong(this, BASE, cmp, val);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 使用CAS将cells自旋标识更新为1  </span></span><br><span class="line">    <span class="comment">// 更新为0时可以不用CAS，直接使用cellsBusy就行  </span></span><br><span class="line">    final boolean casCellsBusy() &#123;  </span><br><span class="line">        return UNSAFE.compareAndSwapInt(this, CELLSBUSY, 0, 1);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 下面这两个方法是ThreadLocalRandom中的方法，不过因为包访问关系，这里又重新写一遍  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// probe翻译过来是探测/探测器/探针这些，不好理解，它是ThreadLocalRandom里面的一个属性，  </span></span><br><span class="line">    <span class="comment">// 不过并不影响对Striped64的理解，这里可以把它理解为线程本身的hash值  </span></span><br><span class="line">    static final int getProbe() &#123;  </span><br><span class="line">        return UNSAFE.getInt(Thread.currentThread(), PROBE);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 相当于rehash，重新算一遍线程的hash值  </span></span><br><span class="line">    static final int advanceProbe(int probe) &#123;  </span><br><span class="line">        probe ^= probe &lt;&lt; 13;   // xorshift  </span><br><span class="line">        probe ^= probe &gt;&gt;&gt; 17;  </span><br><span class="line">        probe ^= probe &lt;&lt; 5;  </span><br><span class="line">        UNSAFE.putInt(Thread.currentThread(), PROBE, probe);  </span><br><span class="line">        return probe;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 核心方法的实现，此方法建议在外部进行一次CAS操作（cell != null时尝试CAS更新base值，cells != null时，CAS更新hash值取模后对应的cell.value） </span></span><br><span class="line"><span class="comment">     * @param x the value 前面我说的二元运算中的第二个操作数，也就是外部提供的那个操作数 </span></span><br><span class="line"><span class="comment">     * @param fn the update function, or null for add (this convention avoids the need for an extra field or function in LongAdder). </span></span><br><span class="line"><span class="comment">     *     外部提供的二元算术操作，实例持有并且只能有一个，生命周期内保持不变，null代表LongAdder这种特殊但是最常用的情况，可以减少一次方法调用 </span></span><br><span class="line"><span class="comment">     * @param wasUncontended false if CAS failed before call 如果为false，表明调用者预先调用的一次CAS操作都失败了 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    final void longAccumulate(long x, LongBinaryOperator fn, boolean wasUncontended) &#123;  </span><br><span class="line">        int h;  </span><br><span class="line">        <span class="comment">// 这个if相当于给线程生成一个非0的hash值  </span></span><br><span class="line">        <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;  </span><br><span class="line">            ThreadLocalRandom.current(); // force initialization  </span><br><span class="line">            h = getProbe();  </span><br><span class="line">            wasUncontended = true;  </span><br><span class="line">        &#125;  </span><br><span class="line">        boolean collide = false; // True if last slot nonempty 如果hash取模映射得到的Cell单元不是null，则为true，此值也可以看作是扩容意向，感觉这个更好理解  </span><br><span class="line">        for (;;) &#123;  </span><br><span class="line">            Cell[] as; Cell a; int n; long v;  </span><br><span class="line">            <span class="keyword">if</span> ((as = cells) != null &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123; <span class="comment">// cells已经被初始化了  </span></span><br><span class="line">                <span class="keyword">if</span> ((<span class="selector-tag">a</span> = as[(n - <span class="number">1</span>) &amp; h]) == null) &#123; <span class="comment">// hash取模映射得到的Cell单元还为null（为null表示还没有被使用）  </span></span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;       <span class="comment">// Try to attach new Cell 如果没有线程正在执行扩容  </span></span><br><span class="line">                        Cell r = new Cell(x);   // Optimistically create 先创建新的累积单元  </span><br><span class="line">                        <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123; <span class="comment">// 尝试加锁  </span></span><br><span class="line">                            boolean created = false;  </span><br><span class="line">                            try &#123;               <span class="comment">// Recheck under lock 在有锁的情况下再检测一遍之前的判断  </span></span><br><span class="line">                                Cell[] rs; int m, j;  </span><br><span class="line">                                <span class="keyword">if</span> ((rs = cells) != null &amp;&amp; (m = rs.length) &gt; <span class="number">0</span> &amp;&amp; rs[j = (m - <span class="number">1</span>) &amp; h] == null) &#123; <span class="comment">// 考虑别的线程可能执行了扩容，这里重新赋值重新判断  </span></span><br><span class="line">                                    rs[j] = r; // 对没有使用的Cell单元进行累积操作（第一次赋值相当于是累积上一个操作数，求和时再和base执行一次运算就得到实际的结果）  </span><br><span class="line">                                    created = true;  </span><br><span class="line">                                &#125;  </span><br><span class="line">                            &#125; finally &#123;  </span><br><span class="line">                                cellsBusy = 0; 清空自旋标识，释放锁  </span><br><span class="line">                            &#125;  </span><br><span class="line">                            <span class="keyword">if</span> (created) <span class="comment">// 如果原本为null的Cell单元是由自己进行第一次累积操作，那么任务已经完成了，所以可以退出循环  </span></span><br><span class="line">                                break;  </span><br><span class="line">                            continue;           // Slot is now non-empty 不是自己进行第一次累积操作，重头再来  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    collide = false; // 执行这一句是因为cells被加锁了，不能往下继续执行第一次的赋值操作（第一次累积），所以还不能考虑扩容  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended) <span class="comment">// CAS already known to fail 前面一次CAS更新a.value（进行一次累积）的尝试已经失败了，说明已经发生了线程竞争  </span></span><br><span class="line">                    wasUncontended = true; // Continue after rehash 情况失败标识，后面去重新算一遍线程的hash值  </span><br><span class="line">                else if (a.cas(v = a.value, ((fn == null) ? v + x : fn.applyAsLong(v, x)))) // 尝试CAS更新a.value（进行一次累积） ------ 标记为分支A  </span><br><span class="line">                    break; // 成功了就完成了累积任务，退出循环  </span><br><span class="line">                else if (n &gt;= NCPU || cells != as) // cell数组已经是最大的了，或者中途发生了扩容操作。因为NCPU不一定是2^n，所以这里用 &gt;=  </span><br><span class="line">                    collide = false; // At max size or stale 长度n是递增的，执行到了这个分支，说明n &gt;= NCPU会永远为true，下面两个else if就永远不会被执行了，也就永远不会再进行扩容  </span><br><span class="line">                                     <span class="comment">// CPU能够并行的CAS操作的最大数量是它的核心数（CAS在x86中对应的指令是cmpxchg，多核需要通过锁缓存来保证整体原子性），当n &gt;= NCPU时，再出现几个线程映射到同一个Cell导致CAS竞争的情况，那就真不关扩容的事了，完全是hash值的锅了  </span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!collide) <span class="comment">// 映射到的Cell单元不是null，并且尝试对它进行累积时，CAS竞争失败了，这时候把扩容意向设置为true  </span></span><br><span class="line">                                   <span class="comment">// 下一次循环如果还是跟这一次一样，说明竞争很严重，那么就真正扩容  </span></span><br><span class="line">                    collide = true; // 把扩容意向设置为true，只有这里才会给collide赋值为true，也只有执行了这一句，才可能执行后面一个else if进行扩容  </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123; <span class="comment">// 最后再考虑扩容，能到这一步说明竞争很激烈，尝试加锁进行扩容 ------ 标记为分支B  </span></span><br><span class="line">                    try &#123;  </span><br><span class="line">                        <span class="keyword">if</span> (cells == as) &#123;      <span class="comment">// Expand table unless stale 检查下是否被别的线程扩容了（CAS更新锁标识，处理不了ABA问题，这里再检查一遍）  </span></span><br><span class="line">                            Cell[] rs = new Cell[n &lt;&lt; 1]; // 执行2倍扩容  </span><br><span class="line">                            for (int i = 0; i &lt; n; ++i)  </span><br><span class="line">                                rs[i] = as[i];  </span><br><span class="line">                            cells = rs;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125; finally &#123;  </span><br><span class="line">                        cellsBusy = 0; // 释放锁  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    collide = false; // 扩容意向为false  </span><br><span class="line">                    continue; // Retry with expanded table 扩容后重头再来  </span><br><span class="line">                &#125;  </span><br><span class="line">                h = advanceProbe(h); // 重新给线程生成一个hash值，降低hash冲突，减少映射到同一个Cell导致CAS竞争的情况  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123; <span class="comment">// cells没有被加锁，并且它没有被初始化，那么就尝试对它进行加锁，加锁成功进入这个else if  </span></span><br><span class="line">                boolean init = false;  </span><br><span class="line">                try &#123;                           <span class="comment">// Initialize table  </span></span><br><span class="line">                    <span class="keyword">if</span> (cells == as) &#123; <span class="comment">// CAS避免不了ABA问题，这里再检测一次，如果还是null，或者空数组，那么就执行初始化  </span></span><br><span class="line">                        Cell[] rs = new Cell[2]; // 初始化时只创建两个单元  </span><br><span class="line">                        rs[h &amp; 1] = new Cell(x); // 对其中一个单元进行累积操作，另一个不管，继续为null  </span><br><span class="line">                        cells = rs;  </span><br><span class="line">                        init = true;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125; finally &#123;  </span><br><span class="line">                    cellsBusy = 0; // 清空自旋标识，释放锁  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">if</span> (init) <span class="comment">// 如果某个原本为null的Cell单元是由自己进行第一次累积操作，那么任务已经完成了，所以可以退出循环  </span></span><br><span class="line">                    break;  </span><br><span class="line">            &#125;  </span><br><span class="line">            else if (casBase(v = base, ((fn == null) ? v + x : fn.applyAsLong(v, x)))) // cells正在进行初始化时，尝试直接在base上进行累加操作  </span><br><span class="line">                break;                          // Fall back on using base 直接在base上进行累积操作成功了，任务完成，可以退出循环了  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// double的不讲，更long的逻辑基本上是一样的  </span></span><br><span class="line">    final void doubleAccumulate(double x, DoubleBinaryOperator fn, boolean wasUncontended);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Unsafe mechanics Unsafe初始化  </span></span><br><span class="line">    private static final sun.misc.Unsafe UNSAFE;  </span><br><span class="line">    private static final long BASE;  </span><br><span class="line">    private static final long CELLSBUSY;  </span><br><span class="line">    private static final long PROBE;  </span><br><span class="line">    static &#123;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();  </span><br><span class="line">            Class&lt;?&gt; sk = Striped64.class;  </span><br><span class="line">            BASE = UNSAFE<span class="selector-class">.objectFieldOffset</span>  </span><br><span class="line">                (sk.getDeclaredField("base"));  </span><br><span class="line">            CELLSBUSY = UNSAFE<span class="selector-class">.objectFieldOffset</span>  </span><br><span class="line">                (sk.getDeclaredField("cellsBusy"));  </span><br><span class="line">            Class&lt;?&gt; tk = Thread.class;  </span><br><span class="line">            PROBE = UNSAFE<span class="selector-class">.objectFieldOffset</span>  </span><br><span class="line">                (tk.getDeclaredField("threadLocalRandomProbe"));  </span><br><span class="line">        &#125; catch (Exception e) &#123;  </span><br><span class="line">            throw new Error(e);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 3.LongAdder的add()方法<br> add(long x) 方法不仅仅实现加，参数为负就为减；调用longAccumulate来进行操作</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">public void add(long x) &#123;  </span><br><span class="line">    Cell[] as; long b, v; int m; Cell a;  </span><br><span class="line">    if ((as = cells) != null || !casBase(b = base, b + x)) &#123;  </span><br><span class="line">        boolean uncontended = true;  </span><br><span class="line">        if (as == null || (m = as.length - 1) &lt; 0 ||  </span><br><span class="line">            (a = as[getProbe() &amp; m]) == null ||  </span><br><span class="line">            !(uncontended = <span class="selector-tag">a</span>.cas(v = <span class="selector-tag">a</span><span class="selector-class">.value</span>, v + x)))  </span><br><span class="line">            longAccumulate(x, null, uncontended);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>jdk1.8的ConcurrentHashMap中，没有再使用Segment，使用了一个简单的仿造LongAdder实现的计数器，这样能够保证计数效率不低于使用Segment的效率。</strong></p>
<p><a href="https://blog.csdn.net/u011392897/article/details/60480108" target="_blank" rel="noopener">jdk1.8 LongAdder源码学习</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>LongAdder</tag>
        <tag>加法器</tag>
        <tag>JDK8</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程实战13-同步中的四种锁synchronized、ReentrantLock、ReentrantReadWriteLock、StampedLock</title>
    <url>/2018/04/17/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9813-%E5%90%8C%E6%AD%A5%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%94%81synchronized%E3%80%81ReentrantLock%E3%80%81ReentrantReadWriteLock%E3%80%81StampedLock/</url>
    <content><![CDATA[<ol>
<li>synchronized同步锁<ul>
<li>synchronized属于悲观锁，直接对区域或者对象加锁，性能稳定，可以使用大部分场景。</li>
</ul>
</li>
<li>ReentrantLock可重入锁（Lock接口）<ul>
<li>相对于synchronized更加灵活，可以控制加锁和放锁的位置</li>
<li>可以使用Condition来操作线程，进行线程之间的通信</li>
<li>核心类AbstractQueuedSynchronizer，通过构造一个基于阻塞的CLH队列容纳所有的阻塞线程，而对该队列的操作均通过Lock-Free（CAS）操作，但对已经获得锁的线程而言，ReentrantLock实现了偏向锁的功能。</li>
</ul>
</li>
<li>ReentrantReadWriteLock可重入读写锁（ReadWriteLock接口）<ul>
<li>相对于ReentrantLock，对于大量的读操作，读和读之间不会加锁，只有存在写时才会加锁，但是这个锁是悲观锁</li>
<li>ReentrantReadWriteLock实现了读写锁的功能</li>
<li>ReentrantReadWriteLock是ReadWriteLock接口的实现类。ReadWriteLock接口的核心方法是readLock()，writeLock()。实现了并发读、互斥写。但读锁会阻塞写锁，是悲观锁的策略。</li>
</ul>
</li>
<li>StampedLock戳锁<ul>
<li>ReentrantReadWriteLock虽然解决了大量读取的效率问题，但是，由于实现的是悲观锁，当读取很多时，读取和读取之间又没有锁，写操作将无法竞争到锁，就会导致写线程饥饿。所以就需要对读取进行乐观锁处理。</li>
<li>StampedLock加入了乐观读锁，不会排斥写入</li>
<li>当并发量大且读远大于写的情况下最快的的是StampedLock锁</li>
</ul>
</li>
</ol>
<hr>
<blockquote>
<p>StampedLock控制锁有三种模式（排它写，悲观读，乐观读），一个StampedLock状态是由版本和模式两个部分组成，锁获取方法返回一个数字作为票据stamp，它用相应的锁状态表示并控制访问。</p>
</blockquote>
<p>StampedLock主要使用的是乐观读取，通过一个stamp变量来检测是否有读写冲突，每次乐观读取时会加入stamp校验。当存在写入操作时，写操作会改变stamp的状态，就会导致乐观读取失败，乐观读锁就会升级为悲观读锁</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">package com.sound.daytd5;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.locks.StampedLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author: ZouTai</span></span><br><span class="line"><span class="comment"> * @date: 2018/4/17</span></span><br><span class="line"><span class="comment"> * @description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public class StampedLockDemo &#123;</span><br><span class="line">    private int balance;</span><br><span class="line">    private final StampedLock stampedLock = new StampedLock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、悲观写</span></span><br><span class="line"><span class="comment">     * writeLock()：典型的cas操作，如果STATE等于s,设置写锁位为1（s+WBIT）。</span></span><br><span class="line"><span class="comment">     * acquireWrite跟acquireRead逻辑类似，先自旋尝试、加入等待队列、直至最终Unsafe.park()挂起线程。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    public void write(int i) &#123;</span><br><span class="line">        long stamp = stampedLock.writeLock();</span><br><span class="line">        balance += i;</span><br><span class="line">        stampedLock.unlockWrite(stamp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2、悲观读</span></span><br><span class="line"><span class="comment">     * 乐观锁失败后锁升级为readLock()：尝试state+1,用于统计读线程的数量，</span></span><br><span class="line"><span class="comment">     * 如果失败，进入acquireRead()进行自旋，通过CAS获取锁。</span></span><br><span class="line"><span class="comment">     * 如果自旋失败，入CLH队列，然后再自旋，</span></span><br><span class="line"><span class="comment">     * 如果成功获得读锁，激活cowait队列中的读线程Unsafe.unpark(),</span></span><br><span class="line"><span class="comment">     * 最终依然失败，Unsafe().park()挂起当前线程。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public void read() &#123;</span><br><span class="line">        long stamp = stampedLock.readLock();</span><br><span class="line">        int value = balance;</span><br><span class="line">        stampedLock.unlockRead(stamp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**重点：！！！</span></span><br><span class="line"><span class="comment">     * 3、乐观读：当读取远远大于写入时，使用乐观锁</span></span><br><span class="line"><span class="comment">     * tryOptimisticRead()：如果当前没有写锁占用，返回state(后7位清0，即清0读线程数)，如果有写锁，返回0，即失败。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public void optimisticRead() &#123;</span><br><span class="line">        long stamp = stampedLock.tryOptimisticRead();</span><br><span class="line">        int value = balance;</span><br><span class="line">        <span class="comment">// 校验这个戳是否有效validate()：比较当前stamp和发生乐观锁得到的stamp比较，不一致则失败。</span></span><br><span class="line">        <span class="keyword">if</span>(!stampedLock.validate(stamp)) &#123;</span><br><span class="line">            long readStamp = stampedLock.readLock();</span><br><span class="line">            value = balance;</span><br><span class="line">            stamp = readStamp;</span><br><span class="line">        &#125;</span><br><span class="line">        stampedLock.unlockRead(stamp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**重点：！</span></span><br><span class="line"><span class="comment">     * 4、判断条件之后，再写</span></span><br><span class="line"><span class="comment">     * 存在读取和写入两个操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public void conditionReadWrite(int state)&#123;</span><br><span class="line">        <span class="comment">// 首先读取</span></span><br><span class="line">        long stamp = stampedLock.readLock();</span><br><span class="line">        while (balance &gt; <span class="number">100</span>)&#123;</span><br><span class="line">            long writeStamp = stampedLock.tryConvertToWriteLock(stamp);</span><br><span class="line">            <span class="comment">// 步骤：a</span></span><br><span class="line">            <span class="keyword">if</span>(writeStamp!=<span class="number">0</span>) &#123;</span><br><span class="line">                balance += state;</span><br><span class="line">                stamp = writeStamp;</span><br><span class="line">                break;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 转换失败</span></span><br><span class="line">                stampedLock.unlockRead(stamp);</span><br><span class="line">                <span class="comment">//显式直接进行写锁 然后再通过循环再试,回到 步骤：a</span></span><br><span class="line">                stamp = stampedLock.writeLock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><a href="http://colobu.com/2016/06/01/Java-8-StampedLocks-vs-ReadWriteLocks-and-Synchronized/" target="_blank" rel="noopener">同步中四种锁的性能比较</a><br><a href="http://www.cnblogs.com/dennyzhangdd/p/6925473.html" target="_blank" rel="noopener">同步中的四种锁synchronized、ReentrantLock、ReentrantReadWriteLock、StampedLock</a><br><a href="https://www.javaspecialists.eu/talks/jfokus13/PhaserAndStampedLock.pdf" target="_blank" rel="noopener">同步锁参考英文文档</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>线程通信</tag>
        <tag>synchronized</tag>
        <tag>ReentrantLock</tag>
        <tag>ReentrantReadWriteLock</tag>
        <tag>StampedLock</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程实战11-并发容器CopyOnWriteArrayList</title>
    <url>/2018/04/11/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9811-%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8CopyOnWriteArrayList/</url>
    <content><![CDATA[<p>一、同步容器和并发容器<br>在jdk早期，为了解决并发安全问题，引入了同步容器Vector和Hashtable。在JDK1.2中，引入了同步封装类，可以由Collections.synchronizedXxxx等方法创建，可以直接对ArrayList进行封装以达到同步。但是，同步容器有一个问题，过于严格，即完全串行执行，导致即便是在复合操作下，并没有线程安全问题，也会加锁。<br>常见复合操作如下：<br>    * 迭代：反复访问元素，直到遍历完全部元素；<br>    * 跳转：根据指定顺序寻找当前元素的下一个（下n个）元素；<br>    * 条件运算：例如若没有则添加等；</p>
<p>同步容器对所有容器状态的访问都串行化，严重降低了并发性；当多个线程竞争锁时，吞吐量严重下降；</p>
<p>java5.0之后提供了多种并发容器来改善同步容器的性能，如ConcurrentHashMap、CopyOnWriteArrayList、CopyOnWriteArraySet、ConcurrentSkipListMap等；这些容器通过进行优化以达到适应不同需求的目的，并没有完全串行化。</p>
<table>
<thead>
<tr>
<th>一般容器</th>
<th>同步容器</th>
<th>并发容器</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayList</td>
<td>Vector</td>
<td>CopyOnWriteArrayList</td>
</tr>
<tr>
<td>HashMap</td>
<td>HashTable</td>
<td>ConcurrentHashMap</td>
</tr>
</tbody></table>
<p>一般容器线程不安全；同步容器线程安全，但是过于严格；为了满足实际需求，合理适应需求，增加了并发容器，更好的适应并发条件，即同步容器为了安全，并发容器为了安全的同时，达到高并发的效率。</p>
<p>二、源码分析：CopyOnWriteArrayList<br>在前面了解读写锁时就已经知道，在实际情况中，往往读取更多，写入很少，而读取数据并不影响数据的安全，所以读数据完全可以并发进行，而只将写数据进行严格加锁。</p>
<ul>
<li>当修改时（添加和移除），就对数组进行复制，此时要加锁。</li>
<li>当读取时，不加锁，直接读取</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** The lock protecting all mutators */</span></span><br><span class="line"><span class="comment">// 1、用于加锁的可重入锁</span></span><br><span class="line">final transient ReentrantLock lock = new ReentrantLock();</span><br><span class="line"><span class="comment">/** The array, accessed only via getArray/setArray. */</span></span><br><span class="line"><span class="comment">// 2、存取数据的volatile数组</span></span><br><span class="line">private transient volatile Object[] array;</span><br></pre></td></tr></table></figure>

<p>3、添加元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 3、添加元素</span><br><span class="line"> public boolean add(E e) &#123;</span><br><span class="line">        final ReentrantLock lock &#x3D; this.lock;                       &#x2F;&#x2F; 获取独占锁</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            Object[] elements &#x3D; getArray();</span><br><span class="line">            int len &#x3D; elements.length;</span><br><span class="line">            Object[] newElements &#x3D; Arrays.copyOf(elements, len + 1);&#x2F;&#x2F; 重新生成一个新的数组实例，并将原始数组的元素拷贝到新数组中</span><br><span class="line">            newElements[len] &#x3D; e;                                   &#x2F;&#x2F; 添加新的元素到新数组的末尾</span><br><span class="line">            setArray(newElements);                                  &#x2F;&#x2F; 更新底层数组</span><br><span class="line">            return true;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>有两点必须清楚：<br>     * 第一，在”添加操作“开始前，获取独占锁(lock)，若此时有需要线程要获取锁，则必须等待；在操作完毕后，释放独占锁(lock)，此时其它线程才能获取锁。通过独占锁，来防止多线程同时修改数据！此时还是可以读取，只是读取的是原来的数组。这段时间内，难道不发生安全问题吗？<br>    * 第二，操作完毕时，会通过setArray()来更新volatile数组。对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入；这样，每次添加元素之后，其它线程都能看到新添加的元素。</p>
<p>4、删除数据<br>remove数据和add类似，也是复制副本</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">public E remove(int index) &#123;  </span><br><span class="line">    final ReentrantLock lock = this.lock;  </span><br><span class="line">    lock.lock();  </span><br><span class="line">    try &#123;  </span><br><span class="line">        Object[] elements = getArray();  </span><br><span class="line">        int len = elements.length;  </span><br><span class="line">        E oldValue = get(elements, index); // 获取volatile数组中指定索引处的元素值  </span><br><span class="line">        int numMoved = len - index - 1;  </span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>) <span class="comment">// 如果被删除的是最后一个元素，则直接通过Arrays.copyOf()进行处理，而不需要新建数组  </span></span><br><span class="line">            setArray(Arrays.copyOf(elements, len - 1));  </span><br><span class="line">        <span class="keyword">else</span> &#123;  </span><br><span class="line">            Object[] newElements = new Object[len - 1];  </span><br><span class="line">            System.arraycopy(elements, 0, newElements, 0, index);    // 拷贝删除元素前半部分数据到新数组中  </span><br><span class="line">            System.arraycopy(elements, index + 1, newElements, index, numMoved);// 拷贝删除元素后半部分数据到新数组中  </span><br><span class="line">            setArray(newElements); // 更新volatile数组  </span><br><span class="line">        &#125;  </span><br><span class="line">        return oldValue;  </span><br><span class="line">    &#125; finally &#123;  </span><br><span class="line">        lock.unlock();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>5、读取数据<br>将底层volatile数组指定索引处的元素返回即可。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">        return get(getArray(), index);</span><br><span class="line">    &#125;</span><br><span class="line">private E get(Object[] <span class="selector-tag">a</span>, int index) &#123;</span><br><span class="line">        return (E) a[index];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>6、遍历元素</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">    return new COWIterator&lt;E&gt;(getArray(), 0);</span><br><span class="line">&#125;</span><br><span class="line">public ListIterator&lt;E&gt; listIterator() &#123;</span><br><span class="line">    return new COWIterator&lt;E&gt;(getArray(), 0);</span><br><span class="line">&#125;</span><br><span class="line">public ListIterator&lt;E&gt; listIterator(final int index) &#123;</span><br><span class="line">    Object[] elements = getArray();</span><br><span class="line">    int len = elements.length;</span><br><span class="line">    if (index&lt;0 || index&gt;len)</span><br><span class="line">        throw new IndexOutOfBoundsException("Index: "+index);</span><br><span class="line"></span><br><span class="line">    return new COWIterator&lt;E&gt;(elements, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static class COWIterator&lt;E&gt; implements ListIterator&lt;E&gt; &#123;</span><br><span class="line">    private final Object[] snapshot; // 保存数组的快照，是一个不可变的对象</span><br><span class="line">    private int <span class="attribute">cursor</span>;</span><br><span class="line"></span><br><span class="line">    private COWIterator(Object[] elements, int initialCursor) &#123;</span><br><span class="line">        <span class="attribute">cursor</span> = initialCursor;</span><br><span class="line">        snapshot = elements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        return cursor &lt; snapshot.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean hasPrevious() &#123;</span><br><span class="line">        return <span class="attribute">cursor</span> &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">    public E next() &#123;</span><br><span class="line">        <span class="keyword">if</span> (! hasNext())</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        return (E) snapshot[<span class="attribute">cursor</span>++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">    public E previous() &#123;</span><br><span class="line">        <span class="keyword">if</span> (! hasPrevious())</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        return (E) snapshot[--<span class="attribute">cursor</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int nextIndex() &#123;</span><br><span class="line">        return <span class="attribute">cursor</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int previousIndex() &#123;</span><br><span class="line">        return <span class="attribute">cursor</span>-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    public void remove() &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    public void set(E e) &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    public void add(E e) &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上容器的迭代器中会保存一个不可变的Object数组对象，那么在进行遍历这个对象时就不需要再进一步的同步。在每次修改时，都会创建并重新发布一个新的窗口副本，从而实现了可变性。如上迭代器代码中保留了一个指向volatile数组的引用，由于不会被修改，因此多个线程可以同时对它进行迭代，而不会彼此干扰或与修改容器的线程相互干扰。<br>与之前的ArrayList实现相比，CopyOnWriteArrayList返回迭代器不会抛出ConcurrentModificationException异常，即它不是fail-fast机制的！</p>
<p>三、CopyOnWrite的应用场景<br>CopyOnWrite并发容器用于读多写少的并发场景。比如缓存；白名单，黑名单，商品类目的访问和更新场景，假如我们有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索内容，但是某些关键字不允许被搜索。这些不能被搜索的关键字会被放在一个黑名单当中，黑名单每天晚上更新一次。当用户搜索时，会检查当前关键字在不在黑名单当中，如果在，则提示不能搜索。</p>
<p>使用CopyOnWriteMap需要注意两件事情：</p>
<pre><code>* 1. 减少扩容开销。根据实际需要，初始化CopyOnWriteMap的大小，避免写时CopyOnWriteMap扩容的开销。

* 2. 使用批量添加。因为每次添加，容器每次都会进行复制，所以减少添加次数，可以减少容器的复制次数。如使用上面代码里的addBlackList方法。</code></pre><p>CopyOnWrite的缺点：CopyOnWrite容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要注意一下。<br>    * 内存占用问题。因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的Yong GC和Full GC。之前我们系统中使用了一个服务由于每晚使用CopyOnWrite机制更新大对象，造成了每晚15秒的Full GC，应用响应时间也随之变长。针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，如ConcurrentHashMap。<br>    * 数据一致性问题/最终一致。CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。即只能保证数据的最终一致性，而不能保证实时一致。最终一致对于分布式系统也非常重要，它通过容忍一定时间的数据不一致，提升整个分布式系统的可用性与分区容错性。当然，最终一致并不是任何场景都适用的，像火车站售票这种系统用户对于数据的实时性要求非常非常高，就必须做成强一致性的。</p>
<p>链接：<a href="https://www.nowcoder.com/questionTerminal/95e4f9fa513c4ef5bd6344cc3819d3f7" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/95e4f9fa513c4ef5bd6344cc3819d3f7</a><br>来源：牛客网</p>
<p><strong>补充：</strong><br>一：快速失败（fail—fast）</p>
<ul>
<li>在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception。</li>
<li>原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</li>
<li>注意：这里异常的抛出条件是检测到 modCount！=expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。</li>
<li>场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。</li>
</ul>
<p>二：安全失败（fail—safe）(克隆容器Copy)</p>
<ul>
<li>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</li>
<li>原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。</li>
<li>场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</li>
</ul>
<p><a href="https://blog.csdn.net/mazhimazh/article/details/19210547" target="_blank" rel="noopener">Java 7之多线程并发容器 - CopyOnWriteArrayList</a><br><a href="https://blog.csdn.net/caomiao2006/article/details/53232687" target="_blank" rel="noopener">CopyOnWriteArrayList详解</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CopyOnWriteArrayList</tag>
        <tag>读写锁</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程实战10-多线程中的任务分解机制ForkJoinPool详解</title>
    <url>/2018/04/10/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9810-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%88%86%E8%A7%A3%E6%9C%BA%E5%88%B6ForkJoinPool%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p>Fork/Join 模式类似于MapReduce，也相当于一种分而治之的理念，或者说就像二分查找、二路归并算法。通过将一个大量的计算分解为许多的小计算，分而治之，然后再合并，同时，这些分出来的每个小计算都是并行进行的，这样就大大增大了CPU的利用率。</p>
</blockquote>
<p>Fork/Join 模式有自己的适用范围。如果一个应用能被分解成多个子任务，并且组合多个子任务的结果就能够获得最终的答案，那么这个应用就适合用 Fork/Join 模式来解决。图 1 给出了一个 Fork/Join 模式的示意图，位于图上部的 Task 依赖于位于其下的 Task 的执行，只有当所有的子任务都完成之后，调用者才能获得 Task 0 的返回结果。可以说，Fork/Join 模式能够解决很多种类的并行问题。通过使用 Doug Lea 提供的 Fork/Join 框架，软件开发人员只需要关注任务的划分和中间结果的组合就能充分利用并行平台的优良性能。其他和并行相关的诸多难于处理的问题，例如负载平衡、同步等，都可以由框架采用统一的方式解决。这样，我们就能够轻松地获得并行的好处而避免了并行编程的困难且容易出错的缺点。<br><img src="http://osiy4s0ad.bkt.clouddn.com/soundblog/1523368521354.jpg" alt="图 1. Fork/Join 模式示意图"></p>
<p>在多线程并发编程中，有时候会遇到将大任务分解成小任务再并发执行的场景。Java 8新增的ForkJoinPool很好的支持了这个问题。ForkJoinPool是一种支持任务分解的线程池，当提交给他的任务“过大”，他就会按照预先定义的规则将大任务分解成小任务，多线程并发执行。 一般要配合可分解任务接口ForkJoinTask来使用，ForkJoinTask有两个实现它的抽象类：RecursiveAction和RecursiveTask，其区别是前者没有返回值，后者有返回值。</p>
<ul>
<li><p>应用场景：<br>简单来说：如果你的问题能很容易分解成子问题，则比较适合ForkJoinPool。适合CPU密集型的场景。</p>
</li>
<li><p>实例：计算1+2+…+100;并行计算</p>
</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">package com.sound.daytc1;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.ExecutionException;</span><br><span class="line">import java.util.concurrent.ForkJoinPool;</span><br><span class="line">import java.util.concurrent.Future;</span><br><span class="line">import java.util.concurrent.RecursiveTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author: ZouTai</span></span><br><span class="line"><span class="comment"> * @date: 2018/4/10</span></span><br><span class="line"><span class="comment"> * @description: ForkJoin模式计算序列相加-二分法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public class RecursiveTaskDemo extends RecursiveTask&lt;Integer&gt; &#123;</span><br><span class="line">    private int first;</span><br><span class="line">    private int last;</span><br><span class="line"></span><br><span class="line">    public RecursiveTaskDemo(int first, int last) &#123;</span><br><span class="line">        this.first = first;</span><br><span class="line">        this.last = last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Integer compute() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + " ... ");</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这里面要写自己的划分逻辑</span></span><br><span class="line"><span class="comment">         * 构造ForkJoin</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        int sum = 0;</span><br><span class="line">        <span class="comment">// 拆分任务</span></span><br><span class="line">        <span class="keyword">if</span> (last - first &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 计算</span></span><br><span class="line">            for (int i = first; i &lt;= last; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 类似于分支递归思想</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            RecursiveTaskDemo demo01 = new RecursiveTaskDemo(first, (last + first) / 2);</span><br><span class="line">            RecursiveTaskDemo demo02 = new RecursiveTaskDemo((last + first) / 2 + 1, last);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行</span></span><br><span class="line">            demo01.fork();</span><br><span class="line">            demo02.fork();</span><br><span class="line"></span><br><span class="line">            Integer a = demo01.join();</span><br><span class="line">            Integer b = demo02.join();</span><br><span class="line"></span><br><span class="line">            sum = a + b;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ForkJoinPool forkJoinPool = new ForkJoinPool(3);</span><br><span class="line">        Future&lt;Integer&gt; future = forkJoinPool.submit(new RecursiveTaskDemo(1, 100));</span><br><span class="line">        System.out.println("处理其他程序...");</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println("计算的值为：" + future.get());</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-forkjoin/" target="_blank" rel="noopener">IBM-JDK 7 中的 Fork/Join 模式</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>ForkJoin</tag>
        <tag>并行计算</tag>
        <tag>任务分配</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程实战9-Java中的并发工具类</title>
    <url>/2018/04/10/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%989-Java%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    <content><![CDATA[<blockquote>
<p>在JDK的并发包里提供了几个非常有用的并发工具类。CountDownLatch、CyclicBarrier和Semaphore工具类提供了一种并发流程控制的手段，Exchanger工具类则提供了在线程间交换数据的一种手段。</p>
</blockquote>
<p>一、等待多线程完成的CountDownLatch</p>
<p>CountDownLatch允许一个或多个线程等待其他线程完成操作。<br>比如我们现在需要一个计算c=a+b总和的任务，但是其中a有a+10,且b有b+100;总和的计算需要等待a和b全部计算完成才能开始，所以需要等待。显然，最简单的方法，可以直接使用join方法来实现。如下：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">package com.sound.daytb4;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、join实现等待</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public class JoinCountDownLatchTest &#123;</span><br><span class="line">    int a = 1;</span><br><span class="line">    int b = 2;</span><br><span class="line">    int c = 0;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        JoinCountDownLatchTest demo = new JoinCountDownLatchTest();</span><br><span class="line">        Thread cal1 = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                demo.a = demo.a + 10;</span><br><span class="line">                System.out.println("计算第一部分，结果为a = "+demo.a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread cal2 = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                demo.b = demo.b + 100;</span><br><span class="line">                System.out.println("计算第二部分，结果为b = "+demo.b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        cal1.start();</span><br><span class="line">        cal2.start();</span><br><span class="line">        cal1.join();</span><br><span class="line">        cal2.join();</span><br><span class="line">        System.out.println("等待前两部分计算完...");</span><br><span class="line">        System.out.println("将第一部分和第二部分相加为，c = "+ (demo.a+demo.b));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     计算第一部分，结果为a = 11</span></span><br><span class="line"><span class="comment">     计算第二部分，结果为b = 102</span></span><br><span class="line"><span class="comment">     等待前两部分计算完...</span></span><br><span class="line"><span class="comment">     将第一部分和第二部分相加为，c = 113</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>CountDownLatch与join的区别</strong><br>但是，相对于join，CountDownLatch功能更多，或者说是更加灵活，可以在内部随时完成。<br>考虑一种情况，对于上面的逻辑，假如，函数中还有其他计算，但是这些计算不算影响c的计算，所以就需要提前唤醒c，而不需要再等待了。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">package com.sound.daytb4;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2、countDownLatch实现等待</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public class CountDownLatchTest &#123;</span><br><span class="line">    static CountDownLatch countDownLatch = new CountDownLatch(2);</span><br><span class="line">    int a = 1;</span><br><span class="line">    int b = 2;</span><br><span class="line">    int c = 0;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        CountDownLatchTest demo = new CountDownLatchTest();</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                demo.a = demo.a + 10;</span><br><span class="line">                System.out.println("计算第一部分，结果为a = "+demo.a);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                demo.b = demo.b + 100;</span><br><span class="line">                System.out.println("计算第二部分，结果为b = "+demo.b);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println("继续计算其他任务");</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println("等待前两部分计算完...");</span><br><span class="line">        System.out.println("将第一部分和第二部分相加为，c = "+ (demo.a+demo.b));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     计算第一部分，结果为a = 11</span></span><br><span class="line"><span class="comment">     计算第二部分，结果为b = 102</span></span><br><span class="line"><span class="comment">     等待前两部分计算完...</span></span><br><span class="line"><span class="comment">     将第一部分和第二部分相加为，c = 113</span></span><br><span class="line"><span class="comment">     继续计算其他任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>CountDownLatch内部逻辑</strong><br>CountDownLatch的构造函数接收一个int类型的参数作为计数器，如果你想等待N个点完<br>成，这里就传入N。<br>当我们调用CountDownLatch的countDown方法时，N就会减1，CountDownLatch的await方法<br>会阻塞当前线程，直到N变成零。由于countDown方法可以用在任何地方，所以这里说的N个<br>点，可以是N个线程，也可以是1个线程里的N个执行步骤。用在多个线程时，只需要把这个<br>CountDownLatch的引用传递到线程里即可。</p>
<p>二、同步/循环屏障CyclicBarrier</p>
<p>CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。<br>这相当于我们平时开会，屏障就相当于会议设置的固定人数和会议内容，每个人相当于一个线程，只有人到齐了，会议才会开始。<br>例子如下：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">package com.sound.daytb5;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line">public class CyclicBarrierDemo &#123;</span><br><span class="line"></span><br><span class="line">	public void meeting(CyclicBarrier barrier) &#123;</span><br><span class="line">		System.out.println(Thread.currentThread().getName() + " 到达会议室，等待开会..");</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(Thread.currentThread().getName().equals(<span class="string">"Thread-7"</span>)) &#123;</span><br><span class="line">			System.out.println("Thread-7 出车祸了，到不了了，会议将无法开始");</span><br><span class="line">			try &#123;</span><br><span class="line">				Thread.sleep(10000);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			barrier.reset();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			barrier.await();</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		CyclicBarrierDemo demo = new CyclicBarrierDemo();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 定义会议人数:10 和 内容run()&#123;&#125;</span></span><br><span class="line">		CyclicBarrier barrier = new CyclicBarrier(<span class="number">10</span>, new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				System.out.println("好！我们开始开会...");</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		for (int i = 0; i &lt; 12; i++) &#123;</span><br><span class="line">			new Thread(new Runnable() &#123;</span><br><span class="line">				@Override</span><br><span class="line">				public void run() &#123;</span><br><span class="line">					demo.meeting(barrier);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;).start();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 监控等待线程数</span></span><br><span class="line">		new Thread(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				while(true) &#123;</span><br><span class="line">					try &#123;</span><br><span class="line">						Thread.sleep(1000);</span><br><span class="line">					&#125; catch (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					System.out.println("等待的线程数 " + barrier.getNumberWaiting());</span><br><span class="line">					System.out.println("屏障是否损坏or异常？ " + barrier.isBroken());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二.1、CyclicBarrier和CountDownLatch的区别<br>CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置。所以CyclicBarrier能处理更为复杂的业务场景。例如，如果计算发生错误，可以重置计数器，并让线程重新执行一次。</p>
<p>三、控制并发线程数的Semaphore<br>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。<br>把它比作是控制流量的红绿灯。比如××马路要限制流量，只允许同时有一百辆车在这条路上行使，其他的都必须在路口等待，所以前一百辆车会看到绿灯，可以开进这条马路，后面的车会看到红灯，不能驶入××马路，但是如果前一百辆中有5辆车已经离开了××马路，那么后面就允许有5辆车驶入马路，这个例子里说的车就是线程，驶入马路就表示线程在执行，离开马路就表示线程执行完成，看见红灯就表示线程被阻塞，不能执行。<br>    * 应用场景：Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，就可以使用Semaphore来做流量控制。如下：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">package com.sound.daytb5;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line">public class SemaphoreTest &#123;</span><br><span class="line">    private static final int THREAD_COUNT = 30;</span><br><span class="line">    private static ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);</span><br><span class="line">    private static Semaphore s = new Semaphore(10);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i = 0; i &lt; THREAD_COUNT; i++) &#123;</span><br><span class="line">            threadPool.execute(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        s.acquire();</span><br><span class="line">                        System.out.println("save data");</span><br><span class="line">                        s.release();</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>与线程池的区别</strong><br>在上面的代码中，我们其实可以直接创建一个大小为10的线程池，这样不就好了吗？其实这两个东西完全不一样。即Semaphore是为了解决资源共享冲突的并发数目，而线程池只是一个线程池，池子里的线程并不一定是资源冲突的。就相当于，线程池是一个家，家里有猫、有狗、有猪，但是猫和猪并不会因为吃的东西而打架，它两吃的食物不一样。但是，同一个猪圈的猪却不同了，猪圈就相当于Semaphore信号量，它们都是吃一个槽里的食物，当然会打起来，所以就需要并发控制，比如，由于资源有限，一个猪圈里面只有10个槽，所以，每个猪圈就限制只能住10头猪，等这些猪长大了杀了（线程死亡），其他猪才能再进来。</p>
<ul>
<li>四、线程间交换数据的Exchanger<br>Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。<ul>
<li>Exchanger的应用场景：<ul>
<li>Exchanger可以用于遗传算法，遗传算法里需要选出两个人作为交配对象，这时候会交换两人的数据，并使用交叉规则得出2个交配结果。</li>
<li>Exchanger也可以用于校对工作，比如我们需要将纸制银行流水通过人工的方式录入成电子银行流水，为了避免错误，采用AB岗两人进行录入，录入到Excel之后，系统需要加载这两个Excel，并对两个Excel数据进行校对，看看是否录入一致。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">package com.sound.daytb5;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.Exchanger;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">public class ExchangerTest &#123;</span><br><span class="line">    private static final Exchanger&lt;String&gt; exgr = new Exchanger&lt;String&gt;();</span><br><span class="line">    private static ExecutorService threadPool = Executors.newFixedThreadPool(2);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        threadPool.execute(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println("银行流水A开始执行...");</span><br><span class="line">                    String A = "银行流水A"; // A录入银行流水数据</span><br><span class="line">                    exgr.exchange(A);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadPool.execute(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println("银行流水B开始执行...");</span><br><span class="line">                    String B = "银行流水B";// B录入银行流水数据</span><br><span class="line">                    String A = exgr.exchange("B");</span><br><span class="line">                    System<span class="selector-class">.out</span>.println(<span class="string">"A和B数据是否一致："</span> + A.equals(B) + <span class="string">"，A录入的是："</span></span><br><span class="line">                            + A + "，B录入是：" + B);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CountDownLatch</tag>
        <tag>CyclicBarrier</tag>
        <tag>Semaphore</tag>
        <tag>Exchanger</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程实战8-ThreadLocal原理与使用-线程局部变量</title>
    <url>/2018/04/10/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%988-ThreadLocal%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%BF%E7%94%A8-%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<blockquote>
<p>首先，我的理解，ThreadLocal只是一个公用对象，但是并不是完全用来作为线程之间共享的。原因在于，它只是一种公用变量模板，每个线程只是拥有它的复制版（线程死亡后，复制版也随之死亡），而不是直接使用公用变量，这样就避免了共享安全问题。但是，为什么不让每个线程直接去创建自己的实例变量呢？主要是因为，线程进来时它自己可能并不清楚需要哪些变量，而且在线程执行完毕，还需要自己去销毁这些变量，下的太繁杂。</p>
</blockquote>
<p>举个例子：当我去吃火锅时（我就是一个线程），餐厅都会有一个菜单纸（ThreadLocal）。没有使用ThreadLocal之前，我们和其他客人公用一张菜单纸，这当然是不符合逻辑的，所以，餐厅需要给我复制一份，我就可以在上面选菜了（菜单-账单就相当于：ThreadLocal-value，即ThreadLocalMap（key-value））。当我就餐结束，结账后（线程结束），我的菜单也就作废了（此时垃圾回收）。即线程公用一张ThreadLocal，但是并不直接使用那个共用的ThreadLocal，而是自己复制一份ThreadLocal，使用完后，这个复制版也就没用了。</p>
<p>为了严谨，下文综合其他解释：</p>
<p>jdk1.8源码解释：ThreadLocal类用来提供线程内部的局部变量。这种变量在多线程环境下访问(通过get或set方法访问)时能保证各个线程里的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是private static类型的，用于关联线程和线程的上下文。<br>    * 之所以使用static是因为ThreadLocal是ThreadLocalMap的key的弱引用，当没有强引用指向ThreadLocal，gc时就会被回收，而此时key将为null。</p>
<ul>
<li>一、实例应用：</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">package com.sound.daytb3;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author: ZouTai</span></span><br><span class="line"><span class="comment"> * @date: 2018/4/10</span></span><br><span class="line"><span class="comment"> * @description: ThreadLOcal-线程局部变量</span></span><br><span class="line"><span class="comment"> * 即，每个线程将维护一个自己的变量，这个变量只对当前线程可以随意更改，其他线程不会影响当前线程变量的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public class ThreadLocalDemo &#123;</span><br><span class="line">    private static ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;Integer&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected Integer initialValue() &#123;</span><br><span class="line">            <span class="comment">// 初始化值为0</span></span><br><span class="line">            return new Integer(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public int getNext() &#123;</span><br><span class="line">        int count = threadLocal.get();</span><br><span class="line">        count++;</span><br><span class="line">        threadLocal.set(count);</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ThreadLocalDemo tld = new ThreadLocalDemo();</span><br><span class="line">        new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + "" + tld.getNext());</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(1000);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + "" + tld.getNext());</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(500);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>二、源码解析：几个重要的方法get、set、remove</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**1、</span></span><br><span class="line"><span class="comment">     * initialValue函数用来设置ThreadLocal的初始值</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    private static ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;Integer&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected Integer initialValue() &#123;</span><br><span class="line">            <span class="comment">// 初始化值为0</span></span><br><span class="line">            return new Integer(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**2、</span></span><br><span class="line"><span class="comment">     * 该函数用来获取与当前线程关联的ThreadLocal的值</span></span><br><span class="line"><span class="comment">     * 如果当前线程没有该ThreadLocal的值，则调用initialValue函数获取初始值返回。</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public T get() &#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocal.ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != null) &#123;</span><br><span class="line">            ThreadLocal.ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class="line">            <span class="keyword">if</span> (e != null) &#123;</span><br><span class="line">                @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">                T result = (T)e.value;</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return setInitialValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**3、</span></span><br><span class="line"><span class="comment">     * 设置当前线程的ThreadLocal的值为value。</span></span><br><span class="line"><span class="comment">     * @param value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public void set(T value) &#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocal.ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != null)</span><br><span class="line">            map.set(this, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**4、</span></span><br><span class="line"><span class="comment">     * remove函数用来将当前线程的ThreadLocal绑定的值删除</span></span><br><span class="line"><span class="comment">     * 在某些情况下需要手动调用该函数，防止内存泄露。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public void remove() &#123;</span><br><span class="line">        ThreadLocal.ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">        <span class="keyword">if</span> (m != null)</span><br><span class="line">            m.remove(this);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>三、ThreadLocal内部的实现原理-原理改进<ul>
<li>我们知道ThreadLocal内部使用的是map，map有三个点（map节点node和两个分支key-value），这里面，我们也是有三个属性（当前线程Thread、ThreadLocal变量和变量值value）。显然，变量值就对应value；但是node和key分别对应什么？</li>
<li>早期的版本中，1.3之前，jdk将当前线程Thread作为key，ThreadLocal作为node。之后，更改为Thread作为node，ThreadLocal作为key。之所以这样做有以下两个好处：<ul>
<li>1.减少map节点，能提高性能：由于实际很多时候，线程很多，但是ThreadLocal变量其实很少。这样设计之后每个Map的Entry数量变小了：之前是Thread的数量，现在是ThreadLocal的数量。</li>
<li>2.减少内存使用量：当Thread销毁之后对应的ThreadLocalMap也就随之销毁了。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>四、内存泄露问题<br>引起内存泄露的主要问题是由于ThreadLocalMap的key使用了对ThreadLocal的弱引用导致的。<ul>
<li>ThreadLocalMap是使用ThreadLocal的弱引用作为Key的</li>
<li>ThreadLocal中的引用对象如下图：<br><img src="http://osiy4s0ad.bkt.clouddn.com/soundblog/1523352180650.jpg" alt="引用图"></li>
<li>内存泄露问题：如图，ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么系统gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：<code>ThreadLocal Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</code>永远无法回收，造成内存泄露。</li>
</ul>
</li>
</ul>
<p><strong>为什么要使用弱引用？直接使用强引用不就可以了吗？</strong><br>其实强引用将导致另外一种内存泄漏问题。即ThreadLocal引用为null，导师线程却没有回收，将用于持有ThreadLocal的强引用，无法回收，这也会导致内存泄漏。比如使用线程池的时候，线程结束是不会销毁的，会再次使用的。就可能出现内存泄露。　　</p>
<p><strong>内存泄漏的防护措施</strong></p>
<blockquote>
<p>源码内部会检查ThreaLocalMap，会将key为null的entry都进行删除<br>转载：整理一下ThreadLocalMap的getEntry函数的流程：<br>    * 1、首先从ThreadLocal的直接索引位置(通过ThreadLocal.threadLocalHashCode &amp; (len-1)运算得到)获取Entry e，如果e不为null并且key相同则返回e；<br>    * 2、如果e为null或者key不一致则向下一个位置查询，如果下一个位置的key和当前需要查询的key相等，则返回对应的Entry，否则，如果key值为null，则擦除该位置的Entry，否则继续向下一个位置查询<br>    * 在这个过程中遇到的key为null的Entry都会被擦除，那么Entry内的value也就没有强引用链，自然会被回收。仔细研究代码可以发现，set操作也有类似的思想，将key为null的这些Entry都删除，防止内存泄露。 但是光这样还是不够的，上面的设计思路依赖一个前提条件：要调用ThreadLocalMap的genEntry函数或者set函数。这当然是不可能任何情况都成立的，所以很多情况下需要使用者手动调用ThreadLocal的remove函数，手动删除不再需要的ThreadLocal，防止内存泄露。所以JDK建议将ThreadLocal变量定义成private static的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露。</p>
</blockquote>
<p>参考链接：<a href="https://zhuanlan.zhihu.com/p/20213204" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/20213204</a><br><a href="http://www.sczyh30.com/posts/Java/java-concurrent-threadlocal/" target="_blank" rel="noopener">http://www.sczyh30.com/posts/Java/java-concurrent-threadlocal/</a><br><a href="https://www.cnblogs.com/onlywujun/p/3524675.html" target="_blank" rel="noopener">https://www.cnblogs.com/onlywujun/p/3524675.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>ThreadLocal</tag>
        <tag>弱引用</tag>
        <tag>ThreadLocalMap</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程实战7-线程之间的通信2-join阻塞线程</title>
    <url>/2018/04/10/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%987-%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A12-join%E5%8A%A0%E5%A1%9E%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>thread.Join把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。比如在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B。</p>
</blockquote>
<p>t.join();      //使调用线程 t 在此之前执行完毕。<br>t.join(1000);  //等待 t 线程，等待时间是1000毫秒</p>
<ul>
<li><p>一、为什么要用join()方法：<br>在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。</p>
<ul>
<li>join()的作用是：“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行。</li>
</ul>
</li>
<li><p>二、实例：</p>
</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author: ZouTai</span></span><br><span class="line"><span class="comment"> * @date: 2018/4/10</span></span><br><span class="line"><span class="comment"> * @description: join-加塞线程，即，向线程加入内部线程，且内部线程，执行完，主线程才能继续。</span></span><br><span class="line"><span class="comment"> * 相当于将加塞线程合并入主线程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public class JoinDemo01 &#123;</span><br><span class="line">    public void a(Thread joinThread)&#123;</span><br><span class="line">        System.out.println("线程a开始...");</span><br><span class="line">        joinThread.start();</span><br><span class="line">        try &#123;</span><br><span class="line">            joinThread.join();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println("线程a执行完毕");</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void b() &#123;</span><br><span class="line">        System.out.println("加塞线程开始执行...");</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println("加塞线程执行完毕");</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        JoinDemo01 joinDemo01 = new JoinDemo01();</span><br><span class="line">        Thread jThread = new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                joinDemo01.b();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        joinDemo01.a(jThread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** result is :</span></span><br><span class="line"><span class="comment">     线程a开始...</span></span><br><span class="line"><span class="comment">     加塞线程开始执行...</span></span><br><span class="line"><span class="comment">     加塞线程执行完毕</span></span><br><span class="line"><span class="comment">     线程a执行完毕</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>三、源码解析</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// join方法：注意isAlive和wait对象线程的区别，不同</span></span><br><span class="line"><span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">            while (isAlive()) &#123; <span class="comment">// 1、判断当前线程是否存货（即加塞线程）</span></span><br><span class="line">                wait(0); // 2、使wait监视器对象线程等待（即主线程）；为什么1、2对象不同，需要了解wait方法，如下</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">		</span><br><span class="line">* This method should only be called by a thread that is the owner</span><br><span class="line">* of this object's monitor. </span><br><span class="line">* 即wait方法是被当前线程的监视器调用，即当前运行的线程，即上面的主线程</span><br><span class="line">* 监视器：即当前运行方法join所在的线程，而不是调用join方法的线程对象joinThread；而isAlive方法才是指的isAlive对象</span><br><span class="line">public final native void wait(long timeout) throws InterruptedException;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>join</tag>
        <tag>阻塞线程</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程实战6-线程之间的通信-深入解析Condition源码</title>
    <url>/2018/04/10/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%986-%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1-%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Condition%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<ul>
<li><p>Object类的几个方法</p>
<ul>
<li>notify方法：只会随机唤醒一个wait线程，然后此wait线程将会继续执行 </li>
<li>notifyAll方法：会唤醒所有的wait线程，所有wait线程将会全部执行</li>
</ul>
</li>
<li><p>显示锁的condition对象</p>
<ul>
<li>对于Object类的wait和notify方法有一定的缺陷，即无法精确唤醒指定的线程。所以引入了lock的condition对象，可以对不同的条件进行判断，来选择唤醒不同的线程<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author: ZouTai</span></span><br><span class="line"><span class="comment"> * @date: 2018/4/9</span></span><br><span class="line"><span class="comment"> * @description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public class ConditionBoundedBuffer &#123;</span><br><span class="line">    private Lock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里使用生产者-消费者模式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    private Condition product = lock.newCondition();</span><br><span class="line">    private Condition consume = lock.newCondition();</span><br><span class="line">    private final int max = 10;</span><br><span class="line">    int count = 0;</span><br><span class="line"></span><br><span class="line">    public void put() throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count &gt;= max) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+"生产过量，停止生产...");</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 1、生产过量，停止生产：生产者等待</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                product.await();</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 2、唤醒消费者</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            consume.signal();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+"生产-库存变为："+count);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public void take() throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+"库存为空，无法购买...");</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 3、库存为空，无法购买：消费者等待</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                consume.await();</span><br><span class="line">            &#125;</span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+"消费-库存还剩："+count);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 4、唤醒生产者</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            product.signal();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>condition源码解析：<a href="https://blog.csdn.net/u010412719/article/details/52089561" target="_blank" rel="noopener">参考博客</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>线程通信</tag>
        <tag>Condition</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程实战5-Java中的读写锁ReentrantReadWriteLock(转载)</title>
    <url>/2018/04/10/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%985-Java%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock/</url>
    <content><![CDATA[<ul>
<li>并发安全问题主要是出现在写的情况下，而读取数据并不影响数据的结果；另外，大高并发的情况下，大多数都是数据的读取，写操作是很少的，所以可以将数据的读写进行分离，将大大提高运行效率。</li>
<li>读写锁又叫做共享锁和排它锁，即读取是线程共享的：可以多个线程一起读取，但是不能被写；写入是排他性的，只能有一个线程进行操作：既不能被读取，也不能被其他线程写入。三种：读读不互斥，读写互斥，写写互斥。</li>
</ul>
<div class="post_content">
      <p><a title="原文链接" href="http://tutorials.jenkov.com/java-concurrency/read-write-locks.html" target="_blank">原文链接</a> <b>作者：</b>Jakob Jenkov <b>译者：</b>微凉 <b>校对：</b>丁一</p>
<p>
相比<a href="http://ifeve.com/locks/" target="_blank">Java中的锁(Locks in Java)</a>里Lock实现，读写锁更复杂一些。假设你的程序中涉及到对一些共享资源的读和写操作，且写操作没有读操作那么频繁。在没有写操作的时候，两个线程同时读一个资源没有任何问题，所以应该允许多个线程能在同时读取共享资源。但是如果有一个线程想去写这些共享资源，就不应该再有其它线程对该资源进行读或写（<i>译者注：也就是说：读-读能共存，读-写不能共存，写-写不能共存</i>）。这就需要一个读/写锁来解决这个问题。
</p>
<p>
Java5在java.util.concurrent包中已经包含了读写锁。尽管如此，我们还是应该了解其实现背后的原理。
</p>
<p>
以下是本文的主题
</p>
<ol>
<li><a href="#simple">读/写锁的Java实现(Read / Write Lock Java Implementation)</a><a></a></li>
<li><a href="#reentrance">读/写锁的重入(Read / Write Lock Reentrance)</a><a></a></li>
<li><a href="#readreentrance">读锁重入(Read Reentrance)</a><a></a></li>
<li><a href="#writereentrance">写锁重入(Write Reentrance)</a><a></a></li>
<li><a href="#upgrade">读锁升级到写锁(Read to Write Reentrance)</a><a></a></li>
<li><a href="#downgrade">写锁降级到读锁(Write to Read Reentrance)</a><a></a></li>
<li><a href="#full">可重入的ReadWriteLock的完整实现(Fully Reentrant ReadWriteLock)</a><a></a></li>
<li><a href="#finally">在finally中调用unlock() (Calling unlock() from a finally-clause)</a><a></a></li>
</ol>
<p><span id="more-3913"></span></p>
<h4 id="simple">读/写锁的Java实现</h4>
<p>
先让我们对读写访问资源的条件做个概述：
</p>
<p>
<b>读取</b> 没有线程正在做写操作，且没有线程在请求写操作。
</p>
<p>
<b>写入</b> 没有线程正在做读写操作。
</p>
<p>
如果某个线程想要读取资源，只要没有线程正在对该资源进行写操作且没有线程请求对该资源的写操作即可。我们假设对写操作的请求比对读操作的请求更重要，就要提升写请求的优先级。此外，如果读操作发生的比较频繁，我们又没有提升写操作的优先级，那么就会产生“饥饿”现象。请求写操作的线程会一直阻塞，直到所有的读线程都从ReadWriteLock上解锁了。如果一直保证新线程的读操作权限，那么等待写操作的线程就会一直阻塞下去，结果就是发生“饥饿”。因此，只有当没有线程正在锁住ReadWriteLock进行写操作，且没有线程请求该锁准备执行写操作时，才能保证读操作继续。
</p>
<p>
当其它线程没有对共享资源进行读操作或者写操作时，某个线程就有可能获得该共享资源的写锁，进而对共享资源进行写操作。有多少线程请求了写锁以及以何种顺序请求写锁并不重要，除非你想保证写锁请求的公平性。
</p>
<p>
按照上面的叙述，简单的实现出一个读/写锁，代码如下
</p>
<div id="highlighter_527527" class="syntaxhighlighter  "><div class="bar "><div class="toolbar"><a href="#viewSource" title="view source" class="item viewSource" style="width: 16px; height: 16px;">view source</a><div class="item copyToClipboard"><embed width="16" height="16" id="highlighter_527527_clipboard" type="application/x-shockwave-flash" title="copy to clipboard" allowscriptaccess="always" wmode="transparent" flashvars="highlighterId=highlighter_527527" menu="false" src="http://ifeve.com/wp-content/plugins/syntaxhighlighter/syntaxhighlighter2/scripts/clipboard.swf"></div><a href="#printSource" title="print" class="item printSource" style="width: 16px; height: 16px;">print</a><a href="#about" title="?" class="item about" style="width: 16px; height: 16px;">?</a></div></div><div class="lines"><div class="line alt1"><table><tbody><tr><td class="number"><code>01</code></td><td class="content"><code class="keyword">public</code> <code class="keyword">class</code> <code class="plain">ReadWriteLock{</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>02</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">int</code> <code class="plain">readers = </code><code class="value">0</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>03</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">int</code> <code class="plain">writers = </code><code class="value">0</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>04</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">int</code> <code class="plain">writeRequests = </code><code class="value">0</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>05</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>06</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">public</code> <code class="keyword">synchronized</code> <code class="keyword">void</code> <code class="plain">lockRead() </code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>07</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">throws</code> <code class="plain">InterruptedException{</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>08</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">while</code><code class="plain">(writers &gt; </code><code class="value">0</code> <code class="plain">|| writeRequests &gt; </code><code class="value">0</code><code class="plain">){</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>09</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">wait();</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>10</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>11</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">readers++;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>12</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>13</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>14</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">public</code> <code class="keyword">synchronized</code> <code class="keyword">void</code> <code class="plain">unlockRead(){</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>15</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">readers--;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>16</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">notifyAll();</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>17</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>18</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>19</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">public</code> <code class="keyword">synchronized</code> <code class="keyword">void</code> <code class="plain">lockWrite() </code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>20</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">throws</code> <code class="plain">InterruptedException{</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>21</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">writeRequests++;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>22</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>23</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">while</code><code class="plain">(readers &gt; </code><code class="value">0</code> <code class="plain">|| writers &gt; </code><code class="value">0</code><code class="plain">){</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>24</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">wait();</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>25</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>26</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">writeRequests--;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>27</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">writers++;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>28</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>29</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>30</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">public</code> <code class="keyword">synchronized</code> <code class="keyword">void</code> <code class="plain">unlockWrite() </code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>31</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">throws</code> <code class="plain">InterruptedException{</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>32</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">writers--;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>33</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">notifyAll();</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>34</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>35</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div></div></div>
<p>
ReadWriteLock类中，读锁和写锁各有一个获取锁和释放锁的方法。
</p>
<p>
读锁的实现在lockRead()中,只要没有线程拥有写锁（writers==0），且没有线程在请求写锁（writeRequests ==0），所有想获得读锁的线程都能成功获取。
</p>
<p>
写锁的实现在lockWrite()中,当一个线程想获得写锁的时候，首先会把写锁请求数加1（writeRequests++），然后再去判断是否能够真能获得写锁，当没有线程持有读锁（readers==0 ）,且没有线程持有写锁（writers==0）时就能获得写锁。有多少线程在请求写锁并无关系。
</p><div class="google-auto-placed ap_container" style="text-align: center; width: 100%; height: auto; clear: none;"><ins data-ad-format="auto" class="adsbygoogle" data-ad-client="ca-pub-9394337417063147" data-adsbygoogle-status="done" style="display: block; margin: auto; background-color: transparent;"><ins id="aswift_4_expand" style="display:inline-table;border:none;height:197px;margin:0;padding:0;position:relative;visibility:visible;width:785px;background-color:transparent;"><ins id="aswift_4_anchor" style="display:block;border:none;height:197px;margin:0;padding:0;position:relative;visibility:visible;width:785px;background-color:transparent;"><iframe width="785" height="197" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_4" name="aswift_4" style="left:0;position:absolute;top:0;width:785px;height:197px;"></iframe></ins></ins></ins></div>
<p>
需要注意的是，在两个释放锁的方法（unlockRead，unlockWrite）中，都调用了notifyAll方法，而不是notify。要解释这个原因，我们可以想象下面一种情形：
</p>
<p>
如果有线程在等待获取读锁，同时又有线程在等待获取写锁。如果这时其中一个等待读锁的线程被notify方法唤醒，但因为此时仍有请求写锁的线程存在（writeRequests&gt;0），所以被唤醒的线程会再次进入阻塞状态。然而，等待写锁的线程一个也没被唤醒，就像什么也没发生过一样（<i>译者注：信号丢失现象</i>）。如果用的是notifyAll方法，所有的线程都会被唤醒，然后判断能否获得其请求的锁。
</p>
<p>
用notifyAll还有一个好处。如果有多个读线程在等待读锁且没有线程在等待写锁时，调用unlockWrite()后，所有等待读锁的线程都能立马成功获取读锁 —— 而不是一次只允许一个。
</p>
<h4 id="reentrance">读/写锁的重入</h4>
<p>
上面实现的读/写锁(ReadWriteLock) 是不可重入的，当一个已经持有写锁的线程再次请求写锁时，就会被阻塞。原因是已经有一个写线程了——就是它自己。此外，考虑下面的例子：
</p>
<ol>
<li>Thread 1 获得了读锁</li>
<li>Thread 2 请求写锁，但因为Thread 1 持有了读锁，所以写锁请求被阻塞。</li>
<li>Thread 1 再想请求一次读锁，但因为Thread 2处于请求写锁的状态，所以想再次获取读锁也会被阻塞。</li>
</ol>
<p>
上面这种情形使用前面的ReadWriteLock就会被锁定——一种类似于死锁的情形。不会再有线程能够成功获取读锁或写锁了。
</p>
<p>
为了让ReadWriteLock可重入，需要对它做一些改进。下面会分别处理读锁的重入和写锁的重入。
</p>
<h4 id="readreentrance">读锁重入</h4>
<p>
为了让ReadWriteLock的读锁可重入，我们要先为读锁重入建立规则：
</p>
<ul>
<li>
要保证某个线程中的读锁可重入，要么满足获取读锁的条件（没有写或写请求），要么已经持有读锁（不管是否有写请求）。
</li>
</ul>
<p>
要确定一个线程是否已经持有读锁，可以用一个map来存储已经持有读锁的线程以及对应线程获取读锁的次数，当需要判断某个线程能否获得读锁时，就利用map中存储的数据进行判断。下面是方法lockRead和unlockRead修改后的的代码：
</p>
<div id="highlighter_115426" class="syntaxhighlighter  "><div class="bar    "><div class="toolbar"><a href="#viewSource" title="view source" class="item viewSource" style="width: 16px; height: 16px;">view source</a><div class="item copyToClipboard"><embed width="16" height="16" id="highlighter_115426_clipboard" type="application/x-shockwave-flash" title="copy to clipboard" allowscriptaccess="always" wmode="transparent" flashvars="highlighterId=highlighter_115426" menu="false" src="http://ifeve.com/wp-content/plugins/syntaxhighlighter/syntaxhighlighter2/scripts/clipboard.swf"></div><a href="#printSource" title="print" class="item printSource" style="width: 16px; height: 16px;">print</a><a href="#about" title="?" class="item about" style="width: 16px; height: 16px;">?</a></div></div><div class="lines"><div class="line alt1"><table><tbody><tr><td class="number"><code>01</code></td><td class="content"><code class="keyword">public</code> <code class="keyword">class</code> <code class="plain">ReadWriteLock{</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>02</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="plain">Map&lt;Thread, Integer&gt; readingThreads =</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>03</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">new</code> <code class="plain">HashMap&lt;Thread, Integer&gt;();</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>04</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>05</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">int</code> <code class="plain">writers = </code><code class="value">0</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>06</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">int</code> <code class="plain">writeRequests = </code><code class="value">0</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>07</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>08</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">public</code> <code class="keyword">synchronized</code> <code class="keyword">void</code> <code class="plain">lockRead() </code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>09</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">throws</code> <code class="plain">InterruptedException{</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>10</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">Thread callingThread = Thread.currentThread();</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>11</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">while</code><code class="plain">(! canGrantReadAccess(callingThread)){</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>12</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">wait();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>13</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>14</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>15</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">readingThreads.put(callingThread,</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>16</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">(getAccessCount(callingThread) + </code><code class="value">1</code><code class="plain">));</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>17</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>18</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>19</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">public</code> <code class="keyword">synchronized</code> <code class="keyword">void</code> <code class="plain">unlockRead(){</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>20</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">Thread callingThread = Thread.currentThread();</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>21</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">int</code> <code class="plain">accessCount = getAccessCount(callingThread);</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>22</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(accessCount == </code><code class="value">1</code><code class="plain">) { </code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>23</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">readingThreads.remove(callingThread); </code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>24</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code><code class="keyword">else</code> <code class="plain">{</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>25</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">readingThreads.put(callingThread, (accessCount -</code><code class="value">1</code><code class="plain">)); </code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>26</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>27</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">notifyAll();</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>28</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>29</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>30</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">boolean</code> <code class="plain">canGrantReadAccess(Thread callingThread){</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>31</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(writers &gt; </code><code class="value">0</code><code class="plain">) </code><code class="keyword">return</code> <code class="keyword">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>32</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(isReader(callingThread) </code><code class="keyword">return</code> <code class="keyword">true</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>33</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(writeRequests &gt; </code><code class="value">0</code><code class="plain">) </code><code class="keyword">return</code> <code class="keyword">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>34</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="keyword">true</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>35</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>36</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>37</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">int</code> <code class="plain">getReadAccessCount(Thread callingThread){</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>38</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">Integer accessCount = readingThreads.get(callingThread);</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>39</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(accessCount == </code><code class="keyword">null</code><code class="plain">) </code><code class="keyword">return</code> <code class="value">0</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>40</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="plain">accessCount.intValue();</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>41</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>42</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>43</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">boolean</code> <code class="plain">isReader(Thread callingThread){</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>44</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="plain">readingThreads.get(callingThread) != </code><code class="keyword">null</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>45</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>46</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div></div></div>
<p>
代码中我们可以看到，只有在没有线程拥有写锁的情况下才允许读锁的重入。此外，重入的读锁比写锁优先级高。
</p>
<h4 id="writereentrance">写锁重入</h4>
<p>
仅当一个线程已经持有写锁，才允许写锁重入（再次获得写锁）。下面是方法lockWrite和unlockWrite修改后的的代码。
</p>
<div id="highlighter_6979" class="syntaxhighlighter  "><div class="bar  "><div class="toolbar"><a href="#viewSource" title="view source" class="item viewSource" style="width: 16px; height: 16px;">view source</a><div class="item copyToClipboard"><embed width="16" height="16" id="highlighter_6979_clipboard" type="application/x-shockwave-flash" title="copy to clipboard" allowscriptaccess="always" wmode="transparent" flashvars="highlighterId=highlighter_6979" menu="false" src="http://ifeve.com/wp-content/plugins/syntaxhighlighter/syntaxhighlighter2/scripts/clipboard.swf"></div><a href="#printSource" title="print" class="item printSource" style="width: 16px; height: 16px;">print</a><a href="#about" title="?" class="item about" style="width: 16px; height: 16px;">?</a></div></div><div class="lines"><div class="line alt1"><table><tbody><tr><td class="number"><code>01</code></td><td class="content"><code class="keyword">public</code> <code class="keyword">class</code> <code class="plain">ReadWriteLock{</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>02</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="plain">Map&lt;Thread, Integer&gt; readingThreads =</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>03</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">new</code> <code class="plain">HashMap&lt;Thread, Integer&gt;();</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>04</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>05</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">int</code> <code class="plain">writeAccesses&nbsp;&nbsp;&nbsp; = </code><code class="value">0</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>06</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">int</code> <code class="plain">writeRequests&nbsp;&nbsp;&nbsp; = </code><code class="value">0</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>07</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="plain">Thread writingThread = </code><code class="keyword">null</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>08</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>09</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">public</code> <code class="keyword">synchronized</code> <code class="keyword">void</code> <code class="plain">lockWrite() </code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>10</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">throws</code> <code class="plain">InterruptedException{</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>11</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">writeRequests++;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>12</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">Thread callingThread = Thread.currentThread();</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>13</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">while</code><code class="plain">(!canGrantWriteAccess(callingThread)){</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>14</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">wait();</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>15</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>16</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">writeRequests--;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>17</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">writeAccesses++;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>18</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">writingThread = callingThread;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>19</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>20</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>21</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">public</code> <code class="keyword">synchronized</code> <code class="keyword">void</code> <code class="plain">unlockWrite() </code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>22</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">throws</code> <code class="plain">InterruptedException{</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>23</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">writeAccesses--;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>24</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(writeAccesses == </code><code class="value">0</code><code class="plain">){</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>25</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">writingThread = </code><code class="keyword">null</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>26</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>27</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">notifyAll();</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>28</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>29</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>30</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">boolean</code> <code class="plain">canGrantWriteAccess(Thread callingThread){</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>31</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(hasReaders()) </code><code class="keyword">return</code> <code class="keyword">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>32</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(writingThread == </code><code class="keyword">null</code><code class="plain">)&nbsp;&nbsp;&nbsp; </code><code class="keyword">return</code> <code class="keyword">true</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>33</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(!isWriter(callingThread)) </code><code class="keyword">return</code> <code class="keyword">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>34</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="keyword">true</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>35</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>36</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>37</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">boolean</code> <code class="plain">hasReaders(){</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>38</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="plain">readingThreads.size() &gt; </code><code class="value">0</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>39</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>40</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>41</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">boolean</code> <code class="plain">isWriter(Thread callingThread){</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>42</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="plain">writingThread == callingThread;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>43</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>44</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div></div></div>
<p>
注意在确定当前线程是否能够获取写锁的时候，是如何处理的。
</p>
<h4 id="upgrade">读锁升级到写锁</h4>
<p>
有时，我们希望一个拥有读锁的线程，也能获得写锁。想要允许这样的操作，要求这个线程是唯一一个拥有读锁的线程。writeLock()需要做点改动来达到这个目的：
</p>
<div id="highlighter_794973" class="syntaxhighlighter  "><div class="bar                       "><div class="toolbar"><a href="#viewSource" title="view source" class="item viewSource" style="width: 16px; height: 16px;">view source</a><div class="item copyToClipboard"><embed width="16" height="16" id="highlighter_794973_clipboard" type="application/x-shockwave-flash" title="copy to clipboard" allowscriptaccess="always" wmode="transparent" flashvars="highlighterId=highlighter_794973" menu="false" src="http://ifeve.com/wp-content/plugins/syntaxhighlighter/syntaxhighlighter2/scripts/clipboard.swf"></div><a href="#printSource" title="print" class="item printSource" style="width: 16px; height: 16px;">print</a><a href="#about" title="?" class="item about" style="width: 16px; height: 16px;">?</a></div></div><div class="lines"><div class="line alt1"><table><tbody><tr><td class="number"><code>01</code></td><td class="content"><code class="keyword">public</code> <code class="keyword">class</code> <code class="plain">ReadWriteLock{</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>02</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="plain">Map&lt;Thread, Integer&gt; readingThreads =</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>03</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">new</code> <code class="plain">HashMap&lt;Thread, Integer&gt;();</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>04</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>05</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">int</code> <code class="plain">writeAccesses&nbsp;&nbsp;&nbsp; = </code><code class="value">0</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>06</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">int</code> <code class="plain">writeRequests&nbsp;&nbsp;&nbsp; = </code><code class="value">0</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>07</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="plain">Thread writingThread = </code><code class="keyword">null</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>08</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>09</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">public</code> <code class="keyword">synchronized</code> <code class="keyword">void</code> <code class="plain">lockWrite() </code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>10</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">throws</code> <code class="plain">InterruptedException{</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>11</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">writeRequests++;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>12</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">Thread callingThread = Thread.currentThread();</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>13</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">while</code><code class="plain">(!canGrantWriteAccess(callingThread)){</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>14</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">wait();</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>15</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>16</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">writeRequests--;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>17</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">writeAccesses++;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>18</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">writingThread = callingThread;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>19</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>20</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>21</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">public</code> <code class="keyword">synchronized</code> <code class="keyword">void</code> <code class="plain">unlockWrite() </code><code class="keyword">throws</code> <code class="plain">InterruptedException{</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>22</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">writeAccesses--;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>23</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(writeAccesses == </code><code class="value">0</code><code class="plain">){</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>24</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">writingThread = </code><code class="keyword">null</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>25</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>26</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">notifyAll();</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>27</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>28</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>29</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">boolean</code> <code class="plain">canGrantWriteAccess(Thread callingThread){</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>30</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(isOnlyReader(callingThread)) </code><code class="keyword">return</code> <code class="keyword">true</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>31</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(hasReaders()) </code><code class="keyword">return</code> <code class="keyword">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>32</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(writingThread == </code><code class="keyword">null</code><code class="plain">) </code><code class="keyword">return</code> <code class="keyword">true</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>33</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(!isWriter(callingThread)) </code><code class="keyword">return</code> <code class="keyword">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>34</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="keyword">true</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>35</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>36</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>37</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">boolean</code> <code class="plain">hasReaders(){</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>38</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="plain">readingThreads.size() &gt; </code><code class="value">0</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>39</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>40</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>41</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">boolean</code> <code class="plain">isWriter(Thread callingThread){</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>42</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="plain">writingThread == callingThread;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>43</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>44</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>45</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">boolean</code> <code class="plain">isOnlyReader(Thread thread){</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>46</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="plain">readers == </code><code class="value">1</code> <code class="plain">&amp;&amp; readingThreads.get(callingThread) != </code><code class="keyword">null</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>47</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>48</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div></div></div>
<p>
现在ReadWriteLock类就可以从读锁升级到写锁了。
</p>
<h4 id="downgrade">写锁降级到读锁</h4>
<p>
有时拥有写锁的线程也希望得到读锁。如果一个线程拥有了写锁，那么自然其它线程是不可能拥有读锁或写锁了。所以对于一个拥有写锁的线程，再获得读锁，是不会有什么危险的。我们仅仅需要对上面canGrantReadAccess方法进行简单地修改：
</p>
<div id="highlighter_551372" class="syntaxhighlighter  "><div class="bar         "><div class="toolbar"><a href="#viewSource" title="view source" class="item viewSource" style="width: 16px; height: 16px;">view source</a><div class="item copyToClipboard"><embed width="16" height="16" id="highlighter_551372_clipboard" type="application/x-shockwave-flash" title="copy to clipboard" allowscriptaccess="always" wmode="transparent" flashvars="highlighterId=highlighter_551372" menu="false" src="http://ifeve.com/wp-content/plugins/syntaxhighlighter/syntaxhighlighter2/scripts/clipboard.swf"></div><a href="#printSource" title="print" class="item printSource" style="width: 16px; height: 16px;">print</a><a href="#about" title="?" class="item about" style="width: 16px; height: 16px;">?</a></div></div><div class="lines"><div class="line alt1"><table><tbody><tr><td class="number"><code>1</code></td><td class="content"><code class="keyword">public</code> <code class="keyword">class</code> <code class="plain">ReadWriteLock{</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>2</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">boolean</code> <code class="plain">canGrantReadAccess(Thread callingThread){</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>3</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(isWriter(callingThread)) </code><code class="keyword">return</code> <code class="keyword">true</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>4</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(writingThread != </code><code class="keyword">null</code><code class="plain">) </code><code class="keyword">return</code> <code class="keyword">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>5</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(isReader(callingThread) </code><code class="keyword">return</code> <code class="keyword">true</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>6</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(writeRequests &gt; </code><code class="value">0</code><code class="plain">) </code><code class="keyword">return</code> <code class="keyword">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>7</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="keyword">true</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>8</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>9</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div></div></div>
<h4 id="full">可重入的ReadWriteLock的完整实现</h4>
<p>
下面是完整的ReadWriteLock实现。为了便于代码的阅读与理解，简单对上面的代码做了重构。重构后的代码如下。
</p>
<div id="highlighter_762535" class="syntaxhighlighter  "><div class="bar              "><div class="toolbar"><a href="#viewSource" title="view source" class="item viewSource" style="width: 16px; height: 16px;">view source</a><div class="item copyToClipboard"><embed width="16" height="16" id="highlighter_762535_clipboard" type="application/x-shockwave-flash" title="copy to clipboard" allowscriptaccess="always" wmode="transparent" flashvars="highlighterId=highlighter_762535" menu="false" src="http://ifeve.com/wp-content/plugins/syntaxhighlighter/syntaxhighlighter2/scripts/clipboard.swf"></div><a href="#printSource" title="print" class="item printSource" style="width: 16px; height: 16px;">print</a><a href="#about" title="?" class="item about" style="width: 16px; height: 16px;">?</a></div></div><div class="lines"><div class="line alt1"><table><tbody><tr><td class="number"><code>001</code></td><td class="content"><code class="keyword">public</code> <code class="keyword">class</code> <code class="plain">ReadWriteLock{</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>002</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="plain">Map&lt;Thread, Integer&gt; readingThreads =</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>003</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">new</code> <code class="plain">HashMap&lt;Thread, Integer&gt;();</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>004</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>005</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">int</code> <code class="plain">writeAccesses&nbsp;&nbsp;&nbsp; = </code><code class="value">0</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>006</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">int</code> <code class="plain">writeRequests&nbsp;&nbsp;&nbsp; = </code><code class="value">0</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>007</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="plain">Thread writingThread = </code><code class="keyword">null</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>008</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>009</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">public</code> <code class="keyword">synchronized</code> <code class="keyword">void</code> <code class="plain">lockRead() </code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>010</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">throws</code> <code class="plain">InterruptedException{</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>011</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">Thread callingThread = Thread.currentThread();</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>012</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">while</code><code class="plain">(! canGrantReadAccess(callingThread)){</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>013</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">wait();</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>014</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>015</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>016</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">readingThreads.put(callingThread,</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>017</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">(getReadAccessCount(callingThread) + </code><code class="value">1</code><code class="plain">));</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>018</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>019</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>020</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">boolean</code> <code class="plain">canGrantReadAccess(Thread callingThread){</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>021</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(isWriter(callingThread)) </code><code class="keyword">return</code> <code class="keyword">true</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>022</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(hasWriter()) </code><code class="keyword">return</code> <code class="keyword">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>023</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(isReader(callingThread)) </code><code class="keyword">return</code> <code class="keyword">true</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>024</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(hasWriteRequests()) </code><code class="keyword">return</code> <code class="keyword">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>025</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="keyword">true</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>026</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>027</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>028</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>029</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">public</code> <code class="keyword">synchronized</code> <code class="keyword">void</code> <code class="plain">unlockRead(){</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>030</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">Thread callingThread = Thread.currentThread();</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>031</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(!isReader(callingThread)){</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>032</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">throw</code> <code class="keyword">new</code> <code class="plain">IllegalMonitorStateException(</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>033</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"Calling Thread does not"</code> <code class="plain">+</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>034</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">" hold a read lock on this ReadWriteLock"</code><code class="plain">);</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>035</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>036</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">int</code> <code class="plain">accessCount = getReadAccessCount(callingThread);</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>037</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(accessCount == </code><code class="value">1</code><code class="plain">){ </code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>038</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">readingThreads.remove(callingThread); </code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>039</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code><code class="keyword">else</code> <code class="plain">{ </code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>040</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">readingThreads.put(callingThread, (accessCount -</code><code class="value">1</code><code class="plain">));</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>041</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>042</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">notifyAll();</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>043</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>044</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>045</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">public</code> <code class="keyword">synchronized</code> <code class="keyword">void</code> <code class="plain">lockWrite() </code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>046</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">throws</code> <code class="plain">InterruptedException{</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>047</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">writeRequests++;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>048</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">Thread callingThread = Thread.currentThread();</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>049</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">while</code><code class="plain">(!canGrantWriteAccess(callingThread)){</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>050</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">wait();</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>051</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>052</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">writeRequests--;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>053</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">writeAccesses++;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>054</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">writingThread = callingThread;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>055</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>056</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>057</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">public</code> <code class="keyword">synchronized</code> <code class="keyword">void</code> <code class="plain">unlockWrite() </code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>058</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">throws</code> <code class="plain">InterruptedException{</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>059</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(!isWriter(Thread.currentThread()){</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>060</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">throw</code> <code class="keyword">new</code> <code class="plain">IllegalMonitorStateException(</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>061</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"Calling Thread does not"</code> <code class="plain">+</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>062</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">" hold the write lock on this ReadWriteLock"</code><code class="plain">);</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>063</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>064</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">writeAccesses--;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>065</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(writeAccesses == </code><code class="value">0</code><code class="plain">){</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>066</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">writingThread = </code><code class="keyword">null</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>067</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>068</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">notifyAll();</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>069</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>070</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>071</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">boolean</code> <code class="plain">canGrantWriteAccess(Thread callingThread){</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>072</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(isOnlyReader(callingThread)) </code><code class="keyword">return</code> <code class="keyword">true</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>073</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(hasReaders()) </code><code class="keyword">return</code> <code class="keyword">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>074</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(writingThread == </code><code class="keyword">null</code><code class="plain">) </code><code class="keyword">return</code> <code class="keyword">true</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>075</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(!isWriter(callingThread)) </code><code class="keyword">return</code> <code class="keyword">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>076</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="keyword">true</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>077</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>078</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>079</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>080</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">int</code> <code class="plain">getReadAccessCount(Thread callingThread){</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>081</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">Integer accessCount = readingThreads.get(callingThread);</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>082</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(accessCount == </code><code class="keyword">null</code><code class="plain">) </code><code class="keyword">return</code> <code class="value">0</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>083</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="plain">accessCount.intValue();</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>084</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>085</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>086</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>087</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">boolean</code> <code class="plain">hasReaders(){</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>088</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="plain">readingThreads.size() &gt; </code><code class="value">0</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>089</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>090</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>091</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">boolean</code> <code class="plain">isReader(Thread callingThread){</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>092</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="plain">readingThreads.get(callingThread) != </code><code class="keyword">null</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>093</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>094</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>095</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">boolean</code> <code class="plain">isOnlyReader(Thread callingThread){</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>096</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="plain">readingThreads.size() == </code><code class="value">1</code> <code class="plain">&amp;&amp;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>097</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">readingThreads.get(callingThread) != </code><code class="keyword">null</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>098</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>099</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>100</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">boolean</code> <code class="plain">hasWriter(){</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>101</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="plain">writingThread != </code><code class="keyword">null</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>102</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>103</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>104</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">boolean</code> <code class="plain">isWriter(Thread callingThread){</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>105</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="plain">writingThread == callingThread;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>106</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>107</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>108</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">boolean</code> <code class="plain">hasWriteRequests(){</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>109</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="keyword">this</code><code class="plain">.writeRequests &gt; </code><code class="value">0</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>110</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>111</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div></div></div>
<h4 id="finally">在finally中调用unlock()</h4>
<p>
在利用ReadWriteLock来保护临界区时，如果临界区可能抛出异常，在finally块中调用readUnlock()和writeUnlock()就显得很重要了。这样做是为了保证ReadWriteLock能被成功解锁，然后其它线程可以请求到该锁。这里有个例子：
</p>
<div id="highlighter_804412" class="syntaxhighlighter  "><div class="bar         "><div class="toolbar"><a href="#viewSource" title="view source" class="item viewSource" style="width: 16px; height: 16px;">view source</a><div class="item copyToClipboard"><embed width="16" height="16" id="highlighter_804412_clipboard" type="application/x-shockwave-flash" title="copy to clipboard" allowscriptaccess="always" wmode="transparent" flashvars="highlighterId=highlighter_804412" menu="false" src="http://ifeve.com/wp-content/plugins/syntaxhighlighter/syntaxhighlighter2/scripts/clipboard.swf"></div><a href="#printSource" title="print" class="item printSource" style="width: 16px; height: 16px;">print</a><a href="#about" title="?" class="item about" style="width: 16px; height: 16px;">?</a></div></div><div class="lines"><div class="line alt1"><table><tbody><tr><td class="number"><code>1</code></td><td class="content"><code class="plain">lock.lockWrite();</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>2</code></td><td class="content"><code class="keyword">try</code><code class="plain">{</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>3</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">//do critical section code, which may throw exception</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>4</code></td><td class="content"><code class="plain">} </code><code class="keyword">finally</code> <code class="plain">{</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>5</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">lock.unlockWrite();</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>6</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div></div></div>
<p>
上面这样的代码结构能够保证临界区中抛出异常时ReadWriteLock也会被释放。如果unlockWrite方法不是在finally块中调用的，当临界区抛出了异常时，ReadWriteLock 会一直保持在写锁定状态，就会导致所有调用lockRead()或lockWrite()的线程一直阻塞。唯一能够重新解锁ReadWriteLock的因素可能就是ReadWriteLock是可重入的，当抛出异常时，这个线程后续还可以成功获取这把锁，然后执行临界区以及再次调用unlockWrite()，这就会再次释放ReadWriteLock。但是如果该线程后续不再获取这把锁了呢？所以，在finally中调用unlockWrite对写出健壮代码是很重要的。
</p>
<div style="margin-top: 15px; font-style: italic">
<p><strong>原创文章，转载请注明：</strong> 转载自<a href="http://ifeve.com/" target="_blank" rel="noopener">并发编程网 – ifeve.com</a><strong>本文链接地址:</strong> <a href="http://ifeve.com/read-write-locks/" target="_blank" rel="noopener">Java中的读/写锁</a></p>
<p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>读写锁</tag>
        <tag>ReentrantReadWriteLock</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程实战4-自旋锁，死锁，以及锁重入详解</title>
    <url>/2018/04/09/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%984-%E8%87%AA%E6%97%8B%E9%94%81%EF%BC%8C%E6%AD%BB%E9%94%81%EF%BC%8C%E4%BB%A5%E5%8F%8A%E9%94%81%E9%87%8D%E5%85%A5%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<ul>
<li>锁重入：也叫做递归锁<ul>
<li>某个线程获得一个已经由<strong>它自己</strong>持有的锁对象，那么这个请求就会成功，即重入</li>
<li>重入是对本线程来说，即本线程多资源可以多次加锁进入，而不会出现阻塞</li>
<li>在JAVA环境下 ReentrantLock 和synchronized 都是可重入锁</li>
<li>场景：比如数据库中，用户名和密码保存在本地txt文件中，则登录验证方法和更新密码方法都应该被加synchronized，那么当更新密码的时候需要验证密码的合法性，所以需要调用验证方法，相当于二次入锁，此时是可以调用的。</li>
</ul>
</li>
<li>自旋锁<ul>
<li>当一个线程访问的资源被其他线程占用时，此线程并不会等待，而是一直尝试获取锁，即仍然占用CPU，直到获取锁为止。</li>
</ul>
</li>
<li>死锁<ul>
<li>资源互斥导致互相占用不放</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>volatile变量原理与使用<a href="https://www.ibm.com/developerworks/cn/java/j-jtp06197.html" target="_blank" rel="noopener">链接：IBM-正确使用 Volatile 变量</a><ul>
<li>Volatile称之为轻量级锁，被volatile修饰的变量，在线程之间是可见的（处理器内部lock指令标记）。</li>
<li>可见：一个线程修改了这个变量的值，在另外一个线程中能够立即读到这个修改后的值。</li>
<li>volatile 变量可以被看作是一种 “程度较轻的 synchronized”；与 synchronized 块相比，volatile 变量所需的编码较少，并且运行时开销也较少，但是它所能实现的功能也仅是 synchronized 的一部分。<strong>Volatile 变量具有synchronized 的可见性特性，但是不具备原子特性。</strong></li>
<li>要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件：<ul>
<li>对变量的写操作不依赖于当前值。</li>
<li>该变量没有包含在具有其他变量的不变式中。<br>第一个条件的限制使 volatile 变量不能用作线程安全计数器。虽然增量操作（x++）看上去类似一个单独操作，实际上它是一个由读取－修改－写入操作序列组成的组合操作，必须以原子方式执行，而 volatile 不能提供必须的原子特性。实现正确的操作需要使 x 的值在操作期间保持不变，而 volatile 变量无法实现这点。（然而，如果将值调整为只从单个线程写入，那么可以忽略第一个条件。）</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>JDK1.5提供的原子类原理与应用<br>Atomic一词跟原子有点关系，后者曾被人认为是最小物质的单位。计算机中的Atomic是指不能分割成若干部分的意思。如果一段代码被认为是Atomic，则表示这段代码在执行过程中，是不能被中断的。通常来说，原子指令由硬件提供，供软件来实现原子方法（某个线程进入该方法后，就不会被中断，直到其执行完成）<br>在x86 平台上，CPU提供了在指令执行期间对总线加锁的手段。CPU芯片上有一条引线#HLOCK pin，如果汇编语言的程序中在一条指令前面加上前缀”LOCK”，经过汇编以后的机器代码就使CPU在执行这条指令的时候把#HLOCK pin的电位拉低，持续到这条指令结束时放开，从而把总线锁住，这样同一总线上别的CPU就暂时不能通过总线访问内存了，保证了这条指令在多处理器环境中的原子性。</p>
<ul>
<li>原子变量的原子操作也是用到了锁，只不过这个是硬件指令级别的锁，比我们软件实现的锁高效很多，更重要的是如果出现了冲突，只是不停的循环重试，而不会切换线程。如：do{ }while 循环调用一个本地方法。</li>
</ul>
</li>
<li><p>Lock锁的认识与使用</p>
<ul>
<li>lock的使用类似如下：<br><img src="http://osiy4s0ad.bkt.clouddn.com/soundblog/1523269535365.jpg" alt="lock使用"></li>
<li>使用方式类似于synchronized，具有相同的互斥性和内存可见性，但是更加灵活，加锁和放锁可以由使用者自己确定</li>
<li>优势：<ul>
<li>synchronized锁可能出现异常而导致中断，无法释放锁，但是通过使用lock，可以直接将lock放在异常finally中，强制释放锁。<ul>
<li>可以方便的实行公平性</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>AbstractQueuedSynchronizer(AQS)详解</p>
<ul>
<li><p>AQS是一个用来构建锁和同步器的框架,它在内部定义了一个int state变量,用来表示同步状态.在LOCK包中的相关锁(常用的有ReentrantLock、 ReadWriteLock)都是基于AQS来构建.然而这些锁都没有直接来继承AQS,而是定义了一个Sync类去继承AQS.那么为什么要这样呢?because:锁面向的是使用用户,而同步器面向的则是线程控制,那么在锁的实现中聚合同步器而不是直接继承AQS就可以很好的隔离二者所关注的事情。</p>
</li>
<li><p>即AQS用来记录线程状态，并不管理线程，所以是内部定义，而不是直接继承</p>
</li>
<li><p>java.util.concurrent中的同步器类：</p>
<ul>
<li><p>RentrantLock</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 源码</span></span><br><span class="line"><span class="comment">         * Performs non-fair tryLock.  tryAcquire is implemented in</span></span><br><span class="line"><span class="comment">         * subclasses, but both need nonfair try for trylock method.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">            final Thread current = Thread.currentThread();</span><br><span class="line">            int c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                int nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    throw new Error("Maximum lock count exceeded");</span><br><span class="line">                setState(nextc);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">            int c = getState() - releases;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">                throw new IllegalMonitorStateException();</span><br><span class="line">            boolean free = false;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                free = true;</span><br><span class="line">                setExclusiveOwnerThread(null);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c);</span><br><span class="line">            return free;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ReentrantReadWriteLock</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>公平锁和非公平锁（是否考虑队列问题）</p>
<ul>
<li>公平锁（Fair）：加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得 </li>
<li>非公平锁（Nonfair）：加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待<br>非公平锁性能比公平锁高5~10倍，因为公平锁需要在多核的情况下维护一个队列，Java中的ReentrantLock 默认的lock()方法采用的是非公平锁。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>自旋锁</tag>
        <tag>锁重入</tag>
        <tag>volatile</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程实战3-单例模式与线程安全性问题</title>
    <url>/2018/04/09/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%983-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>单例模式是为了保证一个应用中只有一个实例对象，在单线程的情况下，只需对构造方法私有化，加上对象唯一指定就能实现，但是在多线程的情况下，就会出现问题</p>
</blockquote>
<ul>
<li>指令重排序：<ul>
<li>大多数现代微处理器都会采用将指令乱序执行（out-of-order execution，简称OoOE或OOE）的方法，在条件允许的情况下，直接运行当前有能力立即执行的后续指令，避开获取下一条指令所需数据时造成的等待3。通过乱序执行的技术，处理器可以大大提高执行效率。</li>
<li>即为了降低数据的切换获取，在不影响单线程程序逻辑的前提下，处理器会将同一资源的指令一起执行，而打乱中间的顺序。所以就会导致，如下，还没有new对象的同时（2），就已经制定了对象地址（3），即顺序为132。</li>
</ul>
</li>
</ul>
<p>单例模式的分类：</p>
<ul>
<li>饿汉式<ul>
<li>由于饿汉式是在初始化时就生成了对象，所以不存在安全问题</li>
</ul>
</li>
</ul>
<pre><code><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author: ZouTai</span></span><br><span class="line"><span class="comment"> * @date: 2018/4/8</span></span><br><span class="line"><span class="comment"> * @description: 饿汉式：初始化实例(线程一定安全)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public class Singleton &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、构造方法私有</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2、建立静态对象，单个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public static Singleton singleton = new Singleton();</span><br><span class="line"></span><br><span class="line">    public Singleton getInstance() &#123;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ul>
<li>懒汉式<ul>
<li>懒汉式是在用的是时候才会初始化对象，当多个线程访问，就会出现线程安全问题</li>
</ul>
</li>
</ul>
<pre><code><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author: ZouTai</span></span><br><span class="line"><span class="comment"> * @date: 2018/4/8</span></span><br><span class="line"><span class="comment"> * @description: 懒汉式：不初始化实例，在用的时候才初始化（线程不安全）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public class Singleton2 &#123;</span><br><span class="line">    private Singleton2() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static Singleton2 singleton = null;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 双重检查加锁-或者叫做细粒度锁</span></span><br><span class="line"><span class="comment">     * 偏向锁-》轻量级锁-》重量级锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public static Singleton2 getInstance() &#123;</span><br><span class="line">        <span class="comment">//自旋=while(true)占用cpu</span></span><br><span class="line">        <span class="keyword">if</span> (singleton == null) &#123; <span class="comment">// 读取时不会冲突</span></span><br><span class="line">            synchronized (Singleton2.class) &#123;</span><br><span class="line">                <span class="comment">// 之所以再次判断，是为了防止其他线程已经更改了</span></span><br><span class="line">                <span class="keyword">if</span> (singleton == null) &#123;</span><br><span class="line">                    singleton = new Singleton2();// 指令重排序</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 申请一块内存空间   // 1</span></span><br><span class="line">                   <span class="comment">// 在这块空间里实例化对象  // 2</span></span><br><span class="line">                   <span class="comment">// instance的引用指向这块空间地址   // 3</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
        <tag>多线程</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程实战2-Synchronized原理与使用</title>
    <url>/2018/04/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%982-Synchronized%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<ul>
<li><p>Synchronized分类：修饰实例方法、静态方法和代码块</p>
<ul>
<li>1、放在普通类方法上，内置锁就是实例对象</li>
<li>2、修饰静态方法，内置锁为当前的class字节码对象Sequence.class</li>
<li>3、修饰代码块，内置锁为括号里的对象</li>
</ul>
</li>
<li><p>锁分类：偏向锁、轻量级锁和重量级锁<br>Synchronized是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。因此，这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”。JDK中对Synchronized做的种种优化，其核心都是为了减少这种重量级锁的使用。JDK1.6以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和“偏向锁”。<br>偏向锁、轻量级锁都是乐观锁，重量级锁是悲观锁。这种设计是为了根据实际的运行状态在不断变化锁的性质，即最开始默认是单线程，即偏向锁，之后如果来了另一个线程就变为轻量级锁，此时两个所冲突并不大，资源是交互使用的。但是，再接着，发现这两个锁总是相互枪资源，就变成重量级锁。  </p>
<ul>
<li>偏向锁：一个对象刚开始实例化的时候，没有任何线程来访问它的时候。它是可偏向的，意味着，它现在认为只可能有一个线程来访问它，所以当第一个线程来访问它的时候，它会偏向这个线程，此时，对象持有偏向锁。偏向第一个线程，这个线程在修改对象头成为偏向锁的时候使用CAS操作，并将对象头中的ThreadID改成自己的ID，之后再次访问这个对象时，只需要对比ID，不需要再使用CAS锁重入，再进行操作。</li>
<li>轻量级锁：一旦有第二个线程访问这个对象，因为偏向锁不会主动释放，所以第二个线程可以看到对象时偏向状态，这时表明在这个对象上已经存在竞争了，检查原来持有该对象锁的线程是否依然存活，如果挂了，则可以将对象变为无锁状态，然后重新偏向新的线程，如果原来的线程依然存活，则马上执行那个线程的操作栈，检查该对象的使用情况，如果仍然需要持有偏向锁，则偏向锁升级为轻量级锁，（偏向锁就是这个时候升级为轻量级锁的）。如果不存在使用了，则可以将对象回复成无锁状态，然后重新偏向。轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。 </li>
<li>重量级锁：当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。</li>
</ul>
</li>
</ul>
<p><a href="http://www.cnblogs.com/paddix/p/5405678.html" target="_blank" rel="noopener">内部原理详解博客</a><br><a href="https://www.zhihu.com/question/53826114" target="_blank" rel="noopener">知乎-生动的解释</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>偏向锁</tag>
        <tag>monitor</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程实战1-多线程的周期、实现方式和意义</title>
    <url>/2018/04/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%91%A8%E6%9C%9F%E3%80%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%92%8C%E6%84%8F%E4%B9%89/</url>
    <content><![CDATA[<p>day01:线程的周期</p>
<p><img src="http://osiy4s0ad.bkt.clouddn.com/soundblog/1523156274841.jpg" alt="线程的周期"></p>
<p>day02:创建线程的多种方式(7中)：<br><strong>一般推荐采用Runnable接口或者Callable接口来实现多线程。</strong></p>
<p>西红丝鸡蛋汤：</p>
<ol>
<li>继承Thread类<ul>
<li>主线成为最简单的汤的做法，现在需要仿照这个做法，定做自己的</li>
<li>直接继承，可以使用一些父线程的共同属性</li>
</ul>
</li>
<li>实现Runnable接口<ul>
<li>做汤的方法都知道，但是需要自己安排</li>
<li>还可以继承其他类，可拓展性比较好</li>
<li>由于接口内部调用的是同一个target，多个线程共享一个target，所以更适合多线程共享统一资源。  <figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public void run() &#123;</span><br><span class="line">       <span class="keyword">if</span> (target != null) &#123;</span><br><span class="line">           target.run();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>带返回值的线程/实现Callable接口的<ul>
<li>大体的方式都知道，但是需要缺少西红柿，需要开个线程，把西红柿提前做好用于备用（返回值），等汤都做好了，只需要向其中加入西红柿就可以了（调用）</li>
<li>同第二种方式类似，只是这里的使用了FutureTask，作用相当于提前分配一个线程任务用于计算一个程序的结果，这个结果将在之后的主线程调用<code>int result = futureTask.get();</code>。</li>
</ul>
</li>
</ol>
<hr>
<ol start="4">
<li>匿名内部类的方式<ul>
<li>我的主要目的是做一顿晚饭（主类），所以西红柿鸡蛋汤并不是主体（只是主体的一部分），这时候，只需要在做饭内部，定义一个做西红柿鸡蛋汤的匿名内部类就行了。</li>
<li>匿名内部类，相当于直接在主线程中加入一个内部类，相当于一个小的脚本，不影响主类。</li>
</ul>
</li>
<li>定时器（quartz）<ul>
<li>为了准确把握做汤的时间，我们需要一个定时器，仅仅是sleep不能满足要求。因为，有时候，这个定时器需求蛮复杂，有些时候，我们做汤，需要隔一分钟尝一次味道，所以，这个时候就需要定时器，固定时间重复一个线程。</li>
</ul>
</li>
<li>线程池的实现<ul>
<li>由于汤做的太好了，开启了饭店，由于顾客很多，为了满足需求，需要很多的做汤程序，为了方便，这个时候就需要雇佣一批厨师（线程池），顾客随时到来，随时就可以启动做汤，但是，由于顾客流量不定，厨师太多太少，都不好。通过分析客户流量，发现10个厨师，刚好满足要求，所以就设置线程池大小为10。</li>
<li>为了满足高并发要求，需要提前备用多个线程在进行操作。</li>
</ul>
</li>
<li>Lambda表达式实现<ul>
<li>同上，需求很大时对西红柿的要求也很大，所以洗西红柿也需要多个人来进行，而且，和做汤不同，洗西红柿的只会洗西红柿（数据计算），所以jdk8就启用了一个lambda表达式，让这些专职工人只做一件事。</li>
<li>lambda表达式有一个数据计算并行流parallelStream，可以对list等直接进行并行计算：<code>return list.parallelStream().mapToInt(i -&gt; i * 2).sum();</code></li>
</ul>
</li>
<li>Spring实现多线程<ul>
<li>spring中有个@Async注解，可以实现多线程</li>
</ul>
</li>
</ol>
<hr>
<p>day03：多线程几个主要指标</p>
<ul>
<li><p>一、活跃性问题</p>
<ul>
<li><p>死锁：即线程资源调用互斥，哲学家吃饭问题（刀叉互斥）</p>
</li>
<li><p>饥饿（不公平）：</p>
<ul>
<li>由于某个线程太弱，优先级太低的问题，导致这个线程始终无法抢到CPU资源，就会导致，这个线程饥饿（排队买饭，前面总是有插队的，你就饿死了）</li>
<li>某一个线程获取了资源的锁，一直占用着，导致另一个线程无法获取此资源，也会饥饿</li>
<li>wait和notify，线程wait后，没有其他线程来notify它，也会被饿死。</li>
</ul>
</li>
<li><p>活锁：之所以称之为活锁，是相对与死锁而言，活锁并没有阻塞，还是在正常运行，只是，这种运行，执行一部分就回滚，一直在重复，相当于一直在做无用功。一般出现在事务回滚中，由于两个线程资源故障，导致都一起回滚，然而，重新开始，还是遇到了这个问题，就一起一直回滚下去。比如，两台机器发送数据，由于通道同时被占用，<strong>就都等了一秒</strong>，再发,这样冲突还是存在。</p>
</li>
<li><p><strong>如何避免饥饿？</strong></p>
<ul>
<li>设置合理的优先级</li>
<li>使用自己实现的锁来代替synchronized，自己会合理的设置锁</li>
</ul>
</li>
</ul>
</li>
<li><p>二、性能问题：多线程并不一定快</p>
<ul>
<li>线程多了，CPU不够，导致一个CPU要应付很多线程，由于线程之间切换，需要保存数据和提取数据，导致切换回占用太多的时间，就会降低整体速度（上下文切换）</li>
</ul>
</li>
<li><p>三、安全性问题</p>
<ul>
<li>出现安全性问题的三个条件：<ul>
<li>多线程环境</li>
<li>共享同一个资源</li>
<li>对资源进行非原子性操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><em>多线程的目的是为了将可以并发操作的操作进行并发执行，而将需要原子性操作的资源进行保护，所以之后会使用到细粒度锁。</em></p>
<p><a href="https://github.com/purice93/ConcurrentThread.git" target="_blank" rel="noopener">源码git</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>多线程</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>一部电影晓生活-韩国</title>
    <url>/2018/04/05/%E4%B8%80%E9%83%A8%E7%94%B5%E5%BD%B1%E6%99%93%E7%94%9F%E6%B4%BB-%E9%9F%A9%E5%9B%BD/</url>
    <content><![CDATA[<blockquote>
<p>和科学技术不同，艺术并不直接促进社会的变革，但是却是一种无形的引导。然而欣赏艺术的能力却并不总是被常人所拥有，而作为八大艺术之一的电影，却显得格外亲民，这种不需要太多“艺术”细胞的东西，相对于美术绘画、音乐旋律等，更容易使人产生共鸣。就像音乐的风格随着时代的不同而改变一样，电影的发展在不同的时期，不同的社会也会有着千差万别，其中多多少少代表着不同社会的发展或者是人们期望发展的方向。</p>
</blockquote>
<hr>
<p><strong>《蚯蚓》，英文名为《My Little Baby, Jaya》</strong></p>
<p>一部电影的主旨往往能够看出起名者想表达的内部含义，前者表达的是对社会的愤懑，后者却包含了更多的父爱。然而电影本身却远远并不只有这些，关键是我们的关注点在哪。</p>
<p>实话实说，对于这部电影，我本想有万字千文来表达，但是在删删改改之后，就直接清空了回收箱。实在是找不到规范的语言来陈述，找不到“礼貌”的词藻来表达，太多的愤世嫉俗让我显得不像是个书生。所以，为了显示一个文化人的身份，我还是化繁为简，简略表达以不失儒家风范。</p>
<p>总体而言，对于这个电影，或者其中发生的时间，看完一小时之后，我就心平气和了，以至于并没有太多的词语想要表达，也没有太多的感悟需要抒发，更没有产生多少的愤懑用来呐喊，唯一的共鸣可能就是偶尔的现实和理想的反差。</p>
<p>过多的同情让我麻木，过多的愤懑让我劳累，过多的反思让我不太喜欢看这些揭露社会黑暗的东西，毕竟这些黑暗的东西谁都知道，只是绝大多数人碰不到，也就无所谓了。然而，法律是需要为可能的发生的事情做准备的，而这就像是如今的韩国社会。许多法律的更改，许多的旧事重提，都是通过历史的翻案或者历史的卑劣记录来实现的。但是，韩国的国情在全世界而言都算是少数的，中国离那也差不多是十万八千零一里了，毕竟中国走的是中国特色社会主义道路，我们既不像韩国那样疯狂，也不会像日本那样保守，而是会在保守中，让历史慢慢前行。</p>
<p>其实，韩国的电影有些时候往往会让人看的更加痛快，一种吸满整口烟气然后一泻而下一样，简直是爽到肺！因为不管结尾是悲是喜，都会让人感到一种“完美”——好人虽然不一定有好的结局，但是坏人一定是会死的。还记得，我第一次爱上韩国电影应该是大二的时候，也是一部这种类型的电影《熔炉》，就如同今天爱上了惊悚片一样，当时也在搜集各种类似的片子，见证各种对社会的讽刺，以达到自己内心的“愉悦”，满足对言论自由的“局部”意淫，从《金福南杀人事件》、《恐怖直播》再到《辩护人》；从国内的《盲井》《盲山》再到《天狗》《天注定》，这些同等类型的片子，无论是揭露社会还是反思历史，多多少少都会带点承重感，承重感多了，就索然无味了，因为刚开始是怕自己会掉入这个深渊，而希望国家能去修补；而之后却是努力远离这个深渊，不关我事。</p>
<p>相对韩国的电影，心目中最喜欢的电影应该算是日本的，如果让我在电影院选择看一部电影，我绝对会去选择一部日本电影，去感受生活中的美好，去感受自然的清新，不去考历史，不去想未来，只活在当下。毕竟电影是种娱乐，而不是一种鞭策社会进步的工具——那是法律该做的事情，我可不希望在劳累的一周之后，本想着在周末来个身心愉悦，却还要在电影院为了社会而烦恼。所以，遍看世界各国主流电影，就会发现，欧美在畅想未来，日本在享受当前，韩国在鞭策历史，印度在讽刺现实，而国内却百花齐放：爱国之花最为灿烂，商业之花偶尔盛开，历史之花即将凋零。</p>
<p><em>科技永在发展，历史总是重复，悲剧往往类似</em></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>电影</tag>
        <tag>蚯蚓</tag>
        <tag>韩国</tag>
        <tag>批判</tag>
        <tag>自由</tag>
        <tag>人性</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式服务器中的session共享问题</title>
    <url>/2018/03/18/%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E7%9A%84session%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>为了使得分发后的多个tomcat服务器，可以对请求session进行共享，我们需要使用一个特殊的数据服务器。<br>一般有memcached和redis3。（redis没有这个功能）</p>
</blockquote>
<p><strong>session共享原理</strong></p>
<ul>
<li>http协议是无状态的，即你连续访问某个网页100次和访问1次对服务器来说是没有区别对待的，因为它记不住你。那么，在一些场合，确实需要服务器记住当前用户怎么办？比如用户登录邮箱后，接下来要收邮件、写邮件，总不能每次操作都让用户输入用户名和密码吧，为了解决这个问题，session的方案就被提了出来，事实上它并不是什么新技术，而且也不能脱离http协议以及任何现有的web技术</li>
<li>session的常见实现形式是会话cookie（session cookie），即未设置过期时间的cookie，这个cookie的默认生命周期为浏览器会话期间，只要关闭浏览器窗口，cookie就消失了。实现机制是当用户发起一个请求的时候，服务器会检查该请求中是否包含sessionid，如果未包含，则系统会创造一个名为JSESSIONID的输出cookie返回给浏览器(只放入内存，并不存在硬盘中)，并将其以HashTable的形式写到服务器的内存里面；当已经包含sessionid是，服务端会检查找到与该session相匹配的信息，如果存在则直接使用该sessionid，若不存在则重新生成新的session。这里需要注意的是session始终是有服务端创建的，并非浏览器自己生成的。但是浏览器的cookie被禁止后session就需要用get方法的URL重写的机制或使用POST方法提交隐藏表单的形式来实现</li>
<li>Session共享：<br>首先我们应该明白，为什么要实现共享，如果你的网站是存放在一个机器上，那么是不存在这个问题的，因为会话数据就在这台机器，但是如果你使用了负载均衡把请求分发到不同的机器呢？这个时候会话id在客户端是没有问题的，但是如果用户的两次请求到了两台不同的机器，而它的session数据可能存在其中一台机器，这个时候就会出现取不到session数据的情况，于是session的共享就成了一个问题</li>
<li>Session一致性解决方案：<ul>
<li>1、session复制<br>tomcat 本身带有复制session的功能。（不讲）</li>
<li>2、共享session<br>需要专门管理session的软件，<br>memcached缓存服务，可以和tomcat整合，帮助tomcat共享管理session。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>利用memcached实现session共享</strong></p>
<ul>
<li>安装mencached<blockquote>
<p>yum -y install memcached<br>service memcached start #启动memcached服务器</p>
</blockquote>
</li>
<li>复制memcached相关的jar包到tomcat的lib下<a href="https://code.google.com/archive/p/memcached-session-manager/downloads" target="_blank" rel="noopener">下载连接</a><br><img src="http://osiy4s0ad.bkt.clouddn.com/soundblog/1521338268310.jpg" alt="memcached相关jar包"></li>
<li>修改tomcat标记<code>vi conf/server.xml</code><br><img src="http://osiy4s0ad.bkt.clouddn.com/soundblog/1521338516695.jpg" alt="添加tomcat标记，用于访问标志"></li>
<li>vim中的查找命令<code>/tag</code>;即命令行模式键入”/“,”tag”即为所需查找的字符串</li>
<li>修改tomcat默认访问页面index.jsp，加入session<br><img src="http://osiy4s0ad.bkt.clouddn.com/soundblog/1521340498851.jpg" alt="修改默认界面index.jsp，添加session支持"> </li>
<li>未添加一致行前，访问nginx时，将产生多个session<br><img src="http://osiy4s0ad.bkt.clouddn.com/soundblog/1521349650737.jpg" alt="tomcat1"><br><img src="http://osiy4s0ad.bkt.clouddn.com/soundblog/1521342012606.jpg" alt="tomcat2"></li>
<li>添加一致性，tomcat连接memcached，将session存入memcached<blockquote>
<p>vi conf/context.xml</p>
</blockquote>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">&lt;Manager className=<span class="string">"de.javakaffee.web.msm.MemcachedBackupSessionManager"</span> </span><br><span class="line">	memcachedNodes=<span class="string">"n1:192.168.116.3:11211"</span> </span><br><span class="line">    sticky=<span class="string">"false"</span> </span><br><span class="line">    lockingMode=<span class="string">"auto"</span></span><br><span class="line">    sessionBackupAsync=<span class="string">"false"</span></span><br><span class="line">	requestUriIgnorePattern=<span class="string">".*\.(ico|png|gif|jpg|css|js)$"</span></span><br><span class="line">    sessionBackupTimeout=<span class="string">"1000"</span> transcoderFactoryClass=<span class="string">"de.javakaffee.web.msm.serializer.kryo.KryoTranscoderFactory"</span> </span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
<img src="http://osiy4s0ad.bkt.clouddn.com/soundblog/1521349290610.jpg" alt="添加memcached连接"></li>
<li>分别修改tomcat对应的index.jsp</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language="java" contentType="text/html; charset=UTF-8"  pageEncoding="UTF-8"%&gt;</span><br><span class="line">SessionID:&lt;%=session.getId()%&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line">SessionIP:&lt;%=request.getServerName()%&gt; </span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&lt;h1&gt;tomcat2 page&lt;/h1&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>重启memcached、nginx和tomcat，访问<code>192.168.116.3</code></li>
<li>效果：sessionID不变，只是服务器页面变化<br><img src="http://osiy4s0ad.bkt.clouddn.com/soundblog/1521349570726.jpg" alt="tomcat1"><br><img src="http://osiy4s0ad.bkt.clouddn.com/soundblog/1521349582665.jpg" alt="tomcat2"></li>
</ul>
<p><strong>注意事项：过程中可能存在各种各样的问题，导致错误。如复制空格问题。当实在无法找到错误原因时，可以文件整体还原，在修改，因为有时候可能是自己错误修改了文件，但是找不到地址了</strong></p>
<hr>
<p>完整参考流程：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.	安装memcached内存数据库</span><br><span class="line">yum –y install memcached</span><br><span class="line">可以用telnet localhost <span class="number">11211</span></span><br><span class="line">Set abc <span class="number">0</span> <span class="number">0</span> <span class="number">5</span></span><br><span class="line"><span class="number">12345</span></span><br><span class="line">get abc </span><br><span class="line"><span class="number">2</span>.	web服务器连接memcached的jar包拷贝到tomcat的lib</span><br><span class="line"><span class="number">3</span>.	修改server.xml里面修改Engine标签，添加jvmRoute属性，目的是查看sessionid里面带有tomcat的名字，就是这里配置的jvmRoute</span><br><span class="line">&lt;Engine name=<span class="string">"Catalina"</span> defaultHost=<span class="string">"localhost"</span> jvmRoute=<span class="string">"tomcat1"</span>&gt;</span><br><span class="line"><span class="number">4</span>.	配置tomcat的conf目录下的context.xml</span><br><span class="line">&lt;Manager className=<span class="string">"de.javakaffee.web.msm.MemcachedBackupSessionManager"</span></span><br><span class="line">        memcachedNodes=<span class="string">"n1:192.168.17.9:11211"</span></span><br><span class="line">    sticky=<span class="string">"false"</span></span><br><span class="line">    lockingMode=<span class="string">"auto"</span></span><br><span class="line">    sessionBackupAsync=<span class="string">"false"</span></span><br><span class="line">        requestUriIgnorePattern=<span class="string">".*\.(ico|png|gif|jpg|css|js)$"</span></span><br><span class="line">sessionBackupTimeout=<span class="string">"1000"</span> transcoderFactoryClass=<span class="string">"de.javakaffee.web.msm.serializer.kryo.KryoTranscoderFactory"</span> /&gt;</span><br><span class="line">配置memcachedNodes属性，配置memcached数据库的ip和端口，默认<span class="number">11211</span>，多个的话用空格隔开</span><br><span class="line">目的？让tomcat服务器从memcached缓存里面拿session或者是放session</span><br><span class="line"><span class="number">5</span>.	修改index.jsp，取sessionid看一看</span><br><span class="line">&lt;%@ page language="java" contentType="text/html; charset=UTF-8"  pageEncoding="UTF-8"%&gt;</span><br><span class="line">&lt;<span class="selector-tag">html</span> lang=<span class="string">"en"</span>&gt;</span><br><span class="line">SessionID:&lt;%=session.getId()%&gt;</span><br><span class="line">&lt;/br&gt;</span><br><span class="line">SessionIP:&lt;%=request.getServerName()%&gt;</span><br><span class="line">&lt;/br&gt;</span><br><span class="line">&lt;h1&gt;tomcat1&lt;/h1&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>


<p><strong>利用redis实现session共享</strong></p>
<ul>
<li>安装redis <code>yum -y install redis</code><br>可能会存在无yum源的问题：</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">CentOS默认的安装源在官方的centos.org上，而redis在第三方的yum源里，因此无法安装。这就是我们常常在yum源里找不到各种软件的原因，还需要自己去wget，然后configure,make,make install，这个过程太痛苦了，并且卸载软件的时候还容易出错。</span><br><span class="line">非官方的yum推荐用fedora的epel仓库。epel (Extra Packages <span class="keyword">for</span> Enterprise Linux)是基于Fedora的一个项目，该仓库下有非常多的软件，建议安装。yum添加epel源的命令为：yum install epel-release然后回车。安装完后，我们使用命令：yum repolist查看。然后重新安装redis</span><br></pre></td></tr></table></figure>
<ul>
<li><p>导入相关的redis-tomcat的jar包到tomcat中（下载链接同上）<br><img src="http://osiy4s0ad.bkt.clouddn.com/soundblog/1521382915270.jpg" alt="三个依赖jar包"></p>
</li>
<li><p>检测是否安装正确</p>
<blockquote>
<p>由于redis默认的打开端口是6379；memcached默认端口是11211；所以可以直接通过telnet来检查端口情况：<code>telnet localhost 6379</code></p>
</blockquote>
</li>
<li><p>修改redis相关配置<code>vi /etc/redis.conf</code>，将bind的127.0.0.1修改为本机地址，否则只能本机访问了。会出现各种错误！</p>
<blockquote>
<p>另外注意：修改的bind为第二个不是第一个！<br><img src="http://osiy4s0ad.bkt.clouddn.com/soundblog/1521446257269.jpg" alt="不是这里的"><br><img src="http://osiy4s0ad.bkt.clouddn.com/soundblog/1521446313973.jpg" alt="而是这里"></p>
</blockquote>
</li>
<li><p>添加redis配置到tomcat中，同memcached一样</p>
</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">&lt;Valve className=<span class="string">"com.orangefunction.tomcat.redissessions.RedisSessionHandlerValve"</span> /&gt;</span><br><span class="line">&lt;Manager className=<span class="string">"com.orangefunction.tomcat.redissessions.RedisSessionManager"</span></span><br><span class="line">         host=<span class="string">"192.168.116.3"</span></span><br><span class="line">         port=<span class="string">"6379"</span></span><br><span class="line">         database=<span class="string">"0"</span></span><br><span class="line">         maxInactiveInterval=<span class="string">"60"</span> /&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试效果<br><img src="http://osiy4s0ad.bkt.clouddn.com/soundblog/1521446558722.jpg" alt="tomcat1"><br><img src="http://osiy4s0ad.bkt.clouddn.com/soundblog/1521446569528.jpg" alt="tomcat2"></li>
</ul>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>session共享</tag>
        <tag>memcached</tag>
      </tags>
  </entry>
  <entry>
    <title>Tensorflow实战Google-第四章深层神经网络知识点</title>
    <url>/2017/10/04/Tensorflow%E5%AE%9E%E6%88%98Google-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E6%B7%B1%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>1.深层神经网络的两个重要参数：多层和非线性</p>
<ul>
<li><p>非线性：</p>
<ul>
<li>相对于以往的神经网络，由于没有使用激活函数，构造出来的函数往往形如：w1x1+w2x2+…+wnxn + b = 0,很显然这种函数只能模拟线性分割。即只能通过直线来划分，一旦分割面是一个圆形，通过这种方式只能尽可能的得到一个多棱角保卫面，而不能拟合成圆形，存在很大的误差。</li>
<li>细想一下，如果我们换一种权重作用方式，比如将w1x1换为x1^w1 或者 w1*e^x1,很显然这种指数函数作用的结果是一种弯曲状态，就能够拟合上面所说的圆形。但是，目前我们采用的方式是直接在输出层外加上一层激活函数（弯曲函数），就能够实现这种方式。激活函数一般有sigmoid、指数函数等，不同的函数作用效果也不一样。</li>
</ul>
</li>
<li><p>多层</p>
<ul>
<li>还是相对于之前的神经网络，由于之前的神经网络没有隐藏层，相当于只有一层权重作用在输入变量上面，这样，w1x1+w2x2+…+wnxn + b = 0函数作用下，无论是几维空间，输出的结果总是为一条直线。</li>
<li>考虑下简单地二维空间，比如进行异或运算。这种方式显然不能够通过一条直线就能够分成两类。再到多维，那将更不可能，一条直线只能分两类，多个类就无法实行。</li>
<li>现在我们想想，既然一层能画一条直线，那我多画几条直线，然后将这两条直线组合一下不就可以了吗？确实是这样，比如进行异或运算，加上一个隐藏层，隐藏层节点为4，这输入到这四个节点的都负责自己的一部分划分，分别划分四个点区域，这样，输出处理时将这四个区域进行组合，就是整个完整的区域。</li>
</ul>
</li>
</ul>
<p>2.损失函数</p>
<ul>
<li>损失函数度量了训练结果和实际结果之间的一种差别，通过这种差别大小来调整神经网络的参数，以此达到优化神经网络的目的。</li>
<li>经典损失函数<br>分类问题的损失函数一般使用交叉熵配合softmax回归；回归问题由于是连续的，一般只有一个输出节点，所以损失函数使用的是均方误差MSE。<ul>
<li>损失函数的计算方式有很多，不同的领域都有各自最优化的方式。经典损失函数就是分类问题和回归问题经常使用到的损失函数。</li>
<li>经典损失函数是一种对训练输出值和实际值相似度的度量，值越小，相似度越大，更准确的解释：经典损失函数（交叉熵）刻画了两个分布概率之间的距离。具体为什么好用，实用就行，暂时不管。</li>
<li>公式：H(p,q)=−∑p(x)logq(x)，这里的p代表真确答案，q代表预测值</li>
<li>显然∑q(x)=1，即概率和等于1。因此，我们需要将输出转化为概率类型。一般而言，我们可以直接计算输出值在整个输出中出现的概率作为计算值，这里我们使用了softmax函数。</li>
<li>softmax回归函数，是将神经网络的输出结果变成概率分布，softmax(yi)=yi’=e^yi/∑e^yj</li>
<li>均方误差函数：MSE(y,y′)=∑(yi−y’i)^2/n</li>
<li>其他损失函数：不同问题不同对待</li>
</ul>
</li>
</ul>
<ol start="3">
<li>神经网络优化-BP算法和梯度下降算法</li>
</ol>
<ul>
<li>梯度下降算法：<ul>
<li>梯度的反方向是函数下降最快的方向，通过这个方式计算，就能够使得函数向着极小值方向迭代，从而达到训练的目的。</li>
<li><strong>学习率</strong>:通过在梯度下降值上加上一个学习率权重，来控制下降的幅度/步长，即控制下降速度的快慢。</li>
<li>几个缺点：<br>  1.只是局部最优解不是全局最优解<br>  2.计算时间长-由于损失函数计算的是所有训练数据上的损失和，所以计算量大<br>  3.为了加快梯度下降，我们可以采用随机梯度下降或者小批量随机下降</li>
</ul>
</li>
</ul>
<ol start="4">
<li>进一步优化</li>
</ol>
<ul>
<li>学习率的优化：在训练初期，差别往往很大，所以这个时候学习率相对较大能够加快训练的速度；但是随着训练的深入，差别减小，为了防止下降跨度太大导致越界，需要降低学习率；这个时候就可以对学习了本进行指数衰减。</li>
<li>过拟合问题：样本不足、样本有噪声、模型结构过于复杂都将导致模型过拟合。<ul>
<li>正则化：为了避免模型复杂导致的过拟合，我们引入了一个思想，即在损失函数中引入/加入衡量模型复杂度的指标，r*R(w),r为正则化系数，R(w)为描述的是模型参数的大小，通过之中方式限制模型参数的大小来限制模型的复杂度。L1、L2正则化</li>
</ul>
</li>
<li>滑动平均模型：为了使得模型更加健壮，即更加稳定。我们使用了滑动平均模型。<ul>
<li>这种模型通过在损失函数中加入一个衰减率decay来，缓冲模型参数变量的变化程度，即不让他变化过大，能走10步的，只让它走一步。</li>
<li>衰减变量：上面这种方式训练速度有点慢，为了让训练初期快，比如走9步，有引入了参数衰减变量，通过训练次数来控制滑动平均的步长大小，越到后期步长越慢。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>ML/DL</category>
      </categories>
      <tags>
        <tag>DNN</tag>
        <tag>CNN</tag>
        <tag>正则化</tag>
      </tags>
  </entry>
  <entry>
    <title>大化设计模式-单例模式</title>
    <url>/2017/09/15/%E5%A4%A7%E5%8C%96%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<ul>
<li><strong>原理</strong>：保证一个类只有一个实例对象，提供一个对外的实例创建方法。</li>
</ul>
<hr>
<ul>
<li><strong>好处</strong>：</li>
</ul>
<ol>
<li>数据共享，多个线程可以共用一个实例，共同享用这个实例的资源属性（如数据库连接器）</li>
<li>线程安全，通过线程加锁，可以达到并发访问的目的</li>
<li>节约资源，防止创建过多不必要的对象</li>
</ol>
<hr>
<ul>
<li><strong>结构图</strong><br><img src="./images/1505455194462.jpg" alt="enter description here"></li>
</ul>
<hr>
<ul>
<li><strong>分类</strong></li>
</ul>
<ol>
<li>懒汉式：实例化调用时才实例化，否则就不实例化</li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//懒汉式  </span></span><br><span class="line">class Singleton  &#123;  </span><br><span class="line">    private static Singleton instance;  </span><br><span class="line">   </span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    public static Singleton GetInstance() &#123;  </span><br><span class="line">        <span class="keyword">if</span> (NULL == instance)  &#123;  </span><br><span class="line">            instance = new Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        return instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>多线程单例：多线程下，加锁</li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//多线程情况下：  </span></span><br><span class="line">class Singleton &#123;  </span><br><span class="line">    private static Singleton instance;  </span><br><span class="line">    <span class="comment">//加一个锁  </span></span><br><span class="line">    private static readonly object sync = new object();  </span><br><span class="line">   </span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    public static Singleton GetInstance() &#123;  </span><br><span class="line">    	<span class="comment">//先判断是否存在，再加锁！</span></span><br><span class="line">        <span class="keyword">if</span> (NULL == instance) &#123;  </span><br><span class="line">            lock(sync) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (NULL == instance)&#123;  </span><br><span class="line">                    instance = new Singleton();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        return instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>饿汉式：通过静态修饰，使得在加载时就直接实例化，提前做准备。</li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//饿汉式  </span></span><br><span class="line">public sealed class Singleton &#123;  </span><br><span class="line">    <span class="comment">// 通过static final修饰，进行初始化加载，同时无法更改</span></span><br><span class="line">    private static final Singleton instance = new Singleton();  </span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    public static Singleton GetInstance()&#123;  </span><br><span class="line">        return instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>网站架构</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>大话设计模式-设计模式六大原则</title>
    <url>/2017/09/13/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<p>参考链接：<a href="http://www.uml.org.cn/sjms/201211023.asp#4" target="_blank" rel="noopener">http://www.uml.org.cn/sjms/201211023.asp#4</a><br>参考书：大话设计模式<br>###设计模式原则</p>
<ol>
<li>单一职责原则</li>
<li>开放封闭原则</li>
<li>依赖倒转原则</li>
<li>接口隔离原则</li>
<li>迪米特法原则</li>
<li>里氏替换原则</li>
</ol>
<hr>
<ul>
<li>单一职责原则（做好自己的专业，降低耦合度）：为了后期的便于修改和添加，降低各功能之间的耦合度，在开发的初期就需要将每一个功能单独分离出来，而不是放在一起；</li>
</ul>
<hr>
<ul>
<li>开放封闭原则（少修改多扩展）：扩展开放，修改封闭；即可以添加，但是不能够修改。面对需求，对程序的改动是通过添加新的代码，而不是修改旧的代码，这样便于后期维护。</li>
</ul>
<hr>
<ul>
<li>依赖倒转原则（面向对象：继承接口）：当我们需要实现某个需求时，不要严格地在现有的模块上去开发，这样的话，当现有的模块出现问题，会牵连当前的模块。所以，我们需要开发一种接口，这种接口不涉及具体的细节问题，即不作具体的事，只是提供一个可以继承实现的接口工具，用于调用。抽象不应该依赖具体的细节，细节应该依赖抽象。（接口）</li>
</ul>
<hr>
<ul>
<li>里氏替换原则（面向对象：继承父类）：即子类包括父类的全部属性及功能，可以完全替换父类，而软件单位不发生变化。这样，父类就可以再不修改的情况下，扩展出各种不同的子类。</li>
</ul>
<hr>
<ul>
<li>接口隔离原则：不同的功能应该通过不同的接口来实现，而不是在一个接口内。相当于单一职责。</li>
</ul>
<hr>
<ul>
<li>迪米特法原则：如果两个类之间没有大的关联，就不必要直接相互作用，而是通过第三方来进行作用传递。即降低类之间的耦合度。类之间的耦合度越弱，一个类被修改，就不会对有关的其他类产生影响。</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>网站架构</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
