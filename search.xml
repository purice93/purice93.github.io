<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>《大型网站技术架构》读书笔记</title>
    <url>/2019/12/05/%E3%80%8A%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>遇到的问题多了，也就成了架构师</p>
</blockquote>
<p>作者：李智慧<br>简介：<a href="https://www.zhihu.com/people/li-zhi-hui-87/activities" target="_blank" rel="noopener">https://www.zhihu.com/people/li-zhi-hui-87/activities</a></p>
<p><strong>概述</strong></p>
<p>第一章：大型网站架构演化</p>
<ul>
<li><p>大型软件的特点，需要解决的几个重要问题：</p>
<ul>
<li>高并发、大流量</li>
<li>高可用</li>
<li>用户分布广泛，网络复杂</li>
<li>安全性可扩展性、迭代开发</li>
</ul>
</li>
<li><p>网站架构发展：最初是一台机器：包括处理逻辑-数据库-文件系统-前端等</p>
</li>
<li><p>模块分拆：解决业务冗余和单机压力</p>
<ul>
<li>应用服务和数据分离；单独的数据库服务，如mysql、redis；网站分为应用服务器-文件服务器-数据服务器</li>
</ul>
</li>
<li><p>使用缓存：解决数据库压力</p>
<ul>
<li>80%的业务集中在20%的数据上；</li>
<li>缓存有两种：本地缓存和服务器缓存，区别在于，本地缓存直接依附于应用服务器，访问更加快速，没有网络延迟的问题，却受限于本地内存的大小，占用应用程序资源。而服务器缓存，相当于建立一个独立的集群缓存服务器，能够大大扩展内存，但是却容易受到网络的影响，比如延迟、中断等；另外还包括缓存服务器的维护和可靠性。</li>
</ul>
</li>
<li><p>服务器集群：解决高并发、大数据访问</p>
<ul>
<li>当同一时间出现大量的数据访问时，一台机器是无法处理的，此时就需要多台机器分发处理，通过部署前端负载均衡处理器，将不同的业务按照均衡的算法逻辑，分发给不同的服务器进行处理</li>
</ul>
</li>
<li><p>数据库读写分离：</p>
<ul>
<li>对于一个成熟的系统，大部分业务场景是查询场景而不是修改场景，但是数据库的修改需要保持一致性，这就导致数据修改时的加锁限制会降低查询的效率，因此可以将读写义务进行分离。</li>
<li>读写分离的实现方式一般是主从搭配，主写副读，单主多副；</li>
<li>查询业务直接读取从服务器，写入业务操作主服务器，同时将主服务器修改的数据同步到从服务器。</li>
</ul>
</li>
<li><p>业务数据缓存：CDN加速和反向代理</p>
<ul>
<li>上述两个方法都是将用户请求的数据进行指直接缓存，比如页面，图片或者音乐，这些网站的规定资源。即同一个访问，如果请求相同，直接返回上次的缓存数据，而不再请求中央服务器。比如浏览器刷新，同样的图片不再请求。</li>
<li>不同的是缓存的数据存储在网络服务商还是自己的服务器上</li>
<li>CDN加速：即数据缓存在网络服务商的服务器上，比如电信、网通等</li>
<li>反向代理：即自己的服务器，接受服务后，判断是否是不需要更新的数据，如果不是，直接访问本地缓存数据。</li>
</ul>
</li>
<li><p>使用分布式文件系统和分布式数据库系统</p>
<ul>
<li>文件压力大，需要分布式，数据库压力大，需要分库</li>
</ul>
</li>
<li><p>NOSQL和搜索引擎</p>
<ul>
<li>非关系型数据库能够更好地根据业务的类型进行匹配，比如某些缓存数据库性能更高。</li>
<li>非数据库数据如搜索引擎ES，能够更好地符合某些查询业务</li>
</ul>
</li>
<li><p>业务拆分或微服务</p>
<ul>
<li>通过将项目拆分成多个独立的业务，对业务进行解耦，使用RPC或MQ进行通信</li>
</ul>
</li>
<li><p>分布式服务和中台架构</p>
<ul>
<li>将共同的业务模块独立出来，从而更好地进行资源整合网</li>
</ul>
</li>
</ul>
<p><em>站的一切技术都要根据业务来进行扩展</em></p>
<p><strong>第二章：大型网站架构模式</strong></p>
<p><em>模式即一种共用的设计结构，为了便于网站的构建，一般网站会对不同的业务进行不同的架构设计</em></p>
<ul>
<li><p>分层：即对业务流水线进行分层，最简单的就是MVC和七层网络模型</p>
</li>
<li><p>分割：分层是横向分割，分割是纵向分割，比如把多个应用模块分割出来，比如订单系统可以分为：下单、去出库、支付三个模块</p>
</li>
<li><p>分布式：分层分割之后一般部署在不同的机器上就相当于分布式。以下为几种分布式方案：</p>
<ul>
<li>分布式应用和服务：即将应用程序分布</li>
<li>分布式数据和存储：即分布式数据库缓存</li>
<li>分布式静态资源：固定的文件图片等</li>
<li>分布式计算服务：比如hadoop的map-reduce，将计算进行分布，而不是资源：即分别在多处进行计算，然后将计算结果进行汇聚；而不是将资源进行汇聚再计算</li>
</ul>
</li>
<li><p>集群：分布式是为了降低模块间的依赖程度和解决资源紧张问题，比如数据库紧张，就将数据库独立出来，分布式部署。但是集群相当于整个服务，集群的作用也是解决高并发问题，不同的地方在于，集群是解决整体的高并发，分布式是为了解决某个资源或业务的高并发，比如数据库访问、下单和支付。</p>
</li>
<li><p>缓存：缓存是离计算最近的地方，一般将热点数据进行直接保存，减轻底层数据库压力</p>
<ul>
<li>CDN缓存</li>
<li>反向代理：反向代理机器缓存</li>
<li>本地缓存</li>
<li>分布式缓存 </li>
</ul>
</li>
<li><p>使用缓存的两点：1.数据热点不均衡，某些数据经常访问；2.缓存数据不会被经常修改*</p>
</li>
<li><p>异步：往往指消息队列MQ，即生产者消费者模式，通过消息队列来减轻服务上下游之间的直接压力，消除同步依赖，上下游服务独立，从而避免受到强业务牵连。主要作用：</p>
<ul>
<li>提高服务可用性：上游服务不会受到下有服务的影响</li>
<li>提高访问速度，用户体验：上游逻辑处理完直接返回，不需要等待</li>
<li>高并发消峰：消息队列相当于一个缓存系统，对消息具有承载能力，具有伸缩性。</li>
</ul>
</li>
<li><p>冗余/备份：为了网站的高可用，数据需要进行冷热备份</p>
<ul>
<li>冷备份：即定时进行全量备份</li>
<li>热备份：对数据操作进行监控，实时备份</li>
</ul>
</li>
<li><p>自动化：主要体现在开发流程化和运维自动化</p>
<ul>
<li>自动化测试</li>
<li>自动化部署检测</li>
<li>自动化降级</li>
<li>自动化失效恢复</li>
<li>自动化分配资源</li>
</ul>
</li>
</ul>
<p><strong>第三章：大型网站架构要素</strong></p>
<p>一个好的网站不仅仅需要考虑需求，还需要考虑一下几个要素</p>
<ul>
<li><p>性能：性能直接关系到用户体验，用户从浏览器到数据库需要得到快速的响应。这些优化包括：</p>
<ul>
<li>浏览器端的页面缓存、压缩、合理布局、减少cookie传输</li>
<li>CDN缓存+反向代理缓存，减轻服务器压力</li>
<li>应用服务器可以加本地缓存+分布式缓存</li>
<li>异步程序处理，直接返回结果</li>
<li>集群</li>
<li>代码里面加多线程、内存管理</li>
<li>数据库优化、索引优化、缓存优化、高性能nosql使用</li>
</ul>
</li>
<li><p>可用性：即防止服务器宕机，需要集群、备份处理</p>
</li>
<li><p>伸缩性：伸缩性是针对服务里是否可添加进行解释的，即随着用户数量的上升，应用服务、数据服务、缓存服务都会不断地添加，但是需要提供同等的服务功能和能力。比如缓存的一致性hash算法。</p>
</li>
<li><p>扩展性：即随着业务功能的添加，新的业务不能影响原始业务的代码模块，少侵入。主要手段：</p>
<ul>
<li>事件驱动架构：即通过消息队列进行消息通知，通过事件机制，来达到不同模块的相互交互，降低耦合性</li>
<li>分布式服务：提取出公共服务模块，新的业务直接使用公共服务模块，不影响其他模块。</li>
</ul>
</li>
<li><p>安全性：防攻击、防数据窃取架构</p>
</li>
</ul>
<p><strong>第四章：瞬时响应-网站的高性能架构</strong></p>
<ul>
<li><p>性能指标响应</p>
<ul>
<li>时间：从发出请求到返回数据的时间</li>
<li>并发数：同一时刻可以访问的用户数，一般多线程进行处理</li>
<li>吞吐量：单位时间内，能够处理请求的数量</li>
</ul>
</li>
<li><p>前端性能优化：</p>
<ul>
<li>减少http请求次数：每一个http请求都会耗用一定的资源，可以通过批量请求将资源进行压缩，比如js\css\图片等静态资源进行统一发送</li>
<li>浏览器缓存</li>
<li>资源压缩：服务器将资源进行压缩发送，浏览器进行解压</li>
<li>Css放在页面最上端，js放在最下端：一般情况下，只有下载完css，才会进行页面渲染，因而可以先下载css</li>
<li>减少cookie传输：cookie在每一次的请求和响应时都会进行传输，因此尽量不要把不必要的信息放在cookie中</li>
</ul>
</li>
<li><p>CDN加速：CDN能够缓存大部分的静态资源</p>
</li>
<li><p>反向代理：反向代理可以缓存数据、保障安全、负载均衡</p>
</li>
<li><p>应用服务器优化：分布式缓存</p>
<ul>
<li>合理使用缓存：<ul>
<li>频繁修改的数据不要使用缓存</li>
<li>没有热点的数据不适用</li>
<li>数据不一致和脏读：<ul>
<li>一个方面，大多数场景可以容许一定时间的缓存不一致</li>
<li>另一方面涉及重要信息，需要强一致，此时就需要更多的资源开销</li>
</ul>
</li>
<li>缓存可用性：</li>
<li>缓存雪崩：缓存服务器崩溃，直接打到底层数据库；此时需要进行分布式缓存，防止服务器奔溃风险</li>
<li>缓存预热：刚使用的系统，缓存并没有数据，为了防止，可以启东时就加在所有的数据或者部分数据</li>
<li>缓存穿透：由于不恰当的业务或者请求不存在的数据，导致直接打入底层数据。比较简单的方式是将null也存储起来。</li>
<li>缓存击穿：由于缓存的过期，导致数据集中打到数据库。比如某个并发大的缓存key突然不存在，导致所有的请求直接进入DB<ul>
<li>方案1：如果缓存不存在，对DB操作进行加锁，只允许一个线程操作</li>
<li>方案2：使用redis的锁机制，SETNX（set if not exists），设置一个临时短期的锁key，控制数据的访问</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>异步操作:消息队列消峰</p>
</li>
<li><p>使用集群:负载均衡</p>
</li>
<li><p>代码优化</p>
<ul>
<li>多线程<ul>
<li>CPU和IO：计算密集型操作，线程数应该尽量少，因为是单个线程工作时间长，减少线程数有助于减少切换的时间开销；IO密集型，线程调大，因为IO处理的数据大，需要更多的线程来协作</li>
<li>处理并发安全性：<ul>
<li>将对象设计为无状态：比如servlet对象，并不带有的属性变量，因而不存在数据共享</li>
<li>使用局部对象</li>
<li>使用锁</li>
</ul>
</li>
<li>资源复用：尽量减少开销大的资源的创建和销毁 <ul>
<li>两种方式：单例和对象池</li>
</ul>
</li>
<li>数据库连接池</li>
<li>线程</li>
<li>网络连接</li>
<li>复杂对象</li>
</ul>
</li>
<li>数据结构和算法</li>
<li>垃圾回收</li>
</ul>
</li>
<li><p>存储性能优化</p>
<ul>
<li>SSD和机械磁盘</li>
<li>B+树和LSM树<ul>
<li>B+树是一种专门针对机械磁盘存储原理二设计的一种N叉树；目前B+树大多是三层结构，因此只需要进行5次磁盘IO操作(三次索引查找，数据读取和数据写入各一次)</li>
<li>LSM是针对读操作多的场景而产生的，其中的M代表merge，即合并；主要理论是将内存和外存进行区分：写入时直接写入内存，由于内存操作快，此时不需要回盘，节省大量时间；读取时大部分直接读取内存就够，如果内存没有，才会读取外部磁盘，这种方式很适合热数据，即大部分数据读取都是最近昌产生的数据。合并时，将内存新的数据和外部磁盘进行合并，这个操作异步进行不占用系统资源。</li>
</ul>
</li>
<li>RAID和HDFS<ul>
<li>磁盘阵列和磁盘集群格式</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>第五章：万无一失-网站的高可用</strong></p>
<p><em>网站的可用性度量，一年时间内有多少时间是可用的，一般是99.99%，表示365*0.01%的故障率，即53分钟</em></p>
<p>高可用的应用：</p>
<ul>
<li><p>通过负载均衡，处理无状态服务的失效转移</p>
<ul>
<li>对于没有状态的服务，表示所有的服务都是对等的，就可以通过克隆进行集群处理</li>
</ul>
</li>
<li><p>有状态的session管理：保存用户信息</p>
<ul>
<li>session复制：一个服务session被修改后，需要将修改的session复制到其他的服务器</li>
<li>session绑定：即绑定用户ID，或者访问ip；这样通过哈希函数，将固定的访问者都映射到同一个服务器</li>
<li>利用cookie记录session：cookie保存在客户端，能很好地解决共享问题；但是要注意大小session服务器：独立出</li>
<li>session服务器，每次访问集群服务器时，都去session服务器获取新的session数据</li>
</ul>
</li>
<li><p>高可用的服务策略：</p>
<ul>
<li>分级管理：核心服务优先，边缘服务降级</li>
<li>超时设置：超过一定时间，就需要执行拒绝策略，比如转移给集群其他服务器或者返回失败、重试等</li>
<li>异步调用：对于不需要立即返回信息的服务，可以通过异步队列来缓存执行。比如订单完成和通知功能，通知功能可以异步缓存调用，避免占用资源</li>
<li>服务降级：网站高峰期由于资源有限，可以临时关闭边缘服务，降低资源占用，比如双十一当天的订单评价、确认收货等非核心服务<ul>
<li>拒绝服务：对低优先级的服务进行限流控制，降低并发度</li>
<li>关闭服务：关闭不重要的服务幂等性设计：同一个接口请求，有不同的原因，如刷新浏览器、重复点击、失败重试等操作，可能会重复执行，此时就需要</li>
</ul>
</li>
<li>幂等性设计，避免造成重复逻辑</li>
</ul>
</li>
<li><p>高可用的数据：数据是IT的核心资产，要保证数据的准确、保存、以及防丢失、防盗取</p>
<ul>
<li>CAP原理：Consistency、Availibility、Patition Tolerance即一致性、可用性、分区容错性<ul>
<li>一致性Consistency：即保证各个副本数据一致，同步一致</li>
<li>可靠性Availibility：要避免设备故障不能影响服务的使用，即使用服务集群</li>
<li>分区容错性Patition Tolerance：又叫可伸缩性；大型网站都是在不断扩展中的，因此必须保证可以进行扩展，比如磁盘增加，服务增加等</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><em>一般而言可伸缩性是一定的，可靠性也是必不可少的；只有一致性可以稍微降低，根据服务器等级，使用不同的成本来保证服务的一致性程度。</em></p>
<p><em>为什么只能有两个？是因为一致性的存在，即强一致。要达到强一致，肯定只能用一个机器，或者一个原子服务。如果有多个服务，数据同步肯定不能达到实时。因此有了一致性，可靠性就没法保证。</em></p>
<ul>
<li><p>数据备份：即保证可靠性</p>
<ul>
<li>冷备份：定时全量备份——类似于快照</li>
<li>热备份：操作完的同时进行复制备份——类似于追加<ul>
<li>异步热备份：多个备份依次备份，然后再异步进行数据同步。这个是主要的采用方式，一般是一主多副，主库用于写入，多个副库用于读取</li>
<li>同步热备份：应用程度同时进行并发复制，将数据同时备份到多个副本中</li>
<li>如今的很多非关系型数据库，如hbase、ES等，都是基于分布式是存储系统的，使用的是热备份方式，即自动进行多个备份；而传统的关系型数据库，如mysql，大多采用一主多副形式。</li>
</ul>
</li>
</ul>
</li>
<li><p>失效转移：服务即便失败也要快速处理或者找到另一种处理办法</p>
<ul>
<li>失效确认：控制中心需要知道应用服务是否失败<ul>
<li>心跳检测：实时发送心跳检测</li>
<li>应用程序访问失败报告：服务器访问失败，需要向控制中心发送报告；同时控制中心需要再次发送心跳检测来确认</li>
</ul>
</li>
<li>访问转移：访问失败后，需要将请求重新转移到同等的其他服务上</li>
<li>数据恢复：一个服务失败，表明数据备份少了一块，就需要重新添加新的备份。保持备份数不变</li>
</ul>
</li>
<li><p>高可用的软件质量保证</p>
<ul>
<li>网站发布：网站发布不能有间隙，不能影响原来的服务；因此网站法布时，需要保留一部分服务，缓慢过渡到新的应用版本</li>
<li>自动化测试：</li>
<li>预发布验证：测试环境和线上环境有所不同，因此需要使用预发布环境来再次测试。除了没有负载均衡，其他所有环境数据都相同，即同一台机器。</li>
<li>代码控制：主干开发，分支发布：git+svn</li>
<li>自动化发布：即严格控制一个开发周期，使用火车发布模型</li>
<li>灰度发布：即每次只上线一部分服务，然后调研；无问题后，再发布后续服务。灰度测试即：先发布一个版本，调研用户反馈，如果比较满意无问题，就可以维持，否则可以取消本次发布。比如全军出击修改的射击效果不好，重新改回去</li>
</ul>
</li>
<li><p>网站运行监控：</p>
<ul>
<li>数据采集：<ul>
<li>用户行为日志：<ul>
<li>服务端收集：比较简单，一般都有日志处理框架，但是无法获取某些具体的访问信息，比如用户的ip信息，这些是经过代理了</li>
<li>客户端收集：在前端页面嵌入js脚本收集</li>
</ul>
</li>
<li>性能监控：服务器的内存、cpu、网络等硬件要实时监控，防止故障</li>
<li>运行数据报告：运行时的缓存命中率、平均延迟、访问次数、处理任务数等后续分析用到的数据</li>
</ul>
</li>
<li>监控管理：<ul>
<li>系统报警：某些数据超标，需要信息通知</li>
<li>失效转移：</li>
<li>自动降级</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>第六章：永无止境-网站的伸缩性架构</strong></p>
<p><em>网站的伸缩性是相对于集群而言，即硬件设施的增添；而扩展性是相对于分布式而言，解耦，分布。</em></p>
<ul>
<li><p>网站架构的伸缩性设计</p>
<ul>
<li>不同功能进行物理分离设计：单一服务-数据库-缓存-静态页面<ul>
<li>纵相分离</li>
<li>横向分离</li>
</ul>
</li>
<li>单一功能通过集群分离</li>
</ul>
</li>
<li><p>应用服务的伸缩性</p>
<ul>
<li>http重定向负载均衡</li>
<li>DNS域名解析负载均衡</li>
<li>反向代理</li>
<li>IP负载均衡</li>
<li>数据库链路层负载均衡</li>
</ul>
</li>
<li><p>负载均衡算法</p>
<ul>
<li>轮训</li>
<li>加权轮训</li>
<li>随机</li>
<li>最少连接</li>
<li>源地址哈希-将同一地址哈希到同一个服务器</li>
</ul>
</li>
<li><p>分布式缓存的伸缩性</p>
</li>
<li><p>分布式缓存伸缩性的主要难点在于，当向其中增添服务器时，如何保证不会出现哈希紊乱，即对原始哈希地址最小的破坏*</p>
<ul>
<li>哈希路由算法：<ul>
<li>对服务器数量取余操作：计算简单，但是一旦加入新的服务器，之前的服务器缓存将不对应。比如3台机器，添加第四台后，之前三台机器的缓存数据都将无法命中，即非命中率75%，机器越多越严重</li>
<li>改进一致性哈希算法：先构造一个0-2^32的整数环，将服务器放在哈希环上，每次数据映射时，总是按照顺时针查找最近的换点，即对应的服务器；当进行扩容时，只需要将新的机器，随机加入其中，这样只有当前点左右机器会受到影响，其他机器都不会受影响，命中率会随着机器的增多，越来越高，直至99%。</li>
<li>缺陷：上述方法有一定缺陷，即新加入的节点，会导致哈希不均衡；改进：可以加入虚拟节点，即每个机器对应多个虚拟节点，将虚拟节点均匀分布在环中；当需要加入新的机器时，分别从每个机器上均匀分配环点，这样，每个机器的环点数还是一致的，从而避免哈希不均衡问题</li>
</ul>
</li>
</ul>
</li>
<li><p>数据库存储的伸缩性</p>
<ul>
<li>关系型数据：主从读写分离，主写从读；分库分表分页</li>
<li>NOSQL：通过一个主节点用于管理数据地址，数据节点保存数据，并将数据细分为多个分片，多备份保存。</li>
</ul>
</li>
</ul>
<p><strong>第七章：随需应变-网站的可扩展架构</strong></p>
<p>利用分布式消息队列降低耦合性事件驱动架构EDA-event driven arth</p>
<p><strong>第八章：网站的架构安全</strong></p>
<ul>
<li><p>攻击类型</p>
<ul>
<li>XSS攻击——跨站点脚本攻击cross site script<ul>
<li>即通过嵌入html脚本来模拟用户行为，进行恶意操作的攻击</li>
<li>反射性XSS：诱导用户点击脚本url，进而群发带有脚本url的链接，导致病毒的扩散</li>
<li>持久性攻击：即攻击脚本直接保存在被攻击网站服务器上，通过将攻击脚本放入数据库，当用户从数据库读取数据时，就将攻击脚本携带出来，从而达到攻击的目的</li>
<li>防范：<ul>
<li>XSS消毒：对html特定字符进行转义</li>
<li>加入httponly属性</li>
</ul>
</li>
</ul>
</li>
<li>注入攻击：<ul>
<li>sql注入，最简单的注入</li>
<li>开源软件的数据库结构泄露导致的定向攻击</li>
</ul>
</li>
<li>SARF攻击——跨站点请求伪造cross site request forgery<ul>
<li>跨站点，即类似于常见的网站授权操作，通过获取用户授权，以用户的身份访问某个站点，进行攻击操作。</li>
<li>解决方案：<ul>
<li>网站需要进行严格的用户鉴权，使用唯一性的表单token，每次请求都是唯一的token</li>
<li>验证码，依次操作需要用户输入验证码</li>
<li>Referer check：验证请求源，一般使用此方法，来防止图片倒链</li>
</ul>
</li>
</ul>
</li>
<li>其他攻击：<ul>
<li>error code：通过服务器报错信息，来收集服务器结构，从而寻找漏洞；避免异常信息直接输出到用户界面</li>
<li>HTML注释：html的注释会显示在客户端上，有助于黑客对网站进行分析，因而应该避免注释</li>
<li>文件上传：通过上传攻击脚本，然后通过正常页面访问当前脚本，来达到执行脚本攻击的目的；可以限制类型、环境独立</li>
<li>路径遍历：对于静态文件，由于不受限制，访问者可以通过路径遍历获取目录下所有的文件，导致文件泄露。采取措施：文件独立，单独使用url服务</li>
</ul>
</li>
</ul>
</li>
<li><p>信息加密和秘钥保存</p>
<ul>
<li>单向散列：不保存密码，而是用代码将输入密码加密，将密文保存在数据库；用户登录时，直接加密，进行匹配。由于这种方式只能单向进行，因而可以保护密码<ul>
<li>加盐</li>
</ul>
</li>
<li>对称加密：加密秘钥和解密秘钥都是同一把，需要严格保护秘钥；常见方式：DES算法、RC算法</li>
<li>非对称加密：通过两把秘钥来进行，秘钥都是针对服务器而言；<ul>
<li>非对称加密技术缺点是只能单向：公钥私钥都是一方提供，只能接受数据，不能发送数据。</li>
<li>客户端向服务器发送数据时，首先获取服务器的公钥，对数据加密，数据库拿到数据后，用自己的私钥解密即可。由于公钥私钥都是服务器提供，外界无从得知传输中的数据；<ul>
<li>信息安全传输：由上所知，信息传输显然需要两次非对称加密，效率都会很低。因而，大多数时候都是配合对称加密：先通过浏览器公约，获取非对称加密公钥，将客户端对称加密秘钥发送给服务器，这样，之后就可以通过对称加密技术进行数据传输</li>
<li>数字签名：一种签字效果，即唯一性，合同法律效果。服务方将合同通过自己的唯一性私钥进行加密，接收方公钥解密，这样合同生效。由于信息是不可抵赖，所以具有签名的效果</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>信息过滤和反垃圾</p>
<ul>
<li>文本匹配：字典树/trie树</li>
<li>分类算法：将文本分成各种特征标签<ul>
<li>贝叶斯</li>
</ul>
</li>
<li>黑名单：直接对地址、ip、用户名拉黑</li>
</ul>
</li>
</ul>
<p><strong>第3篇：案例解析</strong></p>
<ul>
<li>淘宝网架构演进</li>
<li>维基百科海量分布式存储系统Doris的架构分析</li>
</ul>
<p><strong>第12章 网站秒杀系统的架构分析</strong></p>
<ul>
<li>秒杀系统的技术挑战<ul>
<li>对现有系统造成挑战</li>
<li>高并发应用和数据库负载</li>
<li>网络和服务器带宽</li>
<li>直接下单</li>
</ul>
</li>
<li>应对策略<ul>
<li>秒杀系统独立部署：防止影响正常业务</li>
<li>秒杀页面静态化-将所有信息全部静态保存，不经过数据库</li>
<li>租借秒杀活动带宽-临时租用</li>
<li>动态生成随机下单页面-只有秒杀开始才能访问</li>
</ul>
</li>
<li>架构设计<ul>
<li>使用js脚本控制按钮的操作</li>
<li>直接控制秒杀用户数，达到阈值，直接返回拒绝页面</li>
</ul>
</li>
</ul>
<p><strong>第13章 故障案例分析</strong></p>
<p><em>一个好的架构师并不是技术领先，而是经验领先，而这些经验都是故障历练出来的，处理问题不难，而是遇到难的问题很难</em></p>
<ul>
<li><p>写日志引发的故障：</p>
<ul>
<li>问题：比如将日志级别设置为debug模式，由于debug模式是开发模式，会打印所有的运行情况，如果直接上线，会迅速沾满内存</li>
<li>解决：单独配置日志磁盘，防止影响服务器业务；上线时，将级别降为warn；注意第三方库的默认日志输出配置，防止多余</li>
</ul>
</li>
<li><p>高并发访问数据库</p>
<ul>
<li>问题：网站首页频繁奔溃，网站首页访问量最大，会不断请求数据库</li>
<li>解决：将数据进行缓存；页面静态化或者后台固定刷新；</li>
</ul>
</li>
<li><p>高并发情况下，锁引发的故障</p>
<ul>
<li>问题：高并发下，syn的不恰当使用可能会影响业务延迟，比如使用syn(this)时，内部调用了远程操作，占用太多的时间，同时this又是唯一锁，导致超时</li>
<li>解决：此时尽量不要加锁，考虑其他安全方案，比如消息队列</li>
</ul>
</li>
<li><p>缓存引发的故障</p>
<ul>
<li>问题：以往缓存只是为了提高性能，但是随着数据的增加，缓存也是一个重要的数据库。如果轻易撤掉缓存，当并发过大时，会直接打到数据库</li>
<li>解决：使用分布式缓存，即便撤掉部分缓存，还有其他缓存服务器使用</li>
</ul>
</li>
<li><p>应用启动不同步引发的故障</p>
<ul>
<li>问题：服务之间互相依赖，如果下游服务没有提前启动，会导致上有服务直接奔溃</li>
</ul>
</li>
<li><p>大文件存储独占磁盘</p>
<ul>
<li>问题：某一时刻，由于一个大文件的上传，导致其他小文件如图片都无法上传</li>
<li>解决：大文件使用专用存储数据库。不同的文件尽量都独立</li>
</ul>
</li>
<li><p>滥用生产环境</p>
<ul>
<li>问题：工程师为了图省时，有事为了快速解决bug，直接对生产环境进行操作。可能直接错误修改实际数据，同时也会干扰生产环境业务</li>
<li>解决：所有的开发都要依步骤进行，要在测试环境中进行测试</li>
</ul>
</li>
<li><p>不规范的开发习惯</p>
<ul>
<li>问题：开发测试时，注释一些部件，上线时忘恢复</li>
</ul>
</li>
</ul>
<p><strong>第14章 架构师的领导</strong></p>
<ul>
<li>艺术关注人而不单单是产品，注重每一个人的作用，让他们做到自己最大的能力。合理配合</li>
<li>学会教导优秀的人，而不是完全的指导。引路更重要</li>
<li>共同参与架构，考虑所有的想法并发挥其想法</li>
<li>学会妥协，回了产品而不是为了对错。求同存异，理解对方的想法<pre><code>![5e3c587cd3c355e6916189cc0003b0ad](《大型网站技术架构》读书笔记.resources/410B177E-7463-41B4-A3B5-00231158BB6F.jpg)</code></pre></li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>架构</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>一千公里</title>
    <url>/2018/10/29/%E4%B8%80%E5%8D%83%E5%85%AC%E9%87%8C/</url>
    <content><![CDATA[<blockquote>
<p>山随平野尽，江入大荒流。</p>
</blockquote>
<p>按理说，过去的两天是如此地劳累，以至于我今天应该提前下班，早早收场，大睡他一番。但是，突然之间，我总觉得需要做点什么，需要写点什么去记录两天的美好时光，需要再去回味一下两天里的情情景景。但是，突然提笔，才发现，心里想的和肚子里的墨水不在一个水平，粗鄙的词句完全无法畅快的表达我此刻的心情，更不用说是优美的文采，华丽的乐章。但是，我还是要写点什么的，就像一个人的成长一样，令人记忆犹新的往往并不是那些精彩绝伦的画面，相反确是那些尴尬无比的场景，在之后的很多年里作为回味的笑柄，作为家里人谈笑的谈资。</p>
<hr>
<p>起笔之前，我都不知道起个什么标题，“北京武汉两日游”显得太粗俗老套，“跨越千里的旅程”又太过娱乐化。稍作思忖，身为一个极简派之人，姑且标题也暂且极简吧，就定为“一千公里”。一千公里表面上指距离，其实更是时间，对于光速，它不到一秒，对于飞机，不过两三个小时，对于动车也只有五六个小时，但是，人生，总有那么些“挫折”，没钱，坐个直达就不错了，而且，有时候直达你都不一定买的上票。所以，人生之路还是很艰难，所以，现在定个小目标，好好奋斗吧，希望以后能够<em>暴富天天坐飞机</em>(不在两地跑)。</p>
<p>虽然路途有点遥远，但是遥远也带来另一番感受，其中的旅程能够让你真真切切体会到社会的差异以及地区的差异，另外加上各种阅历不同的人在其中产生的各种各样的奇异事件，偶尔会让你灵感大发。虽然很差钱，但是由于自己每天只啃一个包子，还是攒下了不少钱，所以，出发的选择还是锁定为高铁，522元软妹币，用出去的瞬间，我感觉我这一辈子的包子都被它吃光了！这样的话，以后还咋活，只能啃鸡腿度日了。但是高铁并没有我想象中的那么好，这里的好并不是指舒适度，而是，我感觉我的钱只是买来了节约的时间，却没有得到这段旅程的该有的收获，毕竟五个小时，我竟然看着旁边的“大佬”写了三个小时的ppt，还是英文的…（天呀，我有时候感觉做高铁的好像全是精英，不自觉的开始仰慕，但是环顾四周，发现还是有很多人像我一样盯着手机刷新闻，打游戏。说明，我们其实我已经融入这个群体。另外我发现，高铁打游戏并不是很卡，比普通列车强多了，这个钱花得也值-可能是错觉-o-）。与出发的顺利完全相反，返程的艰辛可能是我今生遇到的第二次（第一次我忘记是啥时候了，但是我敢保证这绝对不是第一次，毕竟还不算痛苦，我觉得我还可以再来一次-.-）。返程的票，提前一周就没有买到，还是买的中转+段尾补票（汉口-郑州，郑州-石家庄（中途补票直接坐到北京）），很不幸，不单单需要中转，两段路程全部为无座，天，真踏马舒服！估计这样下去我还能再长100mm，顺利突破180，迎娶白富美(小时候家里人说站着吃饭长得高)。还有另外一件极好的事是，之前买的马扎还可以继续用！真担心只用一次，那就太浪费了。</p>
<hr>
<p>返程虽然不太顺利，但是整体感觉还是蛮好的。因为，在这一路途上，我发现了很多的技巧，可以在将来继续使用。第一趟火车是从汉口出发前往郑州，可能是因为之前玩的太过亢奋，加上出发前没有午睡，导致到了站口，就掐不住了，此时的我未出发就先累倒，我已经开始为我的身体担忧担忧，我不知道我还能不能回到北京，还能不能吸上雾霾，还能不能再见城市的浮力唐璜，但是我还是强忍着喝了一罐椰奶，走上了“货”车。</p>
<p>对于不常坐火车，以及经常买不到票的同志，今天博客中也要分享一些我的经验：</p>
<ol>
<li>首先，所买的火车票如果没有，但是实在要回家，可以买当前列车的短程，或提前买几站，然后上车补票。</li>
<li>另外，即便是无座，早点上车，往卧铺方向走，找补票的列车员补票，很多时候都可以直接补到卧票或者坐票，可能很多人在这个时候会退票（具体原因不明，我当时上车无座，但是前前后后给十多个人补了卧票，排到我却没有了。但是我会守株待兔，不过多时又多出两个~），注意出门在外最好备两三百块现金，补票可能只收现金。</li>
<li>多余的：花10块买个板凳！我见到太多的人，买的长途无座，却不买板凳，等着上车补卧票。最后累得快要瘫痪。</li>
</ol>
<p>最后晒一张我的车票：</p>
<hr>
<p>做菜：<br>本打算回去做点啥，但是事情往往和你想的不一样。想起一个笑话：说一个贪婪之人突然得到一个神灯，神灯可以满足他一个愿望；于是此人便说：能否给我一点钱。上帝：一点是多少。此人回：一个亿。上帝沉思片刻觉得也就一个小目标的事，看了看手上的复古画表回：稍等我一会。此人问：一会是多久？上帝转身回眸：爱你的一万年。就像你所谓的一点只是一个亿，而上帝的一点却是一万年，一点时间一点钱。都是一点却含义不同。我以为我回去能做点宏伟的事情，却发现回去就只烧了两个菜：一个瘦肉茄子，一个韭菜鸡蛋饭。而正是这两道菜才终于让我认清了自我，让我知道其实我也能做个菜，做菜也能这么难吃，能把老抽当做白水，能把食盐当砂糖，却不知水多了能加热，糖多了只是甜。但是理论上来说，做菜步骤还是很完美的，出锅前的99%时间都是完美的，有时候色相甚至超过网上大厨，但是直到最后1%，我才体会到，原来做菜也是有二八定律的，往往最后的20%才是决定胜败的关键！</p>
<p>由于手机无电附图明日再传：</p>
<hr>
<p>还有啥事可写？我先想想。。。</p>
<p>好像没啥时候，总结下心情吧，记录下每时每刻的自己。<br>回望这两天，不知道我的选择是否对错，也不知道之后的发展能够向好，更不知道黑暗的世界到底是何样子，我不懂，对面也不懂，可能对面很懂，但是我却不懂，也可能我已经懂了，只是有点飘飘然如遗世独立，不知能否羽化而登仙。前途依旧动荡，心里依旧起伏，晚来的迟早会来，多余的所思，对于事态的演化是毫无作用的，顶多，也就减缓前进步伐，或是给无知的心脏多添几粒脂肪。</p>
<p><em>革命尚未成功，同志想要努力</em></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>北京</tag>
        <tag>武汉</tag>
        <tag>情感</tag>
      </tags>
  </entry>
  <entry>
    <title>tensorflow-seq2seq知识点梳理</title>
    <url>/2018/09/27/tensorflow-seq2seq%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>接触python已有两年之久，零散地使用tensorflow也将近一年。但是是指今日，如果让我重新建立一个项目，我仍是无能为力。有时候，我会有一种感觉，python这种语言就像是一个无底洞，你永远不知道它在不同的场景中有多少不同的变化，更可怕的是，你无法知晓其中的错误，它是如此的“灵活”，以至于很多的检查都需要依赖程序员自己，而这些错误有时候是很难检查的，特别是对于初学者而言。但是，这又是一个很容易入门的语言，因为，不管你是什么专业的人，你都可以用10行以内的代码做一些简单地事情，而不需要太多的系统知识或者规范。</p>
</blockquote>
<blockquote>
<p>由于python知识点太过散乱，往往是学了后面忘了前面，所以还是要写一些总结加深印象，由于系统的总结可能太过于漫无目的，而且时间成本过高，所以，暂且以一个小项目为首，将其中的流程知识点串起来</p>
</blockquote>
<ol>
<li><p>项目背景<br>项目为一个seq2seq架构，seq2seq架构是一种序列到序列的预测模型，即通过输入和输出都是序列。通常是用在自然语言处理中，比如翻译系统，输入为一维中文，输出为一维英文。改进版也使用在音频处理和图像处理上（这里面需要将音频特征、图像转化为序列形式）。</p>
<blockquote>
<p>输入为一个单词，输出为此单词的字母顺序排列；比如输入为hello，输出则为ehllo</p>
</blockquote>
</li>
<li><p>占位变量tf.placeholder</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">inputs = tf.placeholder(tf.int32, [<span class="literal">None</span>, <span class="literal">None</span>], name=<span class="string">'inputs'</span>)</span><br></pre></td></tr></table></figure>
<p>tensorflow中，由于我们是首先建立训练模型，后定义真实的输入数据。所有需要占位符来表示需要输入的未知变量，解析如下：<br>Args:<br>    dtype: 数据类型-The type of elements in the tensor to be fed.<br>    shape: 数据维度，一般为[批大小，序列长度,]-The shape of the tensor to be fed (optional). If the shape is not<br>      specified, you can feed a tensor of any shape.<br>    name: 数据名字-用于在tensorboard显示标注-A name for the operation (optional).</p>
<p> Returns:<br>    A <code>Tensor</code> that may be used as a handle for feeding a value, but not<br>    evaluated directly.</p>
<ol start="3">
<li>tf.contrib.layers.embed_sequence(ids, vocab_size,  embed_dim)<br>词嵌入，一种one-hot编码的改进版，即将单词映射成数字表示，然后将数字转换为嵌入矩阵向量。</li>
</ol>
<p>Args:<br>    ids: 形状为[batch_size, doc_length]的int32或int64张量，也就是经过预处理的输入数据。<br>    vocab_size: 输入数据的总词汇量，指的是总共有多少类词汇，不是总个数<br>    embed_dim：想要得到的嵌入矩阵的维度(自主设定，表示嵌入广度)</p>
<p> Returns: [batch_size, doc_length, embed_dim]<br>     Tensor of [batch_size, doc_length, embed_dim] with embedded sequences.</p>
<ol start="4">
<li>tf.nn.dynamic_rnn</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">encoder_output, encoder_state = tf.nn.dynamic_rnn(cell, encoder_embed_input,</span><br><span class="line">                                                      sequence_length=source_sequence_length, 			dtype=tf.float32)</span><br></pre></td></tr></table></figure>
<p>这里的dynamic_rnn即构造循环神经网络，但是相对于传统的RNN有一定的改进，对于一般的RNN，对于输入序列，我们是强制性统一到最大长度，对于短于最大长度的进行补齐，但是这样会带来一个计算问题，所以这里使用了dynamic，动态RNN，它增加了一sequence_length输入参数-序列长度，这样，计算时只取当前长度的数值进行计算，输出时只保留当前长度的输出<br>参考：<a href="https://blog.csdn.net/u010223750/article/details/71079036" target="_blank" rel="noopener">https://blog.csdn.net/u010223750/article/details/71079036</a></p>
<ol start="5">
<li>tf.strided_slice</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ending = tf.strided_slice(data, [<span class="number">0</span>, <span class="number">0</span>], [batch_size, <span class="number">-1</span>], [<span class="number">1</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p> Args:<br>    input_: A <code>Tensor</code>.<br>    begin: An <code>int32</code> or <code>int64</code> <code>Tensor</code>.<br>    end: An <code>int32</code> or <code>int64</code> <code>Tensor</code>.<br>    strides: An <code>int32</code> or <code>int64</code> <code>Tensor</code>.</p>
<p>对数据矩阵进行切片，strides一般为全1值，这里的意思相当于切除最后一个字母。<br><img src="http://osiy4s0ad.bkt.clouddn.com/soundblog/1538035875521.png" alt="enter description here"></p>
<ol start="6">
<li>tf.nn.embedding_lookup<br>输入张量映射</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 得到映射嵌入[128,?,15]/[128,length,15] = lookup([30,15],[128,legth])</span><br><span class="line">decoder_embed_input = tf.nn.embedding_lookup(decoder_embeddings, decoder_input)</span><br></pre></td></tr></table></figure>
<p>第一个参数为映射字典，第二个参数为映射索引</p>
<ol start="7">
<li><p>tf.identity(input, name=None)<br>tf.identity就是为了在计算图获取这个值而创建的虚拟节点，只是用来获取中间值</p>
</li>
<li><p>tf.contrib.seq2seq.sequence_loss<br>Args:<br> logits: 训练输出的概率矩阵-A Tensor of shape [batch_size, sequence_length, num_decoder_symbols] and dtype float. The logits correspond to the prediction across all classes at each timestep.<br> targets: 真是输出值-A Tensor of shape [batch_size, sequence_length] and dtype int. The target represents the true class at each timestep.<br>用于计算加权交叉熵损失，<a href="https://blog.csdn.net/chaipp0607/article/details/73392175" target="_blank" rel="noopener">加权交叉熵参考</a></p>
</li>
<li><p>梯度计算和网络更新</p>
<ul>
<li>梯度计算：gradients = optimizer.compute_gradients(cost)</li>
<li>网络更新：train_op = optimizer.apply_gradients(capped_gradients)<br>  将梯度应用在变量上，返回此操作。即：使用该梯度进行权重更新</li>
</ul>
</li>
<li><p>tf.clip_by_value(grad, -5., 5.）<br>数据截断，这里主要为了梯度裁剪：约束梯度值，防止梯度爆炸/跨度过大。是梯度范围限制在-5~5</p>
</li>
<li><p>sess.run()<br>Args:<br>  fetches: 元组：一些用于计算结果的张量，用于去除计算结果tensor （比如我们要求姐y=w*x中的w，这里的fetches相当于y）<br>  feed_dict: 字典：输入变量占位符 （这里的feed_dict相当于x）</p>
</li>
</ol>
]]></content>
      <categories>
        <category>ML/DL</category>
      </categories>
      <tags>
        <tag>端到端</tag>
        <tag>神经网络</tag>
        <tag>seq2seq</tag>
      </tags>
  </entry>
  <entry>
    <title>见多识广——再谈见识</title>
    <url>/2018/09/19/%E8%A7%81%E5%A4%9A%E8%AF%86%E5%B9%BF%E2%80%94%E2%80%94%E5%86%8D%E8%B0%88%E8%A7%81%E8%AF%86/</url>
    <content><![CDATA[<blockquote>
<p>一个人的一生时间极其短暂，如果仅仅凭借单纯的努力，即便劳苦一生，你可能连上一阶级的起跑点都达不到。有时候，如果没有一点见识，你做的许多选择都是错的，盲目的努力都是无用之功。</p>
</blockquote>
<p>最初看到这篇文章，是在一个公众号里面提到的，当时的感触之深，让我在半天之后就买了这本书，我向来不是一个特别喜欢读书的人，但是如果书的语言对口，再加上我感受到了真真切切的受益时，我就会无视腰包之空瘪。</p>
<p>书的内容核心其实只有一个，即见识。但是书的篇幅却有很多，实际上而言，很多篇幅是不需要存在的，但是这些篇幅的存在却恰恰是为了说明，见识的重要性。见识不仅仅是自己的人生阅历，也是别人的人生阅历，这也是学习真正的作用。你需要在最短的时间内积累前人的经验，而将其用在之后的经验之中。但是，经验的得来并不容易，读书其实是最容易的途径，但即便是这，超过80%的人都做不好，更不要提很多稀缺的资源，如父母亲戚的指导、朋友圈的影响等等。</p>
<p>由于我对本书只是通读一次，所以并不太熟，暂且按着类目来抒发自己的感受</p>
<hr>
<p>“命和运决定人的一生”——这是文章的开头语，基本上总结了一个人的一生，即：大多数人即便很努力也基本上不会有太大的改变，相反，如果规规矩矩，也不会差到哪去。即一个人的出生已经决定边界的返回，就像古希腊的城邦，很多人即便再多努力，也不会走出城邦的范围，因为当前的视野和周围的环境，已经限制了你，没人告诉你通往外界的道路，因为他们自个也不知道，他以为世界就这么大。但是，这句话本身也需要排除少数例外。</p>
<p>“自私”很重要，这是我对第一章提炼的观点。当然，这里的自私和平常所说的自私并不一致，但是也有相似之处。我所谓的自私，即一切以自我利益为中心，但是同时不伤害到他人的利益。。初看这句话，很多人些许会感到疑惑，觉得很多时候双方的利益一定是对立的。确实，这种情况也有，但是，如果这种对立的情况发生，我想完全有另一种方式来解决，比如，都放弃自己的利益，这样完全可行，毕竟很多利益是可以完全放弃的。（这里的思想类似于一个贪心算法，即为了全局的最大利益，最好的方法就是每个人是尽量得到自己的最大利益，那么，整体的利益即便不是最大值，也会接近最大值）<br>中国人向来把“大公无私”、“舍己为人”等作为自己的优秀精神，但是很多时候后这种无私，这种舍己，却导致了更加残酷的结果。多少人成年人为了救人自己舍命，却丢下一家老小；多少人为了减轻亲人负担，放弃了向上的机会，而这些机会将会在不远的未来给他们带来重大的改变，当前的辛苦也将结束。</p>
<p>见识的重要性。这几年，时常有个话题被提起，就是那些当年的高考状元，最后都销声匿迹了，很少有最初伟大成就的人。这导致很多人开始对我们的教育产生怀疑。但是，成功的前提是有很多因素决定的，很多时候，智力只起到一个基础作用，而那些真正成功的人，往往是把握时代节奏的人，而这些往往取决于见识。但是，这也并不是说，那些状元一无是处，既然能考上状元，其见识、眼界和思维方式，也不是一般人所能匹敌的，而这些人，大多数也活跃在社会的高层，虽然不是最高层,也够很多人“望其项背”的了。</p>
<p>以上写于2018.8.30，由于觉得言语太过繁琐，并未在写。今日，闲暇无事，又有了新的体会，暂且补充一二，发表了，以免以后再看到，心烦。</p>
<p>上周末，和本科舍友一起闲聊了一下，他所在学校正在北邮，所以我们就按心索路，溜到了旁侧的北师大，恰巧最近开学，当时学校也正在进行“百团大战”的招新，但与我们本科时遍布技术和行为艺术所不同，这里样板好像更多，琴棋书画自不必说，从地理、生理、心理、伦理到各种音乐舞蹈，但这里的音乐舞蹈又和我们所不同，他并不是单单是吉他，更多的是古琴、笛子还有二胡，如此，我更想到之前看台湾地区“领导人”马英九的一个娱乐活动，从言语中无不透露出一种儒生气质，一种极深文化修养，那种修养不仅仅是口头上的谈吐，更是一种言语中表现出的逻辑思维，这种逻辑思维，未有一点见识或者思想阅历是不能体味的。</p>
<p>因此，作为理科生，更有甚者作为一个IT届认识，有时候，我们很可悲，我们受限于一个理论的世界，而对外界的艺术气息一无所知；我们受限于我们自己的圈子，常常把IT行业的春天作为自己的春天，却不知很多领域四季如春；慢慢的我体会到一句话：如果你对别人的世界所致甚少，而他却却对你的世界了如指掌，那么你永远都可能是错的。所以，阅历很重要，如果你只是一个单纯的猿猴，一生沉迷在自己的数据结构里，那你永远都玩不转人生更多的算法，况且很多人连基本的数据结构都一无所知。</p>
<p>一个人的一生总是在经历后才知道错过了什么，而这之前往往不屑于顾。了解的越多，见识越大，你才会知道其中的对错。</p>
<hr>
<p><em>科学技术是第一生产力，但是生产仅仅是人一生中很小的一部分</em></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>成长</tag>
        <tag>眼界</tag>
        <tag>见识</tag>
        <tag>运气</tag>
        <tag>努力</tag>
      </tags>
  </entry>
  <entry>
    <title>电影感悟-豆瓣TOP3</title>
    <url>/2018/08/20/%E7%94%B5%E5%BD%B1%E6%84%9F%E6%82%9F-%E8%B1%86%E7%93%A3TOP3/</url>
    <content><![CDATA[<blockquote>
<p>物质基础决定上层建筑。而是多年的时间里，我慢慢认识到这句话的内在含义，也慢慢开始懂得，一个人的价值不仅仅是由其本身创造，还附带他所有的一起资源，即便是家庭背景、社会阅历、周边朋友，都是其价值的体现，所以，有时候，这个社会很多不公平其实是公平的，因为每个人都会不同，别人有的你没有，你有的别人也会没有，完全靠之后的努力，是否可以弥补。就像别人有背景，你没有，你有才华智力，别人可能第一点。如果找女朋友，别人并不比你高一等级，你也不要抱怨别人比你有钱，因为这两个分属不同的领域，都是你的价值体现，如果说，你的这个价值显得低了一些，只能说对方侧重点不同，或者别人在乎的重点不同。而价值本身并没有高低之分，也不存在公不公平</p>
</blockquote>
<hr>
<blockquote>
<p>从农村到硕士，二十多年的时间里，我像一滴水，从一滴汇入小溪，然后汇入小河、大河、小江、大江、最后进入长江，涌入大海，其中的经历，非常平淡，但是慢慢发现，很多一起的小伙伴都停止了下来。而其中的性格养成也变了，有时候我会发现，国家好的物质生活条件好像全都是为了城里人而培养的，从小学全部都是农村人；到了镇里，开始有了一部分城里人，但是也还是少数；初中，城里人开始在优等班占据过半席位；到了市里，班上城市人开始占据重要地位，但受到分数决定论的影响，这是席位并不是很多，因为很多城里人在分数上是拼不过农村人的，但是他们很多人都很有才艺，而这些高考并不占比重，有时候感觉高考对他们简直“太不公平”；进一步，进入了大学，一切都变了，大学唯才就有出头之日，农村人在其中开始寥寥无几，即便有部分农村人能够依靠自己的强大学识占据一定影响，但是很多的活跃确实由城里人创造，直到这个时候，我才发现，我的缺点众多，只会学习，琴棋书画一窍不通，不仅仅如此，对于大部分农村人而言，极低的眼界使得他们处处碰壁，这更加剧了他们的自卑、犯错。眼界是个很重要的东西，这种东西，需要长时间的教导培养，而身处乡下，很多父母都不会懂的这些，一个简单的例子，很多人会热衷于去兼职，去赚钱，但是，很多人仅仅是为了赚钱而已，如果只为了赚钱，读大学又是为了什么。有时候，我发现，农村人之所以越来越落后于城里人，在于一个根本原因，这些人，很多都连基本的价值都判断不了，他不知道取舍，不知道选择，不知道思考，不知道如何什么东西该做，什么东西不该做，那些是正事，哪些只是在浪费时间。</p>
</blockquote>
<hr>
<blockquote>
<p>因此，我希望从现在开始，不仅仅练习我的表达能力，也希望能够培养自己的阅历，培养自己的知识，培养自己的事物认知。对于我们，获得这些最短的途径就是书籍、电影、文化娱乐、等等。今天，先从电影开始。</p>
</blockquote>
<p>大学读了很多书，豆瓣电影大部分也都刷完了，但是很多东西如果不去总结，就认识不到其中的内涵，所以，暂且将其记录，获取能再次汲取新的东西</p>
<p>《肖生克的救赎》，主角讲述银行家安迪，被误判坐牢IDE，最后通过努力获取自由的故事。在谈论此片之前，我想先说下我的电影观。首先，任何一部电影，虽然其中的故事，大部分人都不会接触到，倒是，其中的很多道理确是大众性的，值得每个人去品位。看过本片，或者打开百科说明，都能知道本电影的主旨在讲自由，但是，今天我并不想讲自由，因为，自由这东西太难解释了，在不同的社会环境，不同的阶级条件下，对于不同的人，自由的体现也是不同的，基本上是很难去给一个和你不同频道的人去解释，有时候，反而会带了彼此的痛苦，戳伤历史的疤痕。与此相反，我想探讨一个积极的问题，即人的全才，全方位发展的人才。<br>人无完人，这是从小就知道的道理，但是对于一个向上发展的人来说，我们的目标确实是做一个完人，当然，今天我说的完人也并不是德智体美全面发展的“全人”，只是指那些可以为了实现一个目标，而去清除道路上的所有缺陷的人，就比如电影中的安迪。为了逃跑，他能够想出一切办法，他能够将其之前的所学应用到其他领域，来助其成功逃离。有时候，我会特别崇拜这种人，特别是在走过人生二十多年后的今天，身边的变化“触目惊心”，让我觉得那些生存在金字塔上方的人士，那些占国家2%的人群，其实是相当厉害的，而不仅仅是智商上的聪明而已。他们能在生活的各个领域达到顶峰，即便是再某一方面落后别人很多，也会通过在其他地方的优势弥补上来，如果理解了这一点，也就不难理解，为什么当今社会寒门再难出贵子。这其实是社会的必然，即便是出生于寒门的我，在今后的生活中我也不会过多的支持寒门，说实话，相反我可能会更支持那些生活条件好的，因为，出于我个人的理解和我的利益，我深知寒门所受到的限制，不仅仅是物质上，更是思维上，要知道，物质很容易改变提高，但是思维见识是很难在短期内得到提高的。就如同电影中的安迪，他的出生很大概率（概率）上不会出生于寒门，因为在其相对短的人生中，如果没有在前20年或者30年里积累大量的生活经验和知识，将很难应付之后的很多事，他不可能懂得这么多的法律，也不会了解很多的书籍，虽然这种事对于寒门并不难，但是很多潜在的知识，寒门子弟是很难体会到的，即便是简单地人事处理上，都可能没他那样处理细微。<br>全方位，这个词在中小学的教育中就已经提到过，但是很少人真正的实施了，或者根本没有实施的基础，而能够实施的都是那些城里的孩子。很多时候，回过头，我会发现，在上大学之前，很多时候都是凭借成绩来定胜负，但是到了大学，我突然发现，那些除了成绩啥也没有的，大多数时候都会没落，当然也有少数真的很努力拼搏的，但是对于大多数人而言，是受不了自卑带来的打击的（我说的并不仅仅我自己-.-）。之所以导致这个结果，根本在于一个人的教育，教育不仅仅只有成绩一个指标，它还应该包括艺术细胞的培养，文学细胞的形成，见识和思维的拓展，无数生活经验的积累（不是只有经历才是经验，读书就是获取经验最快捷的方式）。如果能完完全全做到这些，其实在生活中就是另一个安迪，将会游刃有余。</p>
<p>《霸王别姬》，这个电影时间跨度特别大，类似的影片还有《活着》，这种电影千万不要将其内涵固定在一个剧情点，而是要将其展开在历史的长河中，其实它就是一个人生的经历，每个人都可能经历的人生。即任何人的生活很大概率上都不会一帆风顺。<br>我虽然不熟悉历史，但是对于历史上的朝代战乱多少还是有一些了解，纵观中华三千多年的历史，能够保持在100年以内不出现动乱的很少很少，也就是说，这么长远的年代，没有多少人真正能够一帆风顺，这还不包括其他各种自然灾害。<br>所以，人生很长，如果稍不注意就会有你的好受；有时候即便注意，你也防不胜防。影片的年代历史基本上也和《活着》类似，从民国时的军阀动乱到建国后的文革时期，其中发生的各种惨案，大多数人都避免不了，这就相当于天灾一样吧，一段时间一个轮回，逃不脱也走不掉。所以有时候在想，即便今天人们的生活很舒适，但是细想一看，我们可能和唐朝的贞观之治执念差不多，以相对均方误差来看，我们也是很看尽近些年的幸福指数最好的时候。</p>
<p>《这个杀手不太冷》，这个电影我很喜欢，喜欢那个大叔，因为我发觉我有时候就是这种大叔的性格，但是我并没有大叔这种能力–。虽然本片是个讲述杀手的电影，但是有时候，我将其归为一种爱情或者生活的剧情。因为我始终觉得杀手也是一种职业，职业在我这里不存在好坏，只存在你是否触犯了法律。（可能有人对这句话有点懵逼，或者觉得我是个傻瓜。如果你是认真想一下我们的法律，或者法律的宗旨，就会明白，法律是为了使得所有人的利益都不受到侵害，如果被侵害了就要拿出一定的代价去赔偿），所以，有时候杀手为了保护更多的人或者为利益最大化的多数人（这里的利益不是简单地加减，比如一个人要干掉你全家，这种概率的发生已经很大了，特别是黑帮生活，那你就可以以死相拼）。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>人生</tag>
        <tag>成长</tag>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title>学期总结-2018年上</title>
    <url>/2018/07/22/%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93-2018%E5%B9%B4%E4%B8%8A/</url>
    <content><![CDATA[<blockquote>
<p>从现在开始，我需要养成一个写作的好习惯，之所以培养这个习惯，是因为：我开始发现我的一个重大缺陷——语言表达能力的欠缺。这种能力，在一般生活中并不会有太大的作用，而且很多时候，大部分人都体会不到其所带来的“破坏”，这种破坏，会让你的交际陷入阻塞，职场陷入瓶颈，生活面临窘境。</p>
</blockquote>
<p>我不太会写总结，每次写给导师的月报也都是在最后的几天草草完事。而且有时候，总结总得去找些有趣的、或者有意义的事，来丰富其中的内容，而对于宅男来说，这种事基本上是很难找到的。所幸，今年与往年有所不同，今年父母大丰收，环卫“地球”事业再创记录，而本人事业之“外”也达到了新的高峰，所以，也算值得庆贺。</p>
<p>我是个喜欢做规划的人，也是个喜欢做选择的人，所以，整个学期都是按照之前的规划，多多少少的按部就班完成，但是还是存在大量逾期、欠款。</p>
<p>学期开始，我就给自己制定了“三步走”的发展规划，即研究生语音分离方向只是稍微带一点，并不会倾注太多的“心血”，另一边我会集中力量去为了工作而学习，去学习自己觉得应该学习的东西，或者说是为了自己的前途、兴趣。我是个喜欢思考未来，并且会不断根据时势来进行选择的人，我不想去做未来行业的炮灰，对于我们这些没有深厚根基的人来说，失败对于我们来说只有一次，过后就没有再次尝试的机会。马某曾经说过，“光脚的不怕穿鞋的”，但是对我而言，我可不想在奋斗大半身之后还是个光脚的，而别人不光穿上了鞋，还穿上了阿迪达斯、耐克什么的。</p>
<p>所以，我另外一个目标就是学习大数据、或者数据分析方向，之所以选择这个方向，因为我有java相关的很多基础（数据库-机器学习），我希望在保有javaweb知识的基础上，稍微向着大数据数据分析方向发展，这些也不算是大的转行，而且也至少有一个保底的后台工作，进退都是可行的。所以，目前而言，我的研究生方向大概就是：语音分离、Java后台、大数据分析。而这三个都在这一学期中开始有了点滴前进。</p>
<p>语音分离：这是个很火的方向，相对于人工智能其他的方向，如图像，国内做的人还是“相对”少的，应该不会出现人才供大于求的状况（中国人太多了，一年时间，你还没反应过来，这个行业就已经差不多饱和了，后进来的就只能做一些数据标记的打杂工作）。但是令我真正担心的是这个方向本身的问题。对于方向本身的前景，我持怀疑态度，对于方向难度，研究生是否能够胜任，我也持怀疑态度，即便是对于目前语音方面做得最好的科大讯飞，他们的盈利情况，是否很大，我持大大的怀疑态度（一个靠吹气球膨胀的公司）。相对于图像而言，语音转文本的难度应该算是难很多吧，其中可能不仅仅涉及语音还要设计NLP方面的知识，而这些知识，即便对于一个博士生都是很难在学业期间完成的。另外，其中的市场到底有多大，难道只是个语音输入法？智能家居？也不算是，用处倒也是很广，但是目前的算法效果其实已经达到一定的顶峰。有时候，我也在想，毕业找工作也可以利用在深度学习领域的经验，向着其他AI行业发展，也是个不错的选择，但是，我对此行业太悲观了。这倒不是我根本不了解此行业，只因我看到太多的炮灰研究生博士生，他们利用无比黄金的三年亦或五年，研究的东西都是只停留在论文价值上，没有丝毫的实际价值，最后的工作也大多数与相关领域无关，即便有关，最后这很小的部分，中的大多数也是在其中打着酱油。（相关领域恐怕只有国内的top7能够做点实事）</p>
<p>AI方向确实做出很多成果，但是只限于少数的领域中的少数的场景，而且一定程度上而言，很多都不算是真正意义上的AI，只能算是数据分析或者传统的统计学领域。</p>
<p>后台开发：作为本科找工作的方向，这个方向的“从业”时间应该算是很多了，但是自身的问题也很大，对于自己的知识，最初学习java应该是在14、15年就开始了，但是在这大概三四年的时间里，我却并没有太大的进步，和毕业三年的人相比，我在800里开外。因此这方面还要再穿透点许多其他的知识，以巩固其核心地位。但是我也遇到了一个很大的问题，我总是不能够很仔细的看书，亦或是无法将书本的知识记忆下来，总是在一遍又一遍之后才能达到潜移默化的程度，导致花费了太多的时间做了太多的重复性劳作，而且，有时候感觉并无益处。</p>
<p>大数据分析：我记得我当时选专业时，准备报考经济方面的专业，为此我还买了本《经济学原理》。虽然那时并不是很懂这一行，但是我总是感觉我对金融数据很感兴趣，特别是数学。因此，在上了研之后，偶尔也会处理一些数据问题，开始慢慢发现，数据中的金币价值远大于其他行业的价值，而数据的价值在没有发觉之前是没法显现的。</p>
<p>下学期开始就要正式进入语音合成的领域了，困难倒还是有，但是最大的困难并不在于其理论有多复杂，而在于，我对这方向前景的担忧。有时候，如果你不做你的选择，你就会变成别人的棋子，一旦失败，对别人而言只是浪费了一个棋子，对你而言，可能是今后一生的前景。我需要选择那个方差最小的方向。</p>
<p><strong><em>多个方向多条路，少个方向，不用走岔路</em></strong></p>
]]></content>
      <categories>
        <category>时光回收</category>
      </categories>
      <tags>
        <tag>2018</tag>
        <tag>学习</tag>
        <tag>规划</tag>
      </tags>
  </entry>
  <entry>
    <title>图算法-Prim、Kruskal、Dijkstra、Floyd、Bellman</title>
    <url>/2018/04/30/%E5%9B%BE%E7%AE%97%E6%B3%95-Prim%E3%80%81Kruskal%E3%80%81Dijkstra%E3%80%81Floyd%E3%80%81Bellman/</url>
    <content><![CDATA[<blockquote>
<p>现实生活中，我们常常遇到一些涉及到图的问题；比如一个视频网站如何分配网络服务器，才能使得资源成本最小化；几个城市之间要修路，如何规划才能使得成本最小。另外现在是五一，有几个城市路线规划，在考虑路费时间等因素条件下，如何规划旅游路线。这些的种种问题，都可以化为图规划问题。前两个即最小生成树问题，后面一个即最短路径问题。</p>
</blockquote>
<ul>
<li>最小生成树<br>最小生成树，即对于一个加权图，如何规划路线，使得图中每个节点都能够连通，且权重成本最小（没有环型结构）</li>
</ul>
<p>典型算法：Prim和Kruskal</p>
<ul>
<li>Prim算法，请参照《算法4》p399图例<blockquote>
<p>每次对已访问的节点所连接的外部边进行排序，找到最短的边作为下一个边，进行连接。（重点是已访问）<br><img src="http://osiy4s0ad.bkt.clouddn.com/soundblog/1525079110741.jpg" alt="prim"><br><img src="http://osiy4s0ad.bkt.clouddn.com/soundblog/1525094329301.jpg" alt="enter description here"></p>
</blockquote>
</li>
<li>Kruskal<blockquote>
<p>与Prim算法稍微有点区别。Kruskal算法首先将所有的权重边进行排序，然后对排序的遍历连接，直到所有的边都简历连接关系。（所有的边，不仅仅是已访问）<br><img src="http://osiy4s0ad.bkt.clouddn.com/soundblog/1525079241245.jpg" alt="kuuskal"></p>
</blockquote>
</li>
</ul>
<ul>
<li>最短路径问题<br>对于一个加权图，对于同种的节点A和B，规划一个路线，使得从A到B的路线最短，有时候，这里的成本还会考虑其他因素，都作为权重计算。</li>
</ul>
<p>典型算法;BFS,DFS(广度优先搜索和深度优先搜索)；Dijkstra、拓扑排序、bellman、floyd、A*算法</p>
<ul>
<li><p>Dijkstra</p>
<blockquote>
<p>Dijkstra思想类似于A*算法：graph[src][d]=graph[src][v] + graph[v][d]；其中src为起点，V为已访问节点，d为待访问节点（即相邻的节点）<br><img src="http://osiy4s0ad.bkt.clouddn.com/soundblog/1525093647689.jpg" alt="Dijkstra"></p>
</blockquote>
</li>
<li><p>Floyd</p>
<blockquote>
<p>Floyd思想类似化学催化剂原理，即Dis(i,k) + Dis(k,j) &lt; Dis(i,j)；A直接生成C成本需要100分钟，但是A生成B再生成C总成本：A到B加上B到C可能只有10+20=30分钟，所以，三次遍历整个路径，将所以可以使用催化剂缩短的路径更改，并保存最短路径队列<br><img src="http://osiy4s0ad.bkt.clouddn.com/soundblog/1525094099021.jpg" alt="Floyd"></p>
</blockquote>
</li>
<li><p>Ford</p>
<blockquote>
<p>Bellman-Ford算法可以非常好的解决带有负权的最短路径问题，什么是负权？如果两个顶点之间的距离为正数，那这个距离成为正权。反之，如果一个顶点到一个顶点的距离为负数，那这个距离就称为负权。Bellman-Ford和Dijkstra 相似，都是采用‘松弛’的方法来寻找最短的距离(为细看，解析保留)</p>
</blockquote>
</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">def prim(graph, root):</span><br><span class="line">    assert type(graph) == dict</span><br><span class="line">    # 待访问节点</span><br><span class="line">    nodes = list(graph.keys())</span><br><span class="line">    nodes.remove(root)</span><br><span class="line">    # 已访问节点</span><br><span class="line">    visited = [root]</span><br><span class="line">    path = []</span><br><span class="line">    next = None</span><br><span class="line">    while nodes:</span><br><span class="line">        # 找出最小距离</span><br><span class="line">        distance = <span class="attribute">float</span>(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> visited:</span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> graph[s]:</span><br><span class="line">                # 如果节点已经被访问或者是自身节点，则跳过，</span><br><span class="line">                <span class="keyword">if</span> d <span class="keyword">in</span> visited or s == d:</span><br><span class="line">                    continue</span><br><span class="line">                # 找距离最小的点</span><br><span class="line">                <span class="keyword">if</span> graph[s][d] &lt; distance:</span><br><span class="line">                    distance = graph[s][d]</span><br><span class="line">                    # 将此边加入路径</span><br><span class="line">                    pre = s</span><br><span class="line">                    next = d</span><br><span class="line">        path.append((pre, next))</span><br><span class="line">        visited.append(next)</span><br><span class="line">        nodes.remove(next)</span><br><span class="line"></span><br><span class="line">    return path</span><br><span class="line"></span><br><span class="line">def kruskal(graph):</span><br><span class="line">    assert type(graph)==dict</span><br><span class="line">    nodes = graph.keys()</span><br><span class="line">    # 不同于prim，这里所有的进行排序</span><br><span class="line">    visited = set()</span><br><span class="line">    path = []</span><br><span class="line">    next = None</span><br><span class="line"></span><br><span class="line">    # 感觉这个效率比较低</span><br><span class="line">    while len(visited) &lt; len(nodes):</span><br><span class="line">        distance = <span class="attribute">float</span>(<span class="string">'inf'</span>)</span><br><span class="line">        # 找剩余没有通过边的最短路径</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> nodes:</span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> nodes:</span><br><span class="line">                # 边已经通过，继续</span><br><span class="line">                <span class="keyword">if</span> s <span class="keyword">in</span> visited and d <span class="keyword">in</span> visited or s == d:</span><br><span class="line">                    continue</span><br><span class="line">                <span class="keyword">if</span> graph[s][d] &lt; distance:</span><br><span class="line">                    distance = graph[s][d]</span><br><span class="line">                    pre = s</span><br><span class="line">                    next = d</span><br><span class="line">        # 将最小边加入节点</span><br><span class="line">        path.append((pre, next))</span><br><span class="line">        visited.add(pre)</span><br><span class="line">        visited.add(next)</span><br><span class="line"></span><br><span class="line">    return path</span><br><span class="line"></span><br><span class="line">def dijkstra(graph, src):</span><br><span class="line">    length = len(graph)</span><br><span class="line">    type_ = type(graph)</span><br><span class="line">    <span class="keyword">if</span> type_ == list:</span><br><span class="line">        nodes = [<span class="selector-tag">i</span> <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(length)]</span><br><span class="line">    elif type_ == dict:</span><br><span class="line">        nodes = list(graph.keys())</span><br><span class="line"></span><br><span class="line">    visited = [src]</span><br><span class="line">    path = &#123;src: &#123;src: []&#125;&#125;</span><br><span class="line">    nodes.remove(src)</span><br><span class="line">    distance_graph = &#123;src: <span class="number">0</span>&#125;</span><br><span class="line">    pre = next = src</span><br><span class="line"></span><br><span class="line">    while nodes:</span><br><span class="line">        distance = <span class="attribute">float</span>(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> visited:</span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> nodes:</span><br><span class="line">                # 核心：起点到中间节点+中间节点到终点</span><br><span class="line">                # 其中：中间节点为已访问节点，终点为未访问节点</span><br><span class="line">                new_dist = graph[src][v] + graph[v][d]</span><br><span class="line">                <span class="keyword">if</span> new_dist &lt;= distance:</span><br><span class="line">                    distance = new_dist</span><br><span class="line">                    next = d</span><br><span class="line">                    pre = v</span><br><span class="line">                    graph[src][d] = new_dist</span><br><span class="line"></span><br><span class="line">        path[src][next] = [<span class="selector-tag">i</span> <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> path[src][pre]]</span><br><span class="line">        path[src][next].append(next)</span><br><span class="line"></span><br><span class="line">        distance_graph[next] = distance</span><br><span class="line"></span><br><span class="line">        visited.append(next)</span><br><span class="line">        nodes.remove(next)</span><br><span class="line"></span><br><span class="line">    return distance_graph, path</span><br><span class="line"></span><br><span class="line">def floyd(graph):</span><br><span class="line">    length = len(graph)</span><br><span class="line">    path = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> src <span class="keyword">in</span> graph:</span><br><span class="line">        path.setdefault(src, &#123;&#125;)</span><br><span class="line">        <span class="keyword">for</span> dst <span class="keyword">in</span> graph[src]:</span><br><span class="line">            <span class="keyword">if</span> src == dst:</span><br><span class="line">                continue</span><br><span class="line">            path[src].setdefault(dst, [src,dst])</span><br><span class="line">            new_node = None</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> mid <span class="keyword">in</span> graph:</span><br><span class="line">                <span class="keyword">if</span> mid == dst:</span><br><span class="line">                    continue</span><br><span class="line">                # 距离相加</span><br><span class="line">                new_len = graph[src][mid] + graph[mid][dst]</span><br><span class="line">                <span class="keyword">if</span> graph[src][dst] &gt; new_len:</span><br><span class="line">                    graph[src][dst] = new_len</span><br><span class="line">                    new_node = mid</span><br><span class="line">            <span class="keyword">if</span> new_node:</span><br><span class="line">                path[src][dst].insert(-<span class="number">1</span>, new_node)</span><br><span class="line"></span><br><span class="line">    return graph, path</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def getEdges(G):</span><br><span class="line">    <span class="string">""</span><span class="string">" 读入图G，返回其边与端点的列表 "</span><span class="string">""</span></span><br><span class="line"></span><br><span class="line">    v1 = []  # 出发点</span><br><span class="line">    v2 = []  # 对应的相邻到达点</span><br><span class="line">    w = []  # 顶点v1到顶点v2的边的权值</span><br><span class="line">    <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> G:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> G[i]:</span><br><span class="line">            <span class="keyword">if</span> G[i][j] != <span class="number">0</span>:</span><br><span class="line">                w.append(G[i][j])</span><br><span class="line">                v1.append(i)</span><br><span class="line">                v2.append(j)</span><br><span class="line">    return v1, v2, w</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def Bellman_Ford(G, v0, INF=999):</span><br><span class="line">    v1, v2, w = getEdges(G)</span><br><span class="line">    # 初始化源点与所有点之间的最短距离</span><br><span class="line">    dis = dict((k, INF) <span class="keyword">for</span> k <span class="keyword">in</span> G.keys())</span><br><span class="line">    dis[v0] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    # 核心算法</span><br><span class="line">    for k in range(len(G) - 1):  # 循环 n-1轮</span><br><span class="line"></span><br><span class="line">        check = 0  # 用于标记本轮松弛中dis是否发生更新</span><br><span class="line">        for i in range(len(w)):  # 对每条边进行一次松弛操作</span><br><span class="line">            <span class="keyword">if</span> dis[v1[i]] + w[i] &lt; dis[v2[i]]:</span><br><span class="line">                dis[v2[i]] = dis[v1[i]] + w[i]</span><br><span class="line">                check = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> check == <span class="number">0</span>: break</span><br><span class="line"></span><br><span class="line">    # 检测负权回路</span><br><span class="line">    # 如果在 n-1 次松弛之后，最短路径依然发生变化，则该图必然存在负权回路</span><br><span class="line">    flag = <span class="number">0</span></span><br><span class="line">    for i in range(len(w)):  # 对每条边再尝试进行一次松弛操作</span><br><span class="line">        <span class="keyword">if</span> dis[v1[i]] + w[i] &lt; dis[v2[i]]:</span><br><span class="line">            flag = <span class="number">1</span></span><br><span class="line">            break</span><br><span class="line">    <span class="keyword">if</span> flag == <span class="number">1</span>:</span><br><span class="line">        #         raise CycleError()</span><br><span class="line">        return False</span><br><span class="line">    return dis</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    graph_dict = &#123;<span class="string">"s1"</span>: &#123;<span class="string">"s1"</span>: <span class="number">0</span>, <span class="string">"s2"</span>: <span class="number">2</span>, <span class="string">"s10"</span>: <span class="number">3</span>, <span class="string">"s12"</span>: <span class="number">4</span>, <span class="string">"s5"</span>: <span class="number">3</span>&#125;,</span><br><span class="line">                  <span class="string">"s2"</span>: &#123;<span class="string">"s1"</span>: <span class="number">1</span>, <span class="string">"s2"</span>: <span class="number">0</span>, <span class="string">"s10"</span>: <span class="number">4</span>, <span class="string">"s12"</span>: <span class="number">2</span>, <span class="string">"s5"</span>: <span class="number">2</span>&#125;,</span><br><span class="line">                  <span class="string">"s10"</span>: &#123;<span class="string">"s1"</span>: <span class="number">2</span>, <span class="string">"s2"</span>: <span class="number">6</span>, <span class="string">"s10"</span>: <span class="number">0</span>, <span class="string">"s12"</span>: <span class="number">3</span>, <span class="string">"s5"</span>: <span class="number">4</span>&#125;,</span><br><span class="line">                  <span class="string">"s12"</span>: &#123;<span class="string">"s1"</span>: <span class="number">3</span>, <span class="string">"s2"</span>: <span class="number">5</span>, <span class="string">"s10"</span>: <span class="number">2</span>, <span class="string">"s12"</span>: <span class="number">0</span>, <span class="string">"s5"</span>: <span class="number">2</span>&#125;,</span><br><span class="line">                  <span class="string">"s5"</span>: &#123;<span class="string">"s1"</span>: <span class="number">3</span>, <span class="string">"s2"</span>: <span class="number">5</span>, <span class="string">"s10"</span>: <span class="number">2</span>, <span class="string">"s12"</span>: <span class="number">4</span>, <span class="string">"s5"</span>: <span class="number">0</span>&#125;,</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">    path1 = prim(graph_dict, <span class="string">'s12'</span>)</span><br><span class="line">    print(path1)</span><br><span class="line">    path = kruskal(graph_dict)</span><br><span class="line">    print (path)</span><br><span class="line">    distance, path = dijkstra(graph_dict, <span class="string">'s1'</span>)</span><br><span class="line">    print(distance, <span class="string">'\n'</span>, path)</span><br><span class="line">    new_graph, path= floyd(graph_dict)</span><br><span class="line">    print (new_graph, <span class="string">'\n'</span>, path)</span><br><span class="line">    dis = Bellman_Ford(graph_dict, <span class="string">'s1'</span>)</span><br><span class="line">    print(dis)</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>ML/DL</category>
      </categories>
      <tags>
        <tag>图算法</tag>
        <tag>Prim</tag>
        <tag>Kruskal</tag>
        <tag>Dijkstra</tag>
        <tag>Floyd</tag>
        <tag>Bellman</tag>
        <tag>有向图</tag>
        <tag>无向图</tag>
        <tag>最优化</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程实战15-重排序、happens-before</title>
    <url>/2018/04/17/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9815-%E9%87%8D%E6%8E%92%E5%BA%8F%E3%80%81happens-before%E3%80%81final/</url>
    <content><![CDATA[<ul>
<li>指令重排序<br>为了优化CPU的运行效率，在条件允许的情况下，直接运行当前有能力立即执行的后续指令，避开获取下一条指令所需数据时造成的等待3。通过乱序执行的技术，处理器可以大大提高执行效率。<br>比如：对于如下代码</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">int <span class="selector-tag">a</span> = <span class="number">10</span> <span class="comment">// 1 </span></span><br><span class="line">int <span class="selector-tag">b</span> = <span class="number">100</span> <span class="comment">// 2</span></span><br><span class="line">int c = <span class="selector-tag">a</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>实际的执行过程可能会是：1-3-2，而不是：1-2-3；因为第一步获取a的值后，第三部仍然需要使用，此时，由于第二步并不会干扰单线程下程序了逻辑，将会直接执行3，再执行2.避免二次读取a值。（只是说明可能的原理，例子并不一定正确）</p>
<ul>
<li><p>数据依赖性（as-if-serial）</p>
<ul>
<li>As-if-serial语义的意思是，所有的动作(Action)5都可以为了优化而被重排序，但是必须保证它们重排序后的结果和程序代码本身的应有结果是一致的。<br>即</li>
<li>即如果后续逻辑计算需要依赖之前的某个值a，那么a这个值的计算步骤不能跳过。如上代码：第3步，c的值需要使用a，所以不能跳过1直接执行3</li>
</ul>
</li>
<li><p>happens-before 规则<br>语义：如果A先发生于B，那么A所做的所有改变都能被B看到<br>Happens-before是用来指定两个操作之间的执行顺序。提供跨线程的内存可见性。在Java内存模型中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必然存在happens-before关系。</p>
</li>
</ul>
<p>遵循的规则：<br>    * 程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。<br>    * 监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。<br>    * volatile变量规则：对一个volatile域的写，happens- before 于任意后续对这个volatile域的读。<br>    * 传递性：如果A happens- before B，且B happens- before C，那么A happens- before C。</p>
<ul>
<li><p>锁和volatile的内存语义：（JMM）</p>
<ul>
<li>锁的获取：首先清空当前线程value内存，从主存中获取最新值；锁的释放：将当前线程内存value刷新到主内存</li>
<li>volatile的读写与锁的获取和释放对应，原理类似</li>
</ul>
</li>
<li><p>final域的重排序规则<br>对于final域，编译器和处理器要遵守两个重排序规则</p>
</li>
</ul>
<p>1&gt; 在构造函数内对一个final域的写入，与随后把这个构造函数的引用赋值给一个引用变量，两个操作不能重排序<br>2&gt; 初次读一个包含final域对象的引用，和随后初次读这个final域，这两个操作不能重排序  </p>
<p><a href="https://tech.meituan.com/java-memory-reordering.html" target="_blank" rel="noopener">美团点评博客-Java内存访问重排序的研究</a><br><a href="http://www.infoq.com/cn/articles/java-memory-model-5" target="_blank" rel="noopener">深入理解Java内存模型（五）——锁</a><br><a href="https://blog.csdn.net/ditto_zhou/article/details/78738197" target="_blank" rel="noopener">java多线程学习(九)final的内存语义</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>重排序</tag>
        <tag>happens-before</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程实战14-LongAdder统计加法器-计数器jdk8</title>
    <url>/2018/04/17/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9814-LongAdder%E7%BB%9F%E8%AE%A1%E5%8A%A0%E6%B3%95%E5%99%A8-%E8%AE%A1%E6%95%B0%E5%99%A8jdk8/</url>
    <content><![CDATA[<p>传统的原子锁AtomicLong/AtomicInt虽然也可以处理大量并发情况下的计数器，但是由于使用了自旋等待，当存在大量竞争时，会存在大量自旋等待，而导致CPU浪费，而有效计算很少，降低了计算效率。</p>
<p>而LongAdder是根据ConcurrentHashMap这类为并发设计的类的基本原理——锁分段，通过维护一个计数数组cells来保存多个计数副本，每个线程只对自己的副本进行操作，最后汇总来得到最终结果。</p>
<blockquote>
<p>Adder的英文意思为加法器，从字面意思上就可以理解，LongAdder的作用是用来进行统计计算的。比如，我们需要一个计数器，加入计数值为N，当大量的线程访问时，N的值将会出现并发安全，但是，我们并不打算在每个单独的子线程中去查看这个N值，只是在所有的子线程完毕后，才会统计N的总数，即相当于一种并行计算，但是我们不在乎中间结果，只在乎，中间计算都进行了就可以。因此，我们对可以变量创建一个副本N’，每个线程都有这个副本，只对这个副本进行操作，最后，将所有的副本进行汇总就是最终的N值，即：<code>N=N1&#39;+N2&#39;+N3&#39;...+Nn&#39;</code>。</p>
</blockquote>
<blockquote>
<p>详细原理：内部源码使用了一个cells的数组来保存每个线程的副本，第一个线程会初始化数组cells。新来到一个线程，会指向第一个cell，并检测是否有其他线程使用CAS，如果没有，则所有线程公用一个cel副本；否则，如果自旋等待，则当前线程新建一个cell副本，加入到数组cells，对副本进行操作。当所有操作完成后，使用sum函数就可以统计所有的操作。</p>
</blockquote>
<p><strong>这里也用到了cas操作，主要是为了防止多线程公用一个cell，导致一个cell数据并发出错，另外注意LongAdder的并不是细粒度的，所以不能使用中间值</strong></p>
<ol>
<li>线程副本cell<br>LongAdder继承自Striped64类，主要逻辑方法在Striped64中。<br>其中cell即为每个线程的副本变量，使用的是一个静态内部类Cell，维护了一个value变量</li>
</ol>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">@sun<span class="selector-class">.misc</span><span class="selector-class">.Contended</span> static final class Cell &#123;</span><br><span class="line">        volatile long value;</span><br><span class="line">        Cell(long x) &#123; value = x; &#125;</span><br><span class="line">        final boolean cas(long cmp, long val) &#123;</span><br><span class="line">            return UNSAFE.compareAndSwapLong(this, valueOffset, cmp, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Unsafe mechanics</span></span><br><span class="line">        private static final sun.misc.Unsafe UNSAFE;</span><br><span class="line">        private static final long valueOffset;</span><br><span class="line">        static &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">                Class&lt;?&gt; ak = Cell.class;</span><br><span class="line">                valueOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                    (ak.getDeclaredField("value"));</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                throw new Error(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>问题：既然Cell这么简单，为什么不直接用long value？<br>我的理解：可能要设计到Java值引用问题，如果直接使用long value，在线程B进行数组扩容后，线程A修改的value值将无法反映到线程B；而使用Cell对象对value进行包装后，由于线程A只会修改Cell对象的value值，不会修改Cell对象，所以线程B的Cell中的value也会跟着改变，就不会出现值问题。更具体的了解，可能需要了解一下java的值传递（java没有引用传递）</p>
<p> 2.Striped64主体代码<br> 主方法为longAccumulate方法，主要处理数组的扩容和冲突检查</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">abstract class Striped64 extends Number &#123;  </span><br><span class="line">    @sun<span class="selector-class">.misc</span><span class="selector-class">.Contended</span> static final class Cell &#123; ... &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** Number of CPUS, to place bound on table size */</span>  </span><br><span class="line">    static final int NCPU = Runtime.getRuntime().availableProcessors();  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// cell数组，长度一样要是2^n，可以类比为jdk1.7的ConcurrentHashMap中的segments数组  </span></span><br><span class="line">    transient volatile Cell[] cells;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 累积器的基本值，在两种情况下会使用：  </span></span><br><span class="line">    <span class="comment">// 1、没有遇到并发的情况，直接使用base，速度更快；  </span></span><br><span class="line">    <span class="comment">// 2、多线程并发初始化table数组时，必须要保证table数组只被初始化一次，因此只有一个线程能够竞争成功，这种情况下竞争失败的线程会尝试在base上进行一次累积操作  </span></span><br><span class="line">    transient volatile long base;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 自旋标识，在对cells进行初始化，或者后续扩容时，需要通过CAS操作把此标识设置为1（busy，忙标识，相当于加锁），取消busy时可以直接使用cellsBusy = 0，相当于释放锁  </span></span><br><span class="line">    transient volatile int cellsBusy;  </span><br><span class="line">  </span><br><span class="line">    Striped64() &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 使用CAS更新base的值  </span></span><br><span class="line">    final boolean casBase(long cmp, long val) &#123;  </span><br><span class="line">        return UNSAFE.compareAndSwapLong(this, BASE, cmp, val);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 使用CAS将cells自旋标识更新为1  </span></span><br><span class="line">    <span class="comment">// 更新为0时可以不用CAS，直接使用cellsBusy就行  </span></span><br><span class="line">    final boolean casCellsBusy() &#123;  </span><br><span class="line">        return UNSAFE.compareAndSwapInt(this, CELLSBUSY, 0, 1);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 下面这两个方法是ThreadLocalRandom中的方法，不过因为包访问关系，这里又重新写一遍  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// probe翻译过来是探测/探测器/探针这些，不好理解，它是ThreadLocalRandom里面的一个属性，  </span></span><br><span class="line">    <span class="comment">// 不过并不影响对Striped64的理解，这里可以把它理解为线程本身的hash值  </span></span><br><span class="line">    static final int getProbe() &#123;  </span><br><span class="line">        return UNSAFE.getInt(Thread.currentThread(), PROBE);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 相当于rehash，重新算一遍线程的hash值  </span></span><br><span class="line">    static final int advanceProbe(int probe) &#123;  </span><br><span class="line">        probe ^= probe &lt;&lt; 13;   // xorshift  </span><br><span class="line">        probe ^= probe &gt;&gt;&gt; 17;  </span><br><span class="line">        probe ^= probe &lt;&lt; 5;  </span><br><span class="line">        UNSAFE.putInt(Thread.currentThread(), PROBE, probe);  </span><br><span class="line">        return probe;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 核心方法的实现，此方法建议在外部进行一次CAS操作（cell != null时尝试CAS更新base值，cells != null时，CAS更新hash值取模后对应的cell.value） </span></span><br><span class="line"><span class="comment">     * @param x the value 前面我说的二元运算中的第二个操作数，也就是外部提供的那个操作数 </span></span><br><span class="line"><span class="comment">     * @param fn the update function, or null for add (this convention avoids the need for an extra field or function in LongAdder). </span></span><br><span class="line"><span class="comment">     *     外部提供的二元算术操作，实例持有并且只能有一个，生命周期内保持不变，null代表LongAdder这种特殊但是最常用的情况，可以减少一次方法调用 </span></span><br><span class="line"><span class="comment">     * @param wasUncontended false if CAS failed before call 如果为false，表明调用者预先调用的一次CAS操作都失败了 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    final void longAccumulate(long x, LongBinaryOperator fn, boolean wasUncontended) &#123;  </span><br><span class="line">        int h;  </span><br><span class="line">        <span class="comment">// 这个if相当于给线程生成一个非0的hash值  </span></span><br><span class="line">        <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;  </span><br><span class="line">            ThreadLocalRandom.current(); // force initialization  </span><br><span class="line">            h = getProbe();  </span><br><span class="line">            wasUncontended = true;  </span><br><span class="line">        &#125;  </span><br><span class="line">        boolean collide = false; // True if last slot nonempty 如果hash取模映射得到的Cell单元不是null，则为true，此值也可以看作是扩容意向，感觉这个更好理解  </span><br><span class="line">        for (;;) &#123;  </span><br><span class="line">            Cell[] as; Cell a; int n; long v;  </span><br><span class="line">            <span class="keyword">if</span> ((as = cells) != null &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123; <span class="comment">// cells已经被初始化了  </span></span><br><span class="line">                <span class="keyword">if</span> ((<span class="selector-tag">a</span> = as[(n - <span class="number">1</span>) &amp; h]) == null) &#123; <span class="comment">// hash取模映射得到的Cell单元还为null（为null表示还没有被使用）  </span></span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;       <span class="comment">// Try to attach new Cell 如果没有线程正在执行扩容  </span></span><br><span class="line">                        Cell r = new Cell(x);   // Optimistically create 先创建新的累积单元  </span><br><span class="line">                        <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123; <span class="comment">// 尝试加锁  </span></span><br><span class="line">                            boolean created = false;  </span><br><span class="line">                            try &#123;               <span class="comment">// Recheck under lock 在有锁的情况下再检测一遍之前的判断  </span></span><br><span class="line">                                Cell[] rs; int m, j;  </span><br><span class="line">                                <span class="keyword">if</span> ((rs = cells) != null &amp;&amp; (m = rs.length) &gt; <span class="number">0</span> &amp;&amp; rs[j = (m - <span class="number">1</span>) &amp; h] == null) &#123; <span class="comment">// 考虑别的线程可能执行了扩容，这里重新赋值重新判断  </span></span><br><span class="line">                                    rs[j] = r; // 对没有使用的Cell单元进行累积操作（第一次赋值相当于是累积上一个操作数，求和时再和base执行一次运算就得到实际的结果）  </span><br><span class="line">                                    created = true;  </span><br><span class="line">                                &#125;  </span><br><span class="line">                            &#125; finally &#123;  </span><br><span class="line">                                cellsBusy = 0; 清空自旋标识，释放锁  </span><br><span class="line">                            &#125;  </span><br><span class="line">                            <span class="keyword">if</span> (created) <span class="comment">// 如果原本为null的Cell单元是由自己进行第一次累积操作，那么任务已经完成了，所以可以退出循环  </span></span><br><span class="line">                                break;  </span><br><span class="line">                            continue;           // Slot is now non-empty 不是自己进行第一次累积操作，重头再来  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    collide = false; // 执行这一句是因为cells被加锁了，不能往下继续执行第一次的赋值操作（第一次累积），所以还不能考虑扩容  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended) <span class="comment">// CAS already known to fail 前面一次CAS更新a.value（进行一次累积）的尝试已经失败了，说明已经发生了线程竞争  </span></span><br><span class="line">                    wasUncontended = true; // Continue after rehash 情况失败标识，后面去重新算一遍线程的hash值  </span><br><span class="line">                else if (a.cas(v = a.value, ((fn == null) ? v + x : fn.applyAsLong(v, x)))) // 尝试CAS更新a.value（进行一次累积） ------ 标记为分支A  </span><br><span class="line">                    break; // 成功了就完成了累积任务，退出循环  </span><br><span class="line">                else if (n &gt;= NCPU || cells != as) // cell数组已经是最大的了，或者中途发生了扩容操作。因为NCPU不一定是2^n，所以这里用 &gt;=  </span><br><span class="line">                    collide = false; // At max size or stale 长度n是递增的，执行到了这个分支，说明n &gt;= NCPU会永远为true，下面两个else if就永远不会被执行了，也就永远不会再进行扩容  </span><br><span class="line">                                     <span class="comment">// CPU能够并行的CAS操作的最大数量是它的核心数（CAS在x86中对应的指令是cmpxchg，多核需要通过锁缓存来保证整体原子性），当n &gt;= NCPU时，再出现几个线程映射到同一个Cell导致CAS竞争的情况，那就真不关扩容的事了，完全是hash值的锅了  </span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!collide) <span class="comment">// 映射到的Cell单元不是null，并且尝试对它进行累积时，CAS竞争失败了，这时候把扩容意向设置为true  </span></span><br><span class="line">                                   <span class="comment">// 下一次循环如果还是跟这一次一样，说明竞争很严重，那么就真正扩容  </span></span><br><span class="line">                    collide = true; // 把扩容意向设置为true，只有这里才会给collide赋值为true，也只有执行了这一句，才可能执行后面一个else if进行扩容  </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123; <span class="comment">// 最后再考虑扩容，能到这一步说明竞争很激烈，尝试加锁进行扩容 ------ 标记为分支B  </span></span><br><span class="line">                    try &#123;  </span><br><span class="line">                        <span class="keyword">if</span> (cells == as) &#123;      <span class="comment">// Expand table unless stale 检查下是否被别的线程扩容了（CAS更新锁标识，处理不了ABA问题，这里再检查一遍）  </span></span><br><span class="line">                            Cell[] rs = new Cell[n &lt;&lt; 1]; // 执行2倍扩容  </span><br><span class="line">                            for (int i = 0; i &lt; n; ++i)  </span><br><span class="line">                                rs[i] = as[i];  </span><br><span class="line">                            cells = rs;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125; finally &#123;  </span><br><span class="line">                        cellsBusy = 0; // 释放锁  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    collide = false; // 扩容意向为false  </span><br><span class="line">                    continue; // Retry with expanded table 扩容后重头再来  </span><br><span class="line">                &#125;  </span><br><span class="line">                h = advanceProbe(h); // 重新给线程生成一个hash值，降低hash冲突，减少映射到同一个Cell导致CAS竞争的情况  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123; <span class="comment">// cells没有被加锁，并且它没有被初始化，那么就尝试对它进行加锁，加锁成功进入这个else if  </span></span><br><span class="line">                boolean init = false;  </span><br><span class="line">                try &#123;                           <span class="comment">// Initialize table  </span></span><br><span class="line">                    <span class="keyword">if</span> (cells == as) &#123; <span class="comment">// CAS避免不了ABA问题，这里再检测一次，如果还是null，或者空数组，那么就执行初始化  </span></span><br><span class="line">                        Cell[] rs = new Cell[2]; // 初始化时只创建两个单元  </span><br><span class="line">                        rs[h &amp; 1] = new Cell(x); // 对其中一个单元进行累积操作，另一个不管，继续为null  </span><br><span class="line">                        cells = rs;  </span><br><span class="line">                        init = true;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125; finally &#123;  </span><br><span class="line">                    cellsBusy = 0; // 清空自旋标识，释放锁  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">if</span> (init) <span class="comment">// 如果某个原本为null的Cell单元是由自己进行第一次累积操作，那么任务已经完成了，所以可以退出循环  </span></span><br><span class="line">                    break;  </span><br><span class="line">            &#125;  </span><br><span class="line">            else if (casBase(v = base, ((fn == null) ? v + x : fn.applyAsLong(v, x)))) // cells正在进行初始化时，尝试直接在base上进行累加操作  </span><br><span class="line">                break;                          // Fall back on using base 直接在base上进行累积操作成功了，任务完成，可以退出循环了  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// double的不讲，更long的逻辑基本上是一样的  </span></span><br><span class="line">    final void doubleAccumulate(double x, DoubleBinaryOperator fn, boolean wasUncontended);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Unsafe mechanics Unsafe初始化  </span></span><br><span class="line">    private static final sun.misc.Unsafe UNSAFE;  </span><br><span class="line">    private static final long BASE;  </span><br><span class="line">    private static final long CELLSBUSY;  </span><br><span class="line">    private static final long PROBE;  </span><br><span class="line">    static &#123;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();  </span><br><span class="line">            Class&lt;?&gt; sk = Striped64.class;  </span><br><span class="line">            BASE = UNSAFE<span class="selector-class">.objectFieldOffset</span>  </span><br><span class="line">                (sk.getDeclaredField("base"));  </span><br><span class="line">            CELLSBUSY = UNSAFE<span class="selector-class">.objectFieldOffset</span>  </span><br><span class="line">                (sk.getDeclaredField("cellsBusy"));  </span><br><span class="line">            Class&lt;?&gt; tk = Thread.class;  </span><br><span class="line">            PROBE = UNSAFE<span class="selector-class">.objectFieldOffset</span>  </span><br><span class="line">                (tk.getDeclaredField("threadLocalRandomProbe"));  </span><br><span class="line">        &#125; catch (Exception e) &#123;  </span><br><span class="line">            throw new Error(e);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 3.LongAdder的add()方法<br> add(long x) 方法不仅仅实现加，参数为负就为减；调用longAccumulate来进行操作</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">public void add(long x) &#123;  </span><br><span class="line">    Cell[] as; long b, v; int m; Cell a;  </span><br><span class="line">    if ((as = cells) != null || !casBase(b = base, b + x)) &#123;  </span><br><span class="line">        boolean uncontended = true;  </span><br><span class="line">        if (as == null || (m = as.length - 1) &lt; 0 ||  </span><br><span class="line">            (a = as[getProbe() &amp; m]) == null ||  </span><br><span class="line">            !(uncontended = <span class="selector-tag">a</span>.cas(v = <span class="selector-tag">a</span><span class="selector-class">.value</span>, v + x)))  </span><br><span class="line">            longAccumulate(x, null, uncontended);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>jdk1.8的ConcurrentHashMap中，没有再使用Segment，使用了一个简单的仿造LongAdder实现的计数器，这样能够保证计数效率不低于使用Segment的效率。</strong></p>
<p><a href="https://blog.csdn.net/u011392897/article/details/60480108" target="_blank" rel="noopener">jdk1.8 LongAdder源码学习</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>LongAdder</tag>
        <tag>加法器</tag>
        <tag>JDK8</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程实战13-同步中的四种锁synchronized、ReentrantLock、ReentrantReadWriteLock、StampedLock</title>
    <url>/2018/04/17/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9813-%E5%90%8C%E6%AD%A5%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%94%81synchronized%E3%80%81ReentrantLock%E3%80%81ReentrantReadWriteLock%E3%80%81StampedLock/</url>
    <content><![CDATA[<ol>
<li>synchronized同步锁<ul>
<li>synchronized属于悲观锁，直接对区域或者对象加锁，性能稳定，可以使用大部分场景。</li>
</ul>
</li>
<li>ReentrantLock可重入锁（Lock接口）<ul>
<li>相对于synchronized更加灵活，可以控制加锁和放锁的位置</li>
<li>可以使用Condition来操作线程，进行线程之间的通信</li>
<li>核心类AbstractQueuedSynchronizer，通过构造一个基于阻塞的CLH队列容纳所有的阻塞线程，而对该队列的操作均通过Lock-Free（CAS）操作，但对已经获得锁的线程而言，ReentrantLock实现了偏向锁的功能。</li>
</ul>
</li>
<li>ReentrantReadWriteLock可重入读写锁（ReadWriteLock接口）<ul>
<li>相对于ReentrantLock，对于大量的读操作，读和读之间不会加锁，只有存在写时才会加锁，但是这个锁是悲观锁</li>
<li>ReentrantReadWriteLock实现了读写锁的功能</li>
<li>ReentrantReadWriteLock是ReadWriteLock接口的实现类。ReadWriteLock接口的核心方法是readLock()，writeLock()。实现了并发读、互斥写。但读锁会阻塞写锁，是悲观锁的策略。</li>
</ul>
</li>
<li>StampedLock戳锁<ul>
<li>ReentrantReadWriteLock虽然解决了大量读取的效率问题，但是，由于实现的是悲观锁，当读取很多时，读取和读取之间又没有锁，写操作将无法竞争到锁，就会导致写线程饥饿。所以就需要对读取进行乐观锁处理。</li>
<li>StampedLock加入了乐观读锁，不会排斥写入</li>
<li>当并发量大且读远大于写的情况下最快的的是StampedLock锁</li>
</ul>
</li>
</ol>
<hr>
<blockquote>
<p>StampedLock控制锁有三种模式（排它写，悲观读，乐观读），一个StampedLock状态是由版本和模式两个部分组成，锁获取方法返回一个数字作为票据stamp，它用相应的锁状态表示并控制访问。</p>
</blockquote>
<p>StampedLock主要使用的是乐观读取，通过一个stamp变量来检测是否有读写冲突，每次乐观读取时会加入stamp校验。当存在写入操作时，写操作会改变stamp的状态，就会导致乐观读取失败，乐观读锁就会升级为悲观读锁</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">package com.sound.daytd5;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.locks.StampedLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author: ZouTai</span></span><br><span class="line"><span class="comment"> * @date: 2018/4/17</span></span><br><span class="line"><span class="comment"> * @description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public class StampedLockDemo &#123;</span><br><span class="line">    private int balance;</span><br><span class="line">    private final StampedLock stampedLock = new StampedLock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、悲观写</span></span><br><span class="line"><span class="comment">     * writeLock()：典型的cas操作，如果STATE等于s,设置写锁位为1（s+WBIT）。</span></span><br><span class="line"><span class="comment">     * acquireWrite跟acquireRead逻辑类似，先自旋尝试、加入等待队列、直至最终Unsafe.park()挂起线程。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    public void write(int i) &#123;</span><br><span class="line">        long stamp = stampedLock.writeLock();</span><br><span class="line">        balance += i;</span><br><span class="line">        stampedLock.unlockWrite(stamp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2、悲观读</span></span><br><span class="line"><span class="comment">     * 乐观锁失败后锁升级为readLock()：尝试state+1,用于统计读线程的数量，</span></span><br><span class="line"><span class="comment">     * 如果失败，进入acquireRead()进行自旋，通过CAS获取锁。</span></span><br><span class="line"><span class="comment">     * 如果自旋失败，入CLH队列，然后再自旋，</span></span><br><span class="line"><span class="comment">     * 如果成功获得读锁，激活cowait队列中的读线程Unsafe.unpark(),</span></span><br><span class="line"><span class="comment">     * 最终依然失败，Unsafe().park()挂起当前线程。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public void read() &#123;</span><br><span class="line">        long stamp = stampedLock.readLock();</span><br><span class="line">        int value = balance;</span><br><span class="line">        stampedLock.unlockRead(stamp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**重点：！！！</span></span><br><span class="line"><span class="comment">     * 3、乐观读：当读取远远大于写入时，使用乐观锁</span></span><br><span class="line"><span class="comment">     * tryOptimisticRead()：如果当前没有写锁占用，返回state(后7位清0，即清0读线程数)，如果有写锁，返回0，即失败。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public void optimisticRead() &#123;</span><br><span class="line">        long stamp = stampedLock.tryOptimisticRead();</span><br><span class="line">        int value = balance;</span><br><span class="line">        <span class="comment">// 校验这个戳是否有效validate()：比较当前stamp和发生乐观锁得到的stamp比较，不一致则失败。</span></span><br><span class="line">        <span class="keyword">if</span>(!stampedLock.validate(stamp)) &#123;</span><br><span class="line">            long readStamp = stampedLock.readLock();</span><br><span class="line">            value = balance;</span><br><span class="line">            stamp = readStamp;</span><br><span class="line">        &#125;</span><br><span class="line">        stampedLock.unlockRead(stamp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**重点：！</span></span><br><span class="line"><span class="comment">     * 4、判断条件之后，再写</span></span><br><span class="line"><span class="comment">     * 存在读取和写入两个操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public void conditionReadWrite(int state)&#123;</span><br><span class="line">        <span class="comment">// 首先读取</span></span><br><span class="line">        long stamp = stampedLock.readLock();</span><br><span class="line">        while (balance &gt; <span class="number">100</span>)&#123;</span><br><span class="line">            long writeStamp = stampedLock.tryConvertToWriteLock(stamp);</span><br><span class="line">            <span class="comment">// 步骤：a</span></span><br><span class="line">            <span class="keyword">if</span>(writeStamp!=<span class="number">0</span>) &#123;</span><br><span class="line">                balance += state;</span><br><span class="line">                stamp = writeStamp;</span><br><span class="line">                break;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 转换失败</span></span><br><span class="line">                stampedLock.unlockRead(stamp);</span><br><span class="line">                <span class="comment">//显式直接进行写锁 然后再通过循环再试,回到 步骤：a</span></span><br><span class="line">                stamp = stampedLock.writeLock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><a href="http://colobu.com/2016/06/01/Java-8-StampedLocks-vs-ReadWriteLocks-and-Synchronized/" target="_blank" rel="noopener">同步中四种锁的性能比较</a><br><a href="http://www.cnblogs.com/dennyzhangdd/p/6925473.html" target="_blank" rel="noopener">同步中的四种锁synchronized、ReentrantLock、ReentrantReadWriteLock、StampedLock</a><br><a href="https://www.javaspecialists.eu/talks/jfokus13/PhaserAndStampedLock.pdf" target="_blank" rel="noopener">同步锁参考英文文档</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>线程通信</tag>
        <tag>synchronized</tag>
        <tag>ReentrantLock</tag>
        <tag>ReentrantReadWriteLock</tag>
        <tag>StampedLock</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程实战11-并发容器CopyOnWriteArrayList</title>
    <url>/2018/04/11/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9811-%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8CopyOnWriteArrayList/</url>
    <content><![CDATA[<p>一、同步容器和并发容器<br>在jdk早期，为了解决并发安全问题，引入了同步容器Vector和Hashtable。在JDK1.2中，引入了同步封装类，可以由Collections.synchronizedXxxx等方法创建，可以直接对ArrayList进行封装以达到同步。但是，同步容器有一个问题，过于严格，即完全串行执行，导致即便是在复合操作下，并没有线程安全问题，也会加锁。<br>常见复合操作如下：<br>    * 迭代：反复访问元素，直到遍历完全部元素；<br>    * 跳转：根据指定顺序寻找当前元素的下一个（下n个）元素；<br>    * 条件运算：例如若没有则添加等；</p>
<p>同步容器对所有容器状态的访问都串行化，严重降低了并发性；当多个线程竞争锁时，吞吐量严重下降；</p>
<p>java5.0之后提供了多种并发容器来改善同步容器的性能，如ConcurrentHashMap、CopyOnWriteArrayList、CopyOnWriteArraySet、ConcurrentSkipListMap等；这些容器通过进行优化以达到适应不同需求的目的，并没有完全串行化。</p>
<table>
<thead>
<tr>
<th>一般容器</th>
<th>同步容器</th>
<th>并发容器</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayList</td>
<td>Vector</td>
<td>CopyOnWriteArrayList</td>
</tr>
<tr>
<td>HashMap</td>
<td>HashTable</td>
<td>ConcurrentHashMap</td>
</tr>
</tbody></table>
<p>一般容器线程不安全；同步容器线程安全，但是过于严格；为了满足实际需求，合理适应需求，增加了并发容器，更好的适应并发条件，即同步容器为了安全，并发容器为了安全的同时，达到高并发的效率。</p>
<p>二、源码分析：CopyOnWriteArrayList<br>在前面了解读写锁时就已经知道，在实际情况中，往往读取更多，写入很少，而读取数据并不影响数据的安全，所以读数据完全可以并发进行，而只将写数据进行严格加锁。</p>
<ul>
<li>当修改时（添加和移除），就对数组进行复制，此时要加锁。</li>
<li>当读取时，不加锁，直接读取</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** The lock protecting all mutators */</span></span><br><span class="line"><span class="comment">// 1、用于加锁的可重入锁</span></span><br><span class="line">final transient ReentrantLock lock = new ReentrantLock();</span><br><span class="line"><span class="comment">/** The array, accessed only via getArray/setArray. */</span></span><br><span class="line"><span class="comment">// 2、存取数据的volatile数组</span></span><br><span class="line">private transient volatile Object[] array;</span><br></pre></td></tr></table></figure>

<p>3、添加元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 3、添加元素</span><br><span class="line"> public boolean add(E e) &#123;</span><br><span class="line">        final ReentrantLock lock &#x3D; this.lock;                       &#x2F;&#x2F; 获取独占锁</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            Object[] elements &#x3D; getArray();</span><br><span class="line">            int len &#x3D; elements.length;</span><br><span class="line">            Object[] newElements &#x3D; Arrays.copyOf(elements, len + 1);&#x2F;&#x2F; 重新生成一个新的数组实例，并将原始数组的元素拷贝到新数组中</span><br><span class="line">            newElements[len] &#x3D; e;                                   &#x2F;&#x2F; 添加新的元素到新数组的末尾</span><br><span class="line">            setArray(newElements);                                  &#x2F;&#x2F; 更新底层数组</span><br><span class="line">            return true;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>有两点必须清楚：<br>     * 第一，在”添加操作“开始前，获取独占锁(lock)，若此时有需要线程要获取锁，则必须等待；在操作完毕后，释放独占锁(lock)，此时其它线程才能获取锁。通过独占锁，来防止多线程同时修改数据！此时还是可以读取，只是读取的是原来的数组。这段时间内，难道不发生安全问题吗？<br>    * 第二，操作完毕时，会通过setArray()来更新volatile数组。对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入；这样，每次添加元素之后，其它线程都能看到新添加的元素。</p>
<p>4、删除数据<br>remove数据和add类似，也是复制副本</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">public E remove(int index) &#123;  </span><br><span class="line">    final ReentrantLock lock = this.lock;  </span><br><span class="line">    lock.lock();  </span><br><span class="line">    try &#123;  </span><br><span class="line">        Object[] elements = getArray();  </span><br><span class="line">        int len = elements.length;  </span><br><span class="line">        E oldValue = get(elements, index); // 获取volatile数组中指定索引处的元素值  </span><br><span class="line">        int numMoved = len - index - 1;  </span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>) <span class="comment">// 如果被删除的是最后一个元素，则直接通过Arrays.copyOf()进行处理，而不需要新建数组  </span></span><br><span class="line">            setArray(Arrays.copyOf(elements, len - 1));  </span><br><span class="line">        <span class="keyword">else</span> &#123;  </span><br><span class="line">            Object[] newElements = new Object[len - 1];  </span><br><span class="line">            System.arraycopy(elements, 0, newElements, 0, index);    // 拷贝删除元素前半部分数据到新数组中  </span><br><span class="line">            System.arraycopy(elements, index + 1, newElements, index, numMoved);// 拷贝删除元素后半部分数据到新数组中  </span><br><span class="line">            setArray(newElements); // 更新volatile数组  </span><br><span class="line">        &#125;  </span><br><span class="line">        return oldValue;  </span><br><span class="line">    &#125; finally &#123;  </span><br><span class="line">        lock.unlock();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>5、读取数据<br>将底层volatile数组指定索引处的元素返回即可。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">        return get(getArray(), index);</span><br><span class="line">    &#125;</span><br><span class="line">private E get(Object[] <span class="selector-tag">a</span>, int index) &#123;</span><br><span class="line">        return (E) a[index];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>6、遍历元素</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">    return new COWIterator&lt;E&gt;(getArray(), 0);</span><br><span class="line">&#125;</span><br><span class="line">public ListIterator&lt;E&gt; listIterator() &#123;</span><br><span class="line">    return new COWIterator&lt;E&gt;(getArray(), 0);</span><br><span class="line">&#125;</span><br><span class="line">public ListIterator&lt;E&gt; listIterator(final int index) &#123;</span><br><span class="line">    Object[] elements = getArray();</span><br><span class="line">    int len = elements.length;</span><br><span class="line">    if (index&lt;0 || index&gt;len)</span><br><span class="line">        throw new IndexOutOfBoundsException("Index: "+index);</span><br><span class="line"></span><br><span class="line">    return new COWIterator&lt;E&gt;(elements, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static class COWIterator&lt;E&gt; implements ListIterator&lt;E&gt; &#123;</span><br><span class="line">    private final Object[] snapshot; // 保存数组的快照，是一个不可变的对象</span><br><span class="line">    private int <span class="attribute">cursor</span>;</span><br><span class="line"></span><br><span class="line">    private COWIterator(Object[] elements, int initialCursor) &#123;</span><br><span class="line">        <span class="attribute">cursor</span> = initialCursor;</span><br><span class="line">        snapshot = elements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        return cursor &lt; snapshot.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean hasPrevious() &#123;</span><br><span class="line">        return <span class="attribute">cursor</span> &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">    public E next() &#123;</span><br><span class="line">        <span class="keyword">if</span> (! hasNext())</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        return (E) snapshot[<span class="attribute">cursor</span>++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">    public E previous() &#123;</span><br><span class="line">        <span class="keyword">if</span> (! hasPrevious())</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        return (E) snapshot[--<span class="attribute">cursor</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int nextIndex() &#123;</span><br><span class="line">        return <span class="attribute">cursor</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int previousIndex() &#123;</span><br><span class="line">        return <span class="attribute">cursor</span>-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    public void remove() &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    public void set(E e) &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    public void add(E e) &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上容器的迭代器中会保存一个不可变的Object数组对象，那么在进行遍历这个对象时就不需要再进一步的同步。在每次修改时，都会创建并重新发布一个新的窗口副本，从而实现了可变性。如上迭代器代码中保留了一个指向volatile数组的引用，由于不会被修改，因此多个线程可以同时对它进行迭代，而不会彼此干扰或与修改容器的线程相互干扰。<br>与之前的ArrayList实现相比，CopyOnWriteArrayList返回迭代器不会抛出ConcurrentModificationException异常，即它不是fail-fast机制的！</p>
<p>三、CopyOnWrite的应用场景<br>CopyOnWrite并发容器用于读多写少的并发场景。比如缓存；白名单，黑名单，商品类目的访问和更新场景，假如我们有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索内容，但是某些关键字不允许被搜索。这些不能被搜索的关键字会被放在一个黑名单当中，黑名单每天晚上更新一次。当用户搜索时，会检查当前关键字在不在黑名单当中，如果在，则提示不能搜索。</p>
<p>使用CopyOnWriteMap需要注意两件事情：</p>
<pre><code>* 1. 减少扩容开销。根据实际需要，初始化CopyOnWriteMap的大小，避免写时CopyOnWriteMap扩容的开销。

* 2. 使用批量添加。因为每次添加，容器每次都会进行复制，所以减少添加次数，可以减少容器的复制次数。如使用上面代码里的addBlackList方法。</code></pre><p>CopyOnWrite的缺点：CopyOnWrite容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要注意一下。<br>    * 内存占用问题。因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的Yong GC和Full GC。之前我们系统中使用了一个服务由于每晚使用CopyOnWrite机制更新大对象，造成了每晚15秒的Full GC，应用响应时间也随之变长。针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，如ConcurrentHashMap。<br>    * 数据一致性问题/最终一致。CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。即只能保证数据的最终一致性，而不能保证实时一致。最终一致对于分布式系统也非常重要，它通过容忍一定时间的数据不一致，提升整个分布式系统的可用性与分区容错性。当然，最终一致并不是任何场景都适用的，像火车站售票这种系统用户对于数据的实时性要求非常非常高，就必须做成强一致性的。</p>
<p>链接：<a href="https://www.nowcoder.com/questionTerminal/95e4f9fa513c4ef5bd6344cc3819d3f7" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/95e4f9fa513c4ef5bd6344cc3819d3f7</a><br>来源：牛客网</p>
<p><strong>补充：</strong><br>一：快速失败（fail—fast）</p>
<ul>
<li>在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception。</li>
<li>原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</li>
<li>注意：这里异常的抛出条件是检测到 modCount！=expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。</li>
<li>场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。</li>
</ul>
<p>二：安全失败（fail—safe）(克隆容器Copy)</p>
<ul>
<li>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</li>
<li>原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。</li>
<li>场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</li>
</ul>
<p><a href="https://blog.csdn.net/mazhimazh/article/details/19210547" target="_blank" rel="noopener">Java 7之多线程并发容器 - CopyOnWriteArrayList</a><br><a href="https://blog.csdn.net/caomiao2006/article/details/53232687" target="_blank" rel="noopener">CopyOnWriteArrayList详解</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CopyOnWriteArrayList</tag>
        <tag>读写锁</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程实战10-多线程中的任务分解机制ForkJoinPool详解</title>
    <url>/2018/04/10/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9810-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%88%86%E8%A7%A3%E6%9C%BA%E5%88%B6ForkJoinPool%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p>Fork/Join 模式类似于MapReduce，也相当于一种分而治之的理念，或者说就像二分查找、二路归并算法。通过将一个大量的计算分解为许多的小计算，分而治之，然后再合并，同时，这些分出来的每个小计算都是并行进行的，这样就大大增大了CPU的利用率。</p>
</blockquote>
<p>Fork/Join 模式有自己的适用范围。如果一个应用能被分解成多个子任务，并且组合多个子任务的结果就能够获得最终的答案，那么这个应用就适合用 Fork/Join 模式来解决。图 1 给出了一个 Fork/Join 模式的示意图，位于图上部的 Task 依赖于位于其下的 Task 的执行，只有当所有的子任务都完成之后，调用者才能获得 Task 0 的返回结果。可以说，Fork/Join 模式能够解决很多种类的并行问题。通过使用 Doug Lea 提供的 Fork/Join 框架，软件开发人员只需要关注任务的划分和中间结果的组合就能充分利用并行平台的优良性能。其他和并行相关的诸多难于处理的问题，例如负载平衡、同步等，都可以由框架采用统一的方式解决。这样，我们就能够轻松地获得并行的好处而避免了并行编程的困难且容易出错的缺点。<br><img src="http://osiy4s0ad.bkt.clouddn.com/soundblog/1523368521354.jpg" alt="图 1. Fork/Join 模式示意图"></p>
<p>在多线程并发编程中，有时候会遇到将大任务分解成小任务再并发执行的场景。Java 8新增的ForkJoinPool很好的支持了这个问题。ForkJoinPool是一种支持任务分解的线程池，当提交给他的任务“过大”，他就会按照预先定义的规则将大任务分解成小任务，多线程并发执行。 一般要配合可分解任务接口ForkJoinTask来使用，ForkJoinTask有两个实现它的抽象类：RecursiveAction和RecursiveTask，其区别是前者没有返回值，后者有返回值。</p>
<ul>
<li><p>应用场景：<br>简单来说：如果你的问题能很容易分解成子问题，则比较适合ForkJoinPool。适合CPU密集型的场景。</p>
</li>
<li><p>实例：计算1+2+…+100;并行计算</p>
</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">package com.sound.daytc1;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.ExecutionException;</span><br><span class="line">import java.util.concurrent.ForkJoinPool;</span><br><span class="line">import java.util.concurrent.Future;</span><br><span class="line">import java.util.concurrent.RecursiveTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author: ZouTai</span></span><br><span class="line"><span class="comment"> * @date: 2018/4/10</span></span><br><span class="line"><span class="comment"> * @description: ForkJoin模式计算序列相加-二分法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public class RecursiveTaskDemo extends RecursiveTask&lt;Integer&gt; &#123;</span><br><span class="line">    private int first;</span><br><span class="line">    private int last;</span><br><span class="line"></span><br><span class="line">    public RecursiveTaskDemo(int first, int last) &#123;</span><br><span class="line">        this.first = first;</span><br><span class="line">        this.last = last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Integer compute() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + " ... ");</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这里面要写自己的划分逻辑</span></span><br><span class="line"><span class="comment">         * 构造ForkJoin</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        int sum = 0;</span><br><span class="line">        <span class="comment">// 拆分任务</span></span><br><span class="line">        <span class="keyword">if</span> (last - first &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 计算</span></span><br><span class="line">            for (int i = first; i &lt;= last; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 类似于分支递归思想</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            RecursiveTaskDemo demo01 = new RecursiveTaskDemo(first, (last + first) / 2);</span><br><span class="line">            RecursiveTaskDemo demo02 = new RecursiveTaskDemo((last + first) / 2 + 1, last);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行</span></span><br><span class="line">            demo01.fork();</span><br><span class="line">            demo02.fork();</span><br><span class="line"></span><br><span class="line">            Integer a = demo01.join();</span><br><span class="line">            Integer b = demo02.join();</span><br><span class="line"></span><br><span class="line">            sum = a + b;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ForkJoinPool forkJoinPool = new ForkJoinPool(3);</span><br><span class="line">        Future&lt;Integer&gt; future = forkJoinPool.submit(new RecursiveTaskDemo(1, 100));</span><br><span class="line">        System.out.println("处理其他程序...");</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println("计算的值为：" + future.get());</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-forkjoin/" target="_blank" rel="noopener">IBM-JDK 7 中的 Fork/Join 模式</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>ForkJoin</tag>
        <tag>并行计算</tag>
        <tag>任务分配</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程实战9-Java中的并发工具类</title>
    <url>/2018/04/10/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%989-Java%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    <content><![CDATA[<blockquote>
<p>在JDK的并发包里提供了几个非常有用的并发工具类。CountDownLatch、CyclicBarrier和Semaphore工具类提供了一种并发流程控制的手段，Exchanger工具类则提供了在线程间交换数据的一种手段。</p>
</blockquote>
<p>一、等待多线程完成的CountDownLatch</p>
<p>CountDownLatch允许一个或多个线程等待其他线程完成操作。<br>比如我们现在需要一个计算c=a+b总和的任务，但是其中a有a+10,且b有b+100;总和的计算需要等待a和b全部计算完成才能开始，所以需要等待。显然，最简单的方法，可以直接使用join方法来实现。如下：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">package com.sound.daytb4;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、join实现等待</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public class JoinCountDownLatchTest &#123;</span><br><span class="line">    int a = 1;</span><br><span class="line">    int b = 2;</span><br><span class="line">    int c = 0;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        JoinCountDownLatchTest demo = new JoinCountDownLatchTest();</span><br><span class="line">        Thread cal1 = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                demo.a = demo.a + 10;</span><br><span class="line">                System.out.println("计算第一部分，结果为a = "+demo.a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread cal2 = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                demo.b = demo.b + 100;</span><br><span class="line">                System.out.println("计算第二部分，结果为b = "+demo.b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        cal1.start();</span><br><span class="line">        cal2.start();</span><br><span class="line">        cal1.join();</span><br><span class="line">        cal2.join();</span><br><span class="line">        System.out.println("等待前两部分计算完...");</span><br><span class="line">        System.out.println("将第一部分和第二部分相加为，c = "+ (demo.a+demo.b));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     计算第一部分，结果为a = 11</span></span><br><span class="line"><span class="comment">     计算第二部分，结果为b = 102</span></span><br><span class="line"><span class="comment">     等待前两部分计算完...</span></span><br><span class="line"><span class="comment">     将第一部分和第二部分相加为，c = 113</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>CountDownLatch与join的区别</strong><br>但是，相对于join，CountDownLatch功能更多，或者说是更加灵活，可以在内部随时完成。<br>考虑一种情况，对于上面的逻辑，假如，函数中还有其他计算，但是这些计算不算影响c的计算，所以就需要提前唤醒c，而不需要再等待了。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">package com.sound.daytb4;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2、countDownLatch实现等待</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public class CountDownLatchTest &#123;</span><br><span class="line">    static CountDownLatch countDownLatch = new CountDownLatch(2);</span><br><span class="line">    int a = 1;</span><br><span class="line">    int b = 2;</span><br><span class="line">    int c = 0;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        CountDownLatchTest demo = new CountDownLatchTest();</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                demo.a = demo.a + 10;</span><br><span class="line">                System.out.println("计算第一部分，结果为a = "+demo.a);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                demo.b = demo.b + 100;</span><br><span class="line">                System.out.println("计算第二部分，结果为b = "+demo.b);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println("继续计算其他任务");</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println("等待前两部分计算完...");</span><br><span class="line">        System.out.println("将第一部分和第二部分相加为，c = "+ (demo.a+demo.b));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     计算第一部分，结果为a = 11</span></span><br><span class="line"><span class="comment">     计算第二部分，结果为b = 102</span></span><br><span class="line"><span class="comment">     等待前两部分计算完...</span></span><br><span class="line"><span class="comment">     将第一部分和第二部分相加为，c = 113</span></span><br><span class="line"><span class="comment">     继续计算其他任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>CountDownLatch内部逻辑</strong><br>CountDownLatch的构造函数接收一个int类型的参数作为计数器，如果你想等待N个点完<br>成，这里就传入N。<br>当我们调用CountDownLatch的countDown方法时，N就会减1，CountDownLatch的await方法<br>会阻塞当前线程，直到N变成零。由于countDown方法可以用在任何地方，所以这里说的N个<br>点，可以是N个线程，也可以是1个线程里的N个执行步骤。用在多个线程时，只需要把这个<br>CountDownLatch的引用传递到线程里即可。</p>
<p>二、同步/循环屏障CyclicBarrier</p>
<p>CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。<br>这相当于我们平时开会，屏障就相当于会议设置的固定人数和会议内容，每个人相当于一个线程，只有人到齐了，会议才会开始。<br>例子如下：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">package com.sound.daytb5;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line">public class CyclicBarrierDemo &#123;</span><br><span class="line"></span><br><span class="line">	public void meeting(CyclicBarrier barrier) &#123;</span><br><span class="line">		System.out.println(Thread.currentThread().getName() + " 到达会议室，等待开会..");</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(Thread.currentThread().getName().equals(<span class="string">"Thread-7"</span>)) &#123;</span><br><span class="line">			System.out.println("Thread-7 出车祸了，到不了了，会议将无法开始");</span><br><span class="line">			try &#123;</span><br><span class="line">				Thread.sleep(10000);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			barrier.reset();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			barrier.await();</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		CyclicBarrierDemo demo = new CyclicBarrierDemo();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 定义会议人数:10 和 内容run()&#123;&#125;</span></span><br><span class="line">		CyclicBarrier barrier = new CyclicBarrier(<span class="number">10</span>, new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				System.out.println("好！我们开始开会...");</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		for (int i = 0; i &lt; 12; i++) &#123;</span><br><span class="line">			new Thread(new Runnable() &#123;</span><br><span class="line">				@Override</span><br><span class="line">				public void run() &#123;</span><br><span class="line">					demo.meeting(barrier);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;).start();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 监控等待线程数</span></span><br><span class="line">		new Thread(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				while(true) &#123;</span><br><span class="line">					try &#123;</span><br><span class="line">						Thread.sleep(1000);</span><br><span class="line">					&#125; catch (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					System.out.println("等待的线程数 " + barrier.getNumberWaiting());</span><br><span class="line">					System.out.println("屏障是否损坏or异常？ " + barrier.isBroken());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二.1、CyclicBarrier和CountDownLatch的区别<br>CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置。所以CyclicBarrier能处理更为复杂的业务场景。例如，如果计算发生错误，可以重置计数器，并让线程重新执行一次。</p>
<p>三、控制并发线程数的Semaphore<br>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。<br>把它比作是控制流量的红绿灯。比如××马路要限制流量，只允许同时有一百辆车在这条路上行使，其他的都必须在路口等待，所以前一百辆车会看到绿灯，可以开进这条马路，后面的车会看到红灯，不能驶入××马路，但是如果前一百辆中有5辆车已经离开了××马路，那么后面就允许有5辆车驶入马路，这个例子里说的车就是线程，驶入马路就表示线程在执行，离开马路就表示线程执行完成，看见红灯就表示线程被阻塞，不能执行。<br>    * 应用场景：Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，就可以使用Semaphore来做流量控制。如下：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">package com.sound.daytb5;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line">public class SemaphoreTest &#123;</span><br><span class="line">    private static final int THREAD_COUNT = 30;</span><br><span class="line">    private static ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);</span><br><span class="line">    private static Semaphore s = new Semaphore(10);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i = 0; i &lt; THREAD_COUNT; i++) &#123;</span><br><span class="line">            threadPool.execute(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        s.acquire();</span><br><span class="line">                        System.out.println("save data");</span><br><span class="line">                        s.release();</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>与线程池的区别</strong><br>在上面的代码中，我们其实可以直接创建一个大小为10的线程池，这样不就好了吗？其实这两个东西完全不一样。即Semaphore是为了解决资源共享冲突的并发数目，而线程池只是一个线程池，池子里的线程并不一定是资源冲突的。就相当于，线程池是一个家，家里有猫、有狗、有猪，但是猫和猪并不会因为吃的东西而打架，它两吃的食物不一样。但是，同一个猪圈的猪却不同了，猪圈就相当于Semaphore信号量，它们都是吃一个槽里的食物，当然会打起来，所以就需要并发控制，比如，由于资源有限，一个猪圈里面只有10个槽，所以，每个猪圈就限制只能住10头猪，等这些猪长大了杀了（线程死亡），其他猪才能再进来。</p>
<ul>
<li>四、线程间交换数据的Exchanger<br>Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。<ul>
<li>Exchanger的应用场景：<ul>
<li>Exchanger可以用于遗传算法，遗传算法里需要选出两个人作为交配对象，这时候会交换两人的数据，并使用交叉规则得出2个交配结果。</li>
<li>Exchanger也可以用于校对工作，比如我们需要将纸制银行流水通过人工的方式录入成电子银行流水，为了避免错误，采用AB岗两人进行录入，录入到Excel之后，系统需要加载这两个Excel，并对两个Excel数据进行校对，看看是否录入一致。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">package com.sound.daytb5;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.Exchanger;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">public class ExchangerTest &#123;</span><br><span class="line">    private static final Exchanger&lt;String&gt; exgr = new Exchanger&lt;String&gt;();</span><br><span class="line">    private static ExecutorService threadPool = Executors.newFixedThreadPool(2);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        threadPool.execute(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println("银行流水A开始执行...");</span><br><span class="line">                    String A = "银行流水A"; // A录入银行流水数据</span><br><span class="line">                    exgr.exchange(A);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadPool.execute(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println("银行流水B开始执行...");</span><br><span class="line">                    String B = "银行流水B";// B录入银行流水数据</span><br><span class="line">                    String A = exgr.exchange("B");</span><br><span class="line">                    System<span class="selector-class">.out</span>.println(<span class="string">"A和B数据是否一致："</span> + A.equals(B) + <span class="string">"，A录入的是："</span></span><br><span class="line">                            + A + "，B录入是：" + B);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CountDownLatch</tag>
        <tag>CyclicBarrier</tag>
        <tag>Semaphore</tag>
        <tag>Exchanger</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程实战8-ThreadLocal原理与使用-线程局部变量</title>
    <url>/2018/04/10/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%988-ThreadLocal%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%BF%E7%94%A8-%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<blockquote>
<p>首先，我的理解，ThreadLocal只是一个公用对象，但是并不是完全用来作为线程之间共享的。原因在于，它只是一种公用变量模板，每个线程只是拥有它的复制版（线程死亡后，复制版也随之死亡），而不是直接使用公用变量，这样就避免了共享安全问题。但是，为什么不让每个线程直接去创建自己的实例变量呢？主要是因为，线程进来时它自己可能并不清楚需要哪些变量，而且在线程执行完毕，还需要自己去销毁这些变量，下的太繁杂。</p>
</blockquote>
<p>举个例子：当我去吃火锅时（我就是一个线程），餐厅都会有一个菜单纸（ThreadLocal）。没有使用ThreadLocal之前，我们和其他客人公用一张菜单纸，这当然是不符合逻辑的，所以，餐厅需要给我复制一份，我就可以在上面选菜了（菜单-账单就相当于：ThreadLocal-value，即ThreadLocalMap（key-value））。当我就餐结束，结账后（线程结束），我的菜单也就作废了（此时垃圾回收）。即线程公用一张ThreadLocal，但是并不直接使用那个共用的ThreadLocal，而是自己复制一份ThreadLocal，使用完后，这个复制版也就没用了。</p>
<p>为了严谨，下文综合其他解释：</p>
<p>jdk1.8源码解释：ThreadLocal类用来提供线程内部的局部变量。这种变量在多线程环境下访问(通过get或set方法访问)时能保证各个线程里的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是private static类型的，用于关联线程和线程的上下文。<br>    * 之所以使用static是因为ThreadLocal是ThreadLocalMap的key的弱引用，当没有强引用指向ThreadLocal，gc时就会被回收，而此时key将为null。</p>
<ul>
<li>一、实例应用：</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">package com.sound.daytb3;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author: ZouTai</span></span><br><span class="line"><span class="comment"> * @date: 2018/4/10</span></span><br><span class="line"><span class="comment"> * @description: ThreadLOcal-线程局部变量</span></span><br><span class="line"><span class="comment"> * 即，每个线程将维护一个自己的变量，这个变量只对当前线程可以随意更改，其他线程不会影响当前线程变量的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public class ThreadLocalDemo &#123;</span><br><span class="line">    private static ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;Integer&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected Integer initialValue() &#123;</span><br><span class="line">            <span class="comment">// 初始化值为0</span></span><br><span class="line">            return new Integer(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public int getNext() &#123;</span><br><span class="line">        int count = threadLocal.get();</span><br><span class="line">        count++;</span><br><span class="line">        threadLocal.set(count);</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ThreadLocalDemo tld = new ThreadLocalDemo();</span><br><span class="line">        new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + "" + tld.getNext());</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(1000);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + "" + tld.getNext());</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(500);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>二、源码解析：几个重要的方法get、set、remove</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**1、</span></span><br><span class="line"><span class="comment">     * initialValue函数用来设置ThreadLocal的初始值</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    private static ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;Integer&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected Integer initialValue() &#123;</span><br><span class="line">            <span class="comment">// 初始化值为0</span></span><br><span class="line">            return new Integer(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**2、</span></span><br><span class="line"><span class="comment">     * 该函数用来获取与当前线程关联的ThreadLocal的值</span></span><br><span class="line"><span class="comment">     * 如果当前线程没有该ThreadLocal的值，则调用initialValue函数获取初始值返回。</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public T get() &#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocal.ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != null) &#123;</span><br><span class="line">            ThreadLocal.ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class="line">            <span class="keyword">if</span> (e != null) &#123;</span><br><span class="line">                @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">                T result = (T)e.value;</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return setInitialValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**3、</span></span><br><span class="line"><span class="comment">     * 设置当前线程的ThreadLocal的值为value。</span></span><br><span class="line"><span class="comment">     * @param value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public void set(T value) &#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocal.ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != null)</span><br><span class="line">            map.set(this, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**4、</span></span><br><span class="line"><span class="comment">     * remove函数用来将当前线程的ThreadLocal绑定的值删除</span></span><br><span class="line"><span class="comment">     * 在某些情况下需要手动调用该函数，防止内存泄露。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public void remove() &#123;</span><br><span class="line">        ThreadLocal.ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">        <span class="keyword">if</span> (m != null)</span><br><span class="line">            m.remove(this);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>三、ThreadLocal内部的实现原理-原理改进<ul>
<li>我们知道ThreadLocal内部使用的是map，map有三个点（map节点node和两个分支key-value），这里面，我们也是有三个属性（当前线程Thread、ThreadLocal变量和变量值value）。显然，变量值就对应value；但是node和key分别对应什么？</li>
<li>早期的版本中，1.3之前，jdk将当前线程Thread作为key，ThreadLocal作为node。之后，更改为Thread作为node，ThreadLocal作为key。之所以这样做有以下两个好处：<ul>
<li>1.减少map节点，能提高性能：由于实际很多时候，线程很多，但是ThreadLocal变量其实很少。这样设计之后每个Map的Entry数量变小了：之前是Thread的数量，现在是ThreadLocal的数量。</li>
<li>2.减少内存使用量：当Thread销毁之后对应的ThreadLocalMap也就随之销毁了。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>四、内存泄露问题<br>引起内存泄露的主要问题是由于ThreadLocalMap的key使用了对ThreadLocal的弱引用导致的。<ul>
<li>ThreadLocalMap是使用ThreadLocal的弱引用作为Key的</li>
<li>ThreadLocal中的引用对象如下图：<br><img src="http://osiy4s0ad.bkt.clouddn.com/soundblog/1523352180650.jpg" alt="引用图"></li>
<li>内存泄露问题：如图，ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么系统gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：<code>ThreadLocal Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</code>永远无法回收，造成内存泄露。</li>
</ul>
</li>
</ul>
<p><strong>为什么要使用弱引用？直接使用强引用不就可以了吗？</strong><br>其实强引用将导致另外一种内存泄漏问题。即ThreadLocal引用为null，导师线程却没有回收，将用于持有ThreadLocal的强引用，无法回收，这也会导致内存泄漏。比如使用线程池的时候，线程结束是不会销毁的，会再次使用的。就可能出现内存泄露。　　</p>
<p><strong>内存泄漏的防护措施</strong></p>
<blockquote>
<p>源码内部会检查ThreaLocalMap，会将key为null的entry都进行删除<br>转载：整理一下ThreadLocalMap的getEntry函数的流程：<br>    * 1、首先从ThreadLocal的直接索引位置(通过ThreadLocal.threadLocalHashCode &amp; (len-1)运算得到)获取Entry e，如果e不为null并且key相同则返回e；<br>    * 2、如果e为null或者key不一致则向下一个位置查询，如果下一个位置的key和当前需要查询的key相等，则返回对应的Entry，否则，如果key值为null，则擦除该位置的Entry，否则继续向下一个位置查询<br>    * 在这个过程中遇到的key为null的Entry都会被擦除，那么Entry内的value也就没有强引用链，自然会被回收。仔细研究代码可以发现，set操作也有类似的思想，将key为null的这些Entry都删除，防止内存泄露。 但是光这样还是不够的，上面的设计思路依赖一个前提条件：要调用ThreadLocalMap的genEntry函数或者set函数。这当然是不可能任何情况都成立的，所以很多情况下需要使用者手动调用ThreadLocal的remove函数，手动删除不再需要的ThreadLocal，防止内存泄露。所以JDK建议将ThreadLocal变量定义成private static的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露。</p>
</blockquote>
<p>参考链接：<a href="https://zhuanlan.zhihu.com/p/20213204" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/20213204</a><br><a href="http://www.sczyh30.com/posts/Java/java-concurrent-threadlocal/" target="_blank" rel="noopener">http://www.sczyh30.com/posts/Java/java-concurrent-threadlocal/</a><br><a href="https://www.cnblogs.com/onlywujun/p/3524675.html" target="_blank" rel="noopener">https://www.cnblogs.com/onlywujun/p/3524675.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>ThreadLocal</tag>
        <tag>弱引用</tag>
        <tag>ThreadLocalMap</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程实战7-线程之间的通信2-join阻塞线程</title>
    <url>/2018/04/10/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%987-%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A12-join%E5%8A%A0%E5%A1%9E%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>thread.Join把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。比如在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B。</p>
</blockquote>
<p>t.join();      //使调用线程 t 在此之前执行完毕。<br>t.join(1000);  //等待 t 线程，等待时间是1000毫秒</p>
<ul>
<li><p>一、为什么要用join()方法：<br>在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。</p>
<ul>
<li>join()的作用是：“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行。</li>
</ul>
</li>
<li><p>二、实例：</p>
</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author: ZouTai</span></span><br><span class="line"><span class="comment"> * @date: 2018/4/10</span></span><br><span class="line"><span class="comment"> * @description: join-加塞线程，即，向线程加入内部线程，且内部线程，执行完，主线程才能继续。</span></span><br><span class="line"><span class="comment"> * 相当于将加塞线程合并入主线程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public class JoinDemo01 &#123;</span><br><span class="line">    public void a(Thread joinThread)&#123;</span><br><span class="line">        System.out.println("线程a开始...");</span><br><span class="line">        joinThread.start();</span><br><span class="line">        try &#123;</span><br><span class="line">            joinThread.join();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println("线程a执行完毕");</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void b() &#123;</span><br><span class="line">        System.out.println("加塞线程开始执行...");</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println("加塞线程执行完毕");</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        JoinDemo01 joinDemo01 = new JoinDemo01();</span><br><span class="line">        Thread jThread = new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                joinDemo01.b();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        joinDemo01.a(jThread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** result is :</span></span><br><span class="line"><span class="comment">     线程a开始...</span></span><br><span class="line"><span class="comment">     加塞线程开始执行...</span></span><br><span class="line"><span class="comment">     加塞线程执行完毕</span></span><br><span class="line"><span class="comment">     线程a执行完毕</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>三、源码解析</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// join方法：注意isAlive和wait对象线程的区别，不同</span></span><br><span class="line"><span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">            while (isAlive()) &#123; <span class="comment">// 1、判断当前线程是否存货（即加塞线程）</span></span><br><span class="line">                wait(0); // 2、使wait监视器对象线程等待（即主线程）；为什么1、2对象不同，需要了解wait方法，如下</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">		</span><br><span class="line">* This method should only be called by a thread that is the owner</span><br><span class="line">* of this object's monitor. </span><br><span class="line">* 即wait方法是被当前线程的监视器调用，即当前运行的线程，即上面的主线程</span><br><span class="line">* 监视器：即当前运行方法join所在的线程，而不是调用join方法的线程对象joinThread；而isAlive方法才是指的isAlive对象</span><br><span class="line">public final native void wait(long timeout) throws InterruptedException;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>join</tag>
        <tag>阻塞线程</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程实战6-线程之间的通信-深入解析Condition源码</title>
    <url>/2018/04/10/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%986-%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1-%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Condition%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<ul>
<li><p>Object类的几个方法</p>
<ul>
<li>notify方法：只会随机唤醒一个wait线程，然后此wait线程将会继续执行 </li>
<li>notifyAll方法：会唤醒所有的wait线程，所有wait线程将会全部执行</li>
</ul>
</li>
<li><p>显示锁的condition对象</p>
<ul>
<li>对于Object类的wait和notify方法有一定的缺陷，即无法精确唤醒指定的线程。所以引入了lock的condition对象，可以对不同的条件进行判断，来选择唤醒不同的线程<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author: ZouTai</span></span><br><span class="line"><span class="comment"> * @date: 2018/4/9</span></span><br><span class="line"><span class="comment"> * @description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public class ConditionBoundedBuffer &#123;</span><br><span class="line">    private Lock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里使用生产者-消费者模式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    private Condition product = lock.newCondition();</span><br><span class="line">    private Condition consume = lock.newCondition();</span><br><span class="line">    private final int max = 10;</span><br><span class="line">    int count = 0;</span><br><span class="line"></span><br><span class="line">    public void put() throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count &gt;= max) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+"生产过量，停止生产...");</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 1、生产过量，停止生产：生产者等待</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                product.await();</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 2、唤醒消费者</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            consume.signal();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+"生产-库存变为："+count);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public void take() throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+"库存为空，无法购买...");</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 3、库存为空，无法购买：消费者等待</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                consume.await();</span><br><span class="line">            &#125;</span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+"消费-库存还剩："+count);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 4、唤醒生产者</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            product.signal();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>condition源码解析：<a href="https://blog.csdn.net/u010412719/article/details/52089561" target="_blank" rel="noopener">参考博客</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>线程通信</tag>
        <tag>Condition</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程实战5-Java中的读写锁ReentrantReadWriteLock(转载)</title>
    <url>/2018/04/10/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%985-Java%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock/</url>
    <content><![CDATA[<ul>
<li>并发安全问题主要是出现在写的情况下，而读取数据并不影响数据的结果；另外，大高并发的情况下，大多数都是数据的读取，写操作是很少的，所以可以将数据的读写进行分离，将大大提高运行效率。</li>
<li>读写锁又叫做共享锁和排它锁，即读取是线程共享的：可以多个线程一起读取，但是不能被写；写入是排他性的，只能有一个线程进行操作：既不能被读取，也不能被其他线程写入。三种：读读不互斥，读写互斥，写写互斥。</li>
</ul>
<div class="post_content">
      <p><a title="原文链接" href="http://tutorials.jenkov.com/java-concurrency/read-write-locks.html" target="_blank">原文链接</a> <b>作者：</b>Jakob Jenkov <b>译者：</b>微凉 <b>校对：</b>丁一</p>
<p>
相比<a href="http://ifeve.com/locks/" target="_blank">Java中的锁(Locks in Java)</a>里Lock实现，读写锁更复杂一些。假设你的程序中涉及到对一些共享资源的读和写操作，且写操作没有读操作那么频繁。在没有写操作的时候，两个线程同时读一个资源没有任何问题，所以应该允许多个线程能在同时读取共享资源。但是如果有一个线程想去写这些共享资源，就不应该再有其它线程对该资源进行读或写（<i>译者注：也就是说：读-读能共存，读-写不能共存，写-写不能共存</i>）。这就需要一个读/写锁来解决这个问题。
</p>
<p>
Java5在java.util.concurrent包中已经包含了读写锁。尽管如此，我们还是应该了解其实现背后的原理。
</p>
<p>
以下是本文的主题
</p>
<ol>
<li><a href="#simple">读/写锁的Java实现(Read / Write Lock Java Implementation)</a><a></a></li>
<li><a href="#reentrance">读/写锁的重入(Read / Write Lock Reentrance)</a><a></a></li>
<li><a href="#readreentrance">读锁重入(Read Reentrance)</a><a></a></li>
<li><a href="#writereentrance">写锁重入(Write Reentrance)</a><a></a></li>
<li><a href="#upgrade">读锁升级到写锁(Read to Write Reentrance)</a><a></a></li>
<li><a href="#downgrade">写锁降级到读锁(Write to Read Reentrance)</a><a></a></li>
<li><a href="#full">可重入的ReadWriteLock的完整实现(Fully Reentrant ReadWriteLock)</a><a></a></li>
<li><a href="#finally">在finally中调用unlock() (Calling unlock() from a finally-clause)</a><a></a></li>
</ol>
<p><span id="more-3913"></span></p>
<h4 id="simple">读/写锁的Java实现</h4>
<p>
先让我们对读写访问资源的条件做个概述：
</p>
<p>
<b>读取</b> 没有线程正在做写操作，且没有线程在请求写操作。
</p>
<p>
<b>写入</b> 没有线程正在做读写操作。
</p>
<p>
如果某个线程想要读取资源，只要没有线程正在对该资源进行写操作且没有线程请求对该资源的写操作即可。我们假设对写操作的请求比对读操作的请求更重要，就要提升写请求的优先级。此外，如果读操作发生的比较频繁，我们又没有提升写操作的优先级，那么就会产生“饥饿”现象。请求写操作的线程会一直阻塞，直到所有的读线程都从ReadWriteLock上解锁了。如果一直保证新线程的读操作权限，那么等待写操作的线程就会一直阻塞下去，结果就是发生“饥饿”。因此，只有当没有线程正在锁住ReadWriteLock进行写操作，且没有线程请求该锁准备执行写操作时，才能保证读操作继续。
</p>
<p>
当其它线程没有对共享资源进行读操作或者写操作时，某个线程就有可能获得该共享资源的写锁，进而对共享资源进行写操作。有多少线程请求了写锁以及以何种顺序请求写锁并不重要，除非你想保证写锁请求的公平性。
</p>
<p>
按照上面的叙述，简单的实现出一个读/写锁，代码如下
</p>
<div id="highlighter_527527" class="syntaxhighlighter  "><div class="bar "><div class="toolbar"><a href="#viewSource" title="view source" class="item viewSource" style="width: 16px; height: 16px;">view source</a><div class="item copyToClipboard"><embed width="16" height="16" id="highlighter_527527_clipboard" type="application/x-shockwave-flash" title="copy to clipboard" allowscriptaccess="always" wmode="transparent" flashvars="highlighterId=highlighter_527527" menu="false" src="http://ifeve.com/wp-content/plugins/syntaxhighlighter/syntaxhighlighter2/scripts/clipboard.swf"></div><a href="#printSource" title="print" class="item printSource" style="width: 16px; height: 16px;">print</a><a href="#about" title="?" class="item about" style="width: 16px; height: 16px;">?</a></div></div><div class="lines"><div class="line alt1"><table><tbody><tr><td class="number"><code>01</code></td><td class="content"><code class="keyword">public</code> <code class="keyword">class</code> <code class="plain">ReadWriteLock{</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>02</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">int</code> <code class="plain">readers = </code><code class="value">0</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>03</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">int</code> <code class="plain">writers = </code><code class="value">0</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>04</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">int</code> <code class="plain">writeRequests = </code><code class="value">0</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>05</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>06</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">public</code> <code class="keyword">synchronized</code> <code class="keyword">void</code> <code class="plain">lockRead() </code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>07</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">throws</code> <code class="plain">InterruptedException{</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>08</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">while</code><code class="plain">(writers &gt; </code><code class="value">0</code> <code class="plain">|| writeRequests &gt; </code><code class="value">0</code><code class="plain">){</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>09</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">wait();</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>10</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>11</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">readers++;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>12</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>13</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>14</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">public</code> <code class="keyword">synchronized</code> <code class="keyword">void</code> <code class="plain">unlockRead(){</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>15</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">readers--;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>16</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">notifyAll();</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>17</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>18</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>19</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">public</code> <code class="keyword">synchronized</code> <code class="keyword">void</code> <code class="plain">lockWrite() </code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>20</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">throws</code> <code class="plain">InterruptedException{</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>21</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">writeRequests++;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>22</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>23</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">while</code><code class="plain">(readers &gt; </code><code class="value">0</code> <code class="plain">|| writers &gt; </code><code class="value">0</code><code class="plain">){</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>24</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">wait();</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>25</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>26</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">writeRequests--;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>27</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">writers++;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>28</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>29</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>30</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">public</code> <code class="keyword">synchronized</code> <code class="keyword">void</code> <code class="plain">unlockWrite() </code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>31</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">throws</code> <code class="plain">InterruptedException{</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>32</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">writers--;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>33</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">notifyAll();</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>34</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>35</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div></div></div>
<p>
ReadWriteLock类中，读锁和写锁各有一个获取锁和释放锁的方法。
</p>
<p>
读锁的实现在lockRead()中,只要没有线程拥有写锁（writers==0），且没有线程在请求写锁（writeRequests ==0），所有想获得读锁的线程都能成功获取。
</p>
<p>
写锁的实现在lockWrite()中,当一个线程想获得写锁的时候，首先会把写锁请求数加1（writeRequests++），然后再去判断是否能够真能获得写锁，当没有线程持有读锁（readers==0 ）,且没有线程持有写锁（writers==0）时就能获得写锁。有多少线程在请求写锁并无关系。
</p><div class="google-auto-placed ap_container" style="text-align: center; width: 100%; height: auto; clear: none;"><ins data-ad-format="auto" class="adsbygoogle" data-ad-client="ca-pub-9394337417063147" data-adsbygoogle-status="done" style="display: block; margin: auto; background-color: transparent;"><ins id="aswift_4_expand" style="display:inline-table;border:none;height:197px;margin:0;padding:0;position:relative;visibility:visible;width:785px;background-color:transparent;"><ins id="aswift_4_anchor" style="display:block;border:none;height:197px;margin:0;padding:0;position:relative;visibility:visible;width:785px;background-color:transparent;"><iframe width="785" height="197" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_4" name="aswift_4" style="left:0;position:absolute;top:0;width:785px;height:197px;"></iframe></ins></ins></ins></div>
<p>
需要注意的是，在两个释放锁的方法（unlockRead，unlockWrite）中，都调用了notifyAll方法，而不是notify。要解释这个原因，我们可以想象下面一种情形：
</p>
<p>
如果有线程在等待获取读锁，同时又有线程在等待获取写锁。如果这时其中一个等待读锁的线程被notify方法唤醒，但因为此时仍有请求写锁的线程存在（writeRequests&gt;0），所以被唤醒的线程会再次进入阻塞状态。然而，等待写锁的线程一个也没被唤醒，就像什么也没发生过一样（<i>译者注：信号丢失现象</i>）。如果用的是notifyAll方法，所有的线程都会被唤醒，然后判断能否获得其请求的锁。
</p>
<p>
用notifyAll还有一个好处。如果有多个读线程在等待读锁且没有线程在等待写锁时，调用unlockWrite()后，所有等待读锁的线程都能立马成功获取读锁 —— 而不是一次只允许一个。
</p>
<h4 id="reentrance">读/写锁的重入</h4>
<p>
上面实现的读/写锁(ReadWriteLock) 是不可重入的，当一个已经持有写锁的线程再次请求写锁时，就会被阻塞。原因是已经有一个写线程了——就是它自己。此外，考虑下面的例子：
</p>
<ol>
<li>Thread 1 获得了读锁</li>
<li>Thread 2 请求写锁，但因为Thread 1 持有了读锁，所以写锁请求被阻塞。</li>
<li>Thread 1 再想请求一次读锁，但因为Thread 2处于请求写锁的状态，所以想再次获取读锁也会被阻塞。</li>
</ol>
<p>
上面这种情形使用前面的ReadWriteLock就会被锁定——一种类似于死锁的情形。不会再有线程能够成功获取读锁或写锁了。
</p>
<p>
为了让ReadWriteLock可重入，需要对它做一些改进。下面会分别处理读锁的重入和写锁的重入。
</p>
<h4 id="readreentrance">读锁重入</h4>
<p>
为了让ReadWriteLock的读锁可重入，我们要先为读锁重入建立规则：
</p>
<ul>
<li>
要保证某个线程中的读锁可重入，要么满足获取读锁的条件（没有写或写请求），要么已经持有读锁（不管是否有写请求）。
</li>
</ul>
<p>
要确定一个线程是否已经持有读锁，可以用一个map来存储已经持有读锁的线程以及对应线程获取读锁的次数，当需要判断某个线程能否获得读锁时，就利用map中存储的数据进行判断。下面是方法lockRead和unlockRead修改后的的代码：
</p>
<div id="highlighter_115426" class="syntaxhighlighter  "><div class="bar    "><div class="toolbar"><a href="#viewSource" title="view source" class="item viewSource" style="width: 16px; height: 16px;">view source</a><div class="item copyToClipboard"><embed width="16" height="16" id="highlighter_115426_clipboard" type="application/x-shockwave-flash" title="copy to clipboard" allowscriptaccess="always" wmode="transparent" flashvars="highlighterId=highlighter_115426" menu="false" src="http://ifeve.com/wp-content/plugins/syntaxhighlighter/syntaxhighlighter2/scripts/clipboard.swf"></div><a href="#printSource" title="print" class="item printSource" style="width: 16px; height: 16px;">print</a><a href="#about" title="?" class="item about" style="width: 16px; height: 16px;">?</a></div></div><div class="lines"><div class="line alt1"><table><tbody><tr><td class="number"><code>01</code></td><td class="content"><code class="keyword">public</code> <code class="keyword">class</code> <code class="plain">ReadWriteLock{</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>02</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="plain">Map&lt;Thread, Integer&gt; readingThreads =</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>03</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">new</code> <code class="plain">HashMap&lt;Thread, Integer&gt;();</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>04</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>05</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">int</code> <code class="plain">writers = </code><code class="value">0</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>06</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">int</code> <code class="plain">writeRequests = </code><code class="value">0</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>07</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>08</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">public</code> <code class="keyword">synchronized</code> <code class="keyword">void</code> <code class="plain">lockRead() </code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>09</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">throws</code> <code class="plain">InterruptedException{</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>10</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">Thread callingThread = Thread.currentThread();</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>11</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">while</code><code class="plain">(! canGrantReadAccess(callingThread)){</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>12</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">wait();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>13</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>14</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>15</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">readingThreads.put(callingThread,</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>16</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">(getAccessCount(callingThread) + </code><code class="value">1</code><code class="plain">));</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>17</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>18</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>19</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">public</code> <code class="keyword">synchronized</code> <code class="keyword">void</code> <code class="plain">unlockRead(){</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>20</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">Thread callingThread = Thread.currentThread();</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>21</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">int</code> <code class="plain">accessCount = getAccessCount(callingThread);</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>22</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(accessCount == </code><code class="value">1</code><code class="plain">) { </code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>23</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">readingThreads.remove(callingThread); </code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>24</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code><code class="keyword">else</code> <code class="plain">{</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>25</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">readingThreads.put(callingThread, (accessCount -</code><code class="value">1</code><code class="plain">)); </code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>26</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>27</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">notifyAll();</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>28</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>29</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>30</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">boolean</code> <code class="plain">canGrantReadAccess(Thread callingThread){</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>31</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(writers &gt; </code><code class="value">0</code><code class="plain">) </code><code class="keyword">return</code> <code class="keyword">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>32</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(isReader(callingThread) </code><code class="keyword">return</code> <code class="keyword">true</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>33</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(writeRequests &gt; </code><code class="value">0</code><code class="plain">) </code><code class="keyword">return</code> <code class="keyword">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>34</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="keyword">true</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>35</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>36</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>37</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">int</code> <code class="plain">getReadAccessCount(Thread callingThread){</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>38</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">Integer accessCount = readingThreads.get(callingThread);</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>39</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(accessCount == </code><code class="keyword">null</code><code class="plain">) </code><code class="keyword">return</code> <code class="value">0</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>40</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="plain">accessCount.intValue();</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>41</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>42</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>43</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">boolean</code> <code class="plain">isReader(Thread callingThread){</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>44</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="plain">readingThreads.get(callingThread) != </code><code class="keyword">null</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>45</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>46</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div></div></div>
<p>
代码中我们可以看到，只有在没有线程拥有写锁的情况下才允许读锁的重入。此外，重入的读锁比写锁优先级高。
</p>
<h4 id="writereentrance">写锁重入</h4>
<p>
仅当一个线程已经持有写锁，才允许写锁重入（再次获得写锁）。下面是方法lockWrite和unlockWrite修改后的的代码。
</p>
<div id="highlighter_6979" class="syntaxhighlighter  "><div class="bar  "><div class="toolbar"><a href="#viewSource" title="view source" class="item viewSource" style="width: 16px; height: 16px;">view source</a><div class="item copyToClipboard"><embed width="16" height="16" id="highlighter_6979_clipboard" type="application/x-shockwave-flash" title="copy to clipboard" allowscriptaccess="always" wmode="transparent" flashvars="highlighterId=highlighter_6979" menu="false" src="http://ifeve.com/wp-content/plugins/syntaxhighlighter/syntaxhighlighter2/scripts/clipboard.swf"></div><a href="#printSource" title="print" class="item printSource" style="width: 16px; height: 16px;">print</a><a href="#about" title="?" class="item about" style="width: 16px; height: 16px;">?</a></div></div><div class="lines"><div class="line alt1"><table><tbody><tr><td class="number"><code>01</code></td><td class="content"><code class="keyword">public</code> <code class="keyword">class</code> <code class="plain">ReadWriteLock{</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>02</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="plain">Map&lt;Thread, Integer&gt; readingThreads =</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>03</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">new</code> <code class="plain">HashMap&lt;Thread, Integer&gt;();</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>04</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>05</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">int</code> <code class="plain">writeAccesses&nbsp;&nbsp;&nbsp; = </code><code class="value">0</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>06</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">int</code> <code class="plain">writeRequests&nbsp;&nbsp;&nbsp; = </code><code class="value">0</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>07</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="plain">Thread writingThread = </code><code class="keyword">null</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>08</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>09</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">public</code> <code class="keyword">synchronized</code> <code class="keyword">void</code> <code class="plain">lockWrite() </code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>10</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">throws</code> <code class="plain">InterruptedException{</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>11</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">writeRequests++;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>12</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">Thread callingThread = Thread.currentThread();</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>13</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">while</code><code class="plain">(!canGrantWriteAccess(callingThread)){</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>14</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">wait();</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>15</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>16</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">writeRequests--;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>17</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">writeAccesses++;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>18</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">writingThread = callingThread;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>19</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>20</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>21</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">public</code> <code class="keyword">synchronized</code> <code class="keyword">void</code> <code class="plain">unlockWrite() </code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>22</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">throws</code> <code class="plain">InterruptedException{</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>23</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">writeAccesses--;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>24</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(writeAccesses == </code><code class="value">0</code><code class="plain">){</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>25</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">writingThread = </code><code class="keyword">null</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>26</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>27</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">notifyAll();</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>28</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>29</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>30</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">boolean</code> <code class="plain">canGrantWriteAccess(Thread callingThread){</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>31</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(hasReaders()) </code><code class="keyword">return</code> <code class="keyword">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>32</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(writingThread == </code><code class="keyword">null</code><code class="plain">)&nbsp;&nbsp;&nbsp; </code><code class="keyword">return</code> <code class="keyword">true</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>33</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(!isWriter(callingThread)) </code><code class="keyword">return</code> <code class="keyword">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>34</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="keyword">true</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>35</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>36</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>37</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">boolean</code> <code class="plain">hasReaders(){</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>38</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="plain">readingThreads.size() &gt; </code><code class="value">0</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>39</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>40</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>41</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">boolean</code> <code class="plain">isWriter(Thread callingThread){</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>42</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="plain">writingThread == callingThread;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>43</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>44</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div></div></div>
<p>
注意在确定当前线程是否能够获取写锁的时候，是如何处理的。
</p>
<h4 id="upgrade">读锁升级到写锁</h4>
<p>
有时，我们希望一个拥有读锁的线程，也能获得写锁。想要允许这样的操作，要求这个线程是唯一一个拥有读锁的线程。writeLock()需要做点改动来达到这个目的：
</p>
<div id="highlighter_794973" class="syntaxhighlighter  "><div class="bar                       "><div class="toolbar"><a href="#viewSource" title="view source" class="item viewSource" style="width: 16px; height: 16px;">view source</a><div class="item copyToClipboard"><embed width="16" height="16" id="highlighter_794973_clipboard" type="application/x-shockwave-flash" title="copy to clipboard" allowscriptaccess="always" wmode="transparent" flashvars="highlighterId=highlighter_794973" menu="false" src="http://ifeve.com/wp-content/plugins/syntaxhighlighter/syntaxhighlighter2/scripts/clipboard.swf"></div><a href="#printSource" title="print" class="item printSource" style="width: 16px; height: 16px;">print</a><a href="#about" title="?" class="item about" style="width: 16px; height: 16px;">?</a></div></div><div class="lines"><div class="line alt1"><table><tbody><tr><td class="number"><code>01</code></td><td class="content"><code class="keyword">public</code> <code class="keyword">class</code> <code class="plain">ReadWriteLock{</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>02</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="plain">Map&lt;Thread, Integer&gt; readingThreads =</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>03</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">new</code> <code class="plain">HashMap&lt;Thread, Integer&gt;();</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>04</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>05</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">int</code> <code class="plain">writeAccesses&nbsp;&nbsp;&nbsp; = </code><code class="value">0</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>06</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">int</code> <code class="plain">writeRequests&nbsp;&nbsp;&nbsp; = </code><code class="value">0</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>07</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="plain">Thread writingThread = </code><code class="keyword">null</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>08</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>09</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">public</code> <code class="keyword">synchronized</code> <code class="keyword">void</code> <code class="plain">lockWrite() </code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>10</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">throws</code> <code class="plain">InterruptedException{</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>11</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">writeRequests++;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>12</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">Thread callingThread = Thread.currentThread();</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>13</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">while</code><code class="plain">(!canGrantWriteAccess(callingThread)){</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>14</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">wait();</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>15</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>16</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">writeRequests--;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>17</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">writeAccesses++;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>18</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">writingThread = callingThread;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>19</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>20</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>21</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">public</code> <code class="keyword">synchronized</code> <code class="keyword">void</code> <code class="plain">unlockWrite() </code><code class="keyword">throws</code> <code class="plain">InterruptedException{</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>22</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">writeAccesses--;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>23</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(writeAccesses == </code><code class="value">0</code><code class="plain">){</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>24</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">writingThread = </code><code class="keyword">null</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>25</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>26</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">notifyAll();</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>27</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>28</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>29</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">boolean</code> <code class="plain">canGrantWriteAccess(Thread callingThread){</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>30</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(isOnlyReader(callingThread)) </code><code class="keyword">return</code> <code class="keyword">true</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>31</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(hasReaders()) </code><code class="keyword">return</code> <code class="keyword">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>32</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(writingThread == </code><code class="keyword">null</code><code class="plain">) </code><code class="keyword">return</code> <code class="keyword">true</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>33</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(!isWriter(callingThread)) </code><code class="keyword">return</code> <code class="keyword">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>34</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="keyword">true</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>35</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>36</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>37</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">boolean</code> <code class="plain">hasReaders(){</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>38</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="plain">readingThreads.size() &gt; </code><code class="value">0</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>39</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>40</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>41</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">boolean</code> <code class="plain">isWriter(Thread callingThread){</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>42</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="plain">writingThread == callingThread;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>43</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>44</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>45</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">boolean</code> <code class="plain">isOnlyReader(Thread thread){</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>46</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="plain">readers == </code><code class="value">1</code> <code class="plain">&amp;&amp; readingThreads.get(callingThread) != </code><code class="keyword">null</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>47</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>48</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div></div></div>
<p>
现在ReadWriteLock类就可以从读锁升级到写锁了。
</p>
<h4 id="downgrade">写锁降级到读锁</h4>
<p>
有时拥有写锁的线程也希望得到读锁。如果一个线程拥有了写锁，那么自然其它线程是不可能拥有读锁或写锁了。所以对于一个拥有写锁的线程，再获得读锁，是不会有什么危险的。我们仅仅需要对上面canGrantReadAccess方法进行简单地修改：
</p>
<div id="highlighter_551372" class="syntaxhighlighter  "><div class="bar         "><div class="toolbar"><a href="#viewSource" title="view source" class="item viewSource" style="width: 16px; height: 16px;">view source</a><div class="item copyToClipboard"><embed width="16" height="16" id="highlighter_551372_clipboard" type="application/x-shockwave-flash" title="copy to clipboard" allowscriptaccess="always" wmode="transparent" flashvars="highlighterId=highlighter_551372" menu="false" src="http://ifeve.com/wp-content/plugins/syntaxhighlighter/syntaxhighlighter2/scripts/clipboard.swf"></div><a href="#printSource" title="print" class="item printSource" style="width: 16px; height: 16px;">print</a><a href="#about" title="?" class="item about" style="width: 16px; height: 16px;">?</a></div></div><div class="lines"><div class="line alt1"><table><tbody><tr><td class="number"><code>1</code></td><td class="content"><code class="keyword">public</code> <code class="keyword">class</code> <code class="plain">ReadWriteLock{</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>2</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">boolean</code> <code class="plain">canGrantReadAccess(Thread callingThread){</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>3</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(isWriter(callingThread)) </code><code class="keyword">return</code> <code class="keyword">true</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>4</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(writingThread != </code><code class="keyword">null</code><code class="plain">) </code><code class="keyword">return</code> <code class="keyword">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>5</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(isReader(callingThread) </code><code class="keyword">return</code> <code class="keyword">true</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>6</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(writeRequests &gt; </code><code class="value">0</code><code class="plain">) </code><code class="keyword">return</code> <code class="keyword">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>7</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="keyword">true</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>8</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>9</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div></div></div>
<h4 id="full">可重入的ReadWriteLock的完整实现</h4>
<p>
下面是完整的ReadWriteLock实现。为了便于代码的阅读与理解，简单对上面的代码做了重构。重构后的代码如下。
</p>
<div id="highlighter_762535" class="syntaxhighlighter  "><div class="bar              "><div class="toolbar"><a href="#viewSource" title="view source" class="item viewSource" style="width: 16px; height: 16px;">view source</a><div class="item copyToClipboard"><embed width="16" height="16" id="highlighter_762535_clipboard" type="application/x-shockwave-flash" title="copy to clipboard" allowscriptaccess="always" wmode="transparent" flashvars="highlighterId=highlighter_762535" menu="false" src="http://ifeve.com/wp-content/plugins/syntaxhighlighter/syntaxhighlighter2/scripts/clipboard.swf"></div><a href="#printSource" title="print" class="item printSource" style="width: 16px; height: 16px;">print</a><a href="#about" title="?" class="item about" style="width: 16px; height: 16px;">?</a></div></div><div class="lines"><div class="line alt1"><table><tbody><tr><td class="number"><code>001</code></td><td class="content"><code class="keyword">public</code> <code class="keyword">class</code> <code class="plain">ReadWriteLock{</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>002</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="plain">Map&lt;Thread, Integer&gt; readingThreads =</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>003</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">new</code> <code class="plain">HashMap&lt;Thread, Integer&gt;();</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>004</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>005</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">int</code> <code class="plain">writeAccesses&nbsp;&nbsp;&nbsp; = </code><code class="value">0</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>006</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">int</code> <code class="plain">writeRequests&nbsp;&nbsp;&nbsp; = </code><code class="value">0</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>007</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="plain">Thread writingThread = </code><code class="keyword">null</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>008</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>009</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">public</code> <code class="keyword">synchronized</code> <code class="keyword">void</code> <code class="plain">lockRead() </code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>010</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">throws</code> <code class="plain">InterruptedException{</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>011</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">Thread callingThread = Thread.currentThread();</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>012</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">while</code><code class="plain">(! canGrantReadAccess(callingThread)){</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>013</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">wait();</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>014</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>015</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>016</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">readingThreads.put(callingThread,</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>017</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">(getReadAccessCount(callingThread) + </code><code class="value">1</code><code class="plain">));</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>018</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>019</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>020</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">boolean</code> <code class="plain">canGrantReadAccess(Thread callingThread){</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>021</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(isWriter(callingThread)) </code><code class="keyword">return</code> <code class="keyword">true</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>022</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(hasWriter()) </code><code class="keyword">return</code> <code class="keyword">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>023</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(isReader(callingThread)) </code><code class="keyword">return</code> <code class="keyword">true</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>024</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(hasWriteRequests()) </code><code class="keyword">return</code> <code class="keyword">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>025</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="keyword">true</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>026</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>027</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>028</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>029</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">public</code> <code class="keyword">synchronized</code> <code class="keyword">void</code> <code class="plain">unlockRead(){</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>030</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">Thread callingThread = Thread.currentThread();</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>031</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(!isReader(callingThread)){</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>032</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">throw</code> <code class="keyword">new</code> <code class="plain">IllegalMonitorStateException(</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>033</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"Calling Thread does not"</code> <code class="plain">+</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>034</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">" hold a read lock on this ReadWriteLock"</code><code class="plain">);</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>035</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>036</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">int</code> <code class="plain">accessCount = getReadAccessCount(callingThread);</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>037</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(accessCount == </code><code class="value">1</code><code class="plain">){ </code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>038</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">readingThreads.remove(callingThread); </code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>039</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code><code class="keyword">else</code> <code class="plain">{ </code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>040</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">readingThreads.put(callingThread, (accessCount -</code><code class="value">1</code><code class="plain">));</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>041</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>042</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">notifyAll();</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>043</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>044</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>045</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">public</code> <code class="keyword">synchronized</code> <code class="keyword">void</code> <code class="plain">lockWrite() </code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>046</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">throws</code> <code class="plain">InterruptedException{</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>047</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">writeRequests++;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>048</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">Thread callingThread = Thread.currentThread();</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>049</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">while</code><code class="plain">(!canGrantWriteAccess(callingThread)){</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>050</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">wait();</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>051</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>052</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">writeRequests--;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>053</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">writeAccesses++;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>054</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">writingThread = callingThread;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>055</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>056</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>057</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">public</code> <code class="keyword">synchronized</code> <code class="keyword">void</code> <code class="plain">unlockWrite() </code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>058</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">throws</code> <code class="plain">InterruptedException{</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>059</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(!isWriter(Thread.currentThread()){</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>060</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">throw</code> <code class="keyword">new</code> <code class="plain">IllegalMonitorStateException(</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>061</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"Calling Thread does not"</code> <code class="plain">+</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>062</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">" hold the write lock on this ReadWriteLock"</code><code class="plain">);</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>063</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>064</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">writeAccesses--;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>065</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(writeAccesses == </code><code class="value">0</code><code class="plain">){</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>066</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">writingThread = </code><code class="keyword">null</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>067</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>068</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">notifyAll();</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>069</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>070</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>071</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">boolean</code> <code class="plain">canGrantWriteAccess(Thread callingThread){</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>072</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(isOnlyReader(callingThread)) </code><code class="keyword">return</code> <code class="keyword">true</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>073</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(hasReaders()) </code><code class="keyword">return</code> <code class="keyword">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>074</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(writingThread == </code><code class="keyword">null</code><code class="plain">) </code><code class="keyword">return</code> <code class="keyword">true</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>075</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(!isWriter(callingThread)) </code><code class="keyword">return</code> <code class="keyword">false</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>076</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="keyword">true</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>077</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>078</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>079</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>080</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">int</code> <code class="plain">getReadAccessCount(Thread callingThread){</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>081</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">Integer accessCount = readingThreads.get(callingThread);</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>082</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(accessCount == </code><code class="keyword">null</code><code class="plain">) </code><code class="keyword">return</code> <code class="value">0</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>083</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="plain">accessCount.intValue();</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>084</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>085</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>086</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>087</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">boolean</code> <code class="plain">hasReaders(){</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>088</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="plain">readingThreads.size() &gt; </code><code class="value">0</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>089</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>090</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>091</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">boolean</code> <code class="plain">isReader(Thread callingThread){</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>092</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="plain">readingThreads.get(callingThread) != </code><code class="keyword">null</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>093</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>094</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>095</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">boolean</code> <code class="plain">isOnlyReader(Thread callingThread){</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>096</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="plain">readingThreads.size() == </code><code class="value">1</code> <code class="plain">&amp;&amp;</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>097</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">readingThreads.get(callingThread) != </code><code class="keyword">null</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>098</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>099</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>100</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">boolean</code> <code class="plain">hasWriter(){</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>101</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="plain">writingThread != </code><code class="keyword">null</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>102</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>103</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>104</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">boolean</code> <code class="plain">isWriter(Thread callingThread){</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>105</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="plain">writingThread == callingThread;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>106</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>107</code></td><td class="content">&nbsp;</td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>108</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">private</code> <code class="keyword">boolean</code> <code class="plain">hasWriteRequests(){</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>109</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="keyword">this</code><code class="plain">.writeRequests &gt; </code><code class="value">0</code><code class="plain">;</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>110</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>111</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div></div></div>
<h4 id="finally">在finally中调用unlock()</h4>
<p>
在利用ReadWriteLock来保护临界区时，如果临界区可能抛出异常，在finally块中调用readUnlock()和writeUnlock()就显得很重要了。这样做是为了保证ReadWriteLock能被成功解锁，然后其它线程可以请求到该锁。这里有个例子：
</p>
<div id="highlighter_804412" class="syntaxhighlighter  "><div class="bar         "><div class="toolbar"><a href="#viewSource" title="view source" class="item viewSource" style="width: 16px; height: 16px;">view source</a><div class="item copyToClipboard"><embed width="16" height="16" id="highlighter_804412_clipboard" type="application/x-shockwave-flash" title="copy to clipboard" allowscriptaccess="always" wmode="transparent" flashvars="highlighterId=highlighter_804412" menu="false" src="http://ifeve.com/wp-content/plugins/syntaxhighlighter/syntaxhighlighter2/scripts/clipboard.swf"></div><a href="#printSource" title="print" class="item printSource" style="width: 16px; height: 16px;">print</a><a href="#about" title="?" class="item about" style="width: 16px; height: 16px;">?</a></div></div><div class="lines"><div class="line alt1"><table><tbody><tr><td class="number"><code>1</code></td><td class="content"><code class="plain">lock.lockWrite();</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>2</code></td><td class="content"><code class="keyword">try</code><code class="plain">{</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>3</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">//do critical section code, which may throw exception</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>4</code></td><td class="content"><code class="plain">} </code><code class="keyword">finally</code> <code class="plain">{</code></td></tr></tbody></table></div><div class="line alt1"><table><tbody><tr><td class="number"><code>5</code></td><td class="content"><code class="spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">lock.unlockWrite();</code></td></tr></tbody></table></div><div class="line alt2"><table><tbody><tr><td class="number"><code>6</code></td><td class="content"><code class="plain">}</code></td></tr></tbody></table></div></div></div>
<p>
上面这样的代码结构能够保证临界区中抛出异常时ReadWriteLock也会被释放。如果unlockWrite方法不是在finally块中调用的，当临界区抛出了异常时，ReadWriteLock 会一直保持在写锁定状态，就会导致所有调用lockRead()或lockWrite()的线程一直阻塞。唯一能够重新解锁ReadWriteLock的因素可能就是ReadWriteLock是可重入的，当抛出异常时，这个线程后续还可以成功获取这把锁，然后执行临界区以及再次调用unlockWrite()，这就会再次释放ReadWriteLock。但是如果该线程后续不再获取这把锁了呢？所以，在finally中调用unlockWrite对写出健壮代码是很重要的。
</p>
<div style="margin-top: 15px; font-style: italic">
<p><strong>原创文章，转载请注明：</strong> 转载自<a href="http://ifeve.com/" target="_blank" rel="noopener">并发编程网 – ifeve.com</a><strong>本文链接地址:</strong> <a href="http://ifeve.com/read-write-locks/" target="_blank" rel="noopener">Java中的读/写锁</a></p>
<p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>读写锁</tag>
        <tag>ReentrantReadWriteLock</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程实战4-自旋锁，死锁，以及锁重入详解</title>
    <url>/2018/04/09/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%984-%E8%87%AA%E6%97%8B%E9%94%81%EF%BC%8C%E6%AD%BB%E9%94%81%EF%BC%8C%E4%BB%A5%E5%8F%8A%E9%94%81%E9%87%8D%E5%85%A5%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<ul>
<li>锁重入：也叫做递归锁<ul>
<li>某个线程获得一个已经由<strong>它自己</strong>持有的锁对象，那么这个请求就会成功，即重入</li>
<li>重入是对本线程来说，即本线程多资源可以多次加锁进入，而不会出现阻塞</li>
<li>在JAVA环境下 ReentrantLock 和synchronized 都是可重入锁</li>
<li>场景：比如数据库中，用户名和密码保存在本地txt文件中，则登录验证方法和更新密码方法都应该被加synchronized，那么当更新密码的时候需要验证密码的合法性，所以需要调用验证方法，相当于二次入锁，此时是可以调用的。</li>
</ul>
</li>
<li>自旋锁<ul>
<li>当一个线程访问的资源被其他线程占用时，此线程并不会等待，而是一直尝试获取锁，即仍然占用CPU，直到获取锁为止。</li>
</ul>
</li>
<li>死锁<ul>
<li>资源互斥导致互相占用不放</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>volatile变量原理与使用<a href="https://www.ibm.com/developerworks/cn/java/j-jtp06197.html" target="_blank" rel="noopener">链接：IBM-正确使用 Volatile 变量</a><ul>
<li>Volatile称之为轻量级锁，被volatile修饰的变量，在线程之间是可见的（处理器内部lock指令标记）。</li>
<li>可见：一个线程修改了这个变量的值，在另外一个线程中能够立即读到这个修改后的值。</li>
<li>volatile 变量可以被看作是一种 “程度较轻的 synchronized”；与 synchronized 块相比，volatile 变量所需的编码较少，并且运行时开销也较少，但是它所能实现的功能也仅是 synchronized 的一部分。<strong>Volatile 变量具有synchronized 的可见性特性，但是不具备原子特性。</strong></li>
<li>要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件：<ul>
<li>对变量的写操作不依赖于当前值。</li>
<li>该变量没有包含在具有其他变量的不变式中。<br>第一个条件的限制使 volatile 变量不能用作线程安全计数器。虽然增量操作（x++）看上去类似一个单独操作，实际上它是一个由读取－修改－写入操作序列组成的组合操作，必须以原子方式执行，而 volatile 不能提供必须的原子特性。实现正确的操作需要使 x 的值在操作期间保持不变，而 volatile 变量无法实现这点。（然而，如果将值调整为只从单个线程写入，那么可以忽略第一个条件。）</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>JDK1.5提供的原子类原理与应用<br>Atomic一词跟原子有点关系，后者曾被人认为是最小物质的单位。计算机中的Atomic是指不能分割成若干部分的意思。如果一段代码被认为是Atomic，则表示这段代码在执行过程中，是不能被中断的。通常来说，原子指令由硬件提供，供软件来实现原子方法（某个线程进入该方法后，就不会被中断，直到其执行完成）<br>在x86 平台上，CPU提供了在指令执行期间对总线加锁的手段。CPU芯片上有一条引线#HLOCK pin，如果汇编语言的程序中在一条指令前面加上前缀”LOCK”，经过汇编以后的机器代码就使CPU在执行这条指令的时候把#HLOCK pin的电位拉低，持续到这条指令结束时放开，从而把总线锁住，这样同一总线上别的CPU就暂时不能通过总线访问内存了，保证了这条指令在多处理器环境中的原子性。</p>
<ul>
<li>原子变量的原子操作也是用到了锁，只不过这个是硬件指令级别的锁，比我们软件实现的锁高效很多，更重要的是如果出现了冲突，只是不停的循环重试，而不会切换线程。如：do{ }while 循环调用一个本地方法。</li>
</ul>
</li>
<li><p>Lock锁的认识与使用</p>
<ul>
<li>lock的使用类似如下：<br><img src="http://osiy4s0ad.bkt.clouddn.com/soundblog/1523269535365.jpg" alt="lock使用"></li>
<li>使用方式类似于synchronized，具有相同的互斥性和内存可见性，但是更加灵活，加锁和放锁可以由使用者自己确定</li>
<li>优势：<ul>
<li>synchronized锁可能出现异常而导致中断，无法释放锁，但是通过使用lock，可以直接将lock放在异常finally中，强制释放锁。<ul>
<li>可以方便的实行公平性</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>AbstractQueuedSynchronizer(AQS)详解</p>
<ul>
<li><p>AQS是一个用来构建锁和同步器的框架,它在内部定义了一个int state变量,用来表示同步状态.在LOCK包中的相关锁(常用的有ReentrantLock、 ReadWriteLock)都是基于AQS来构建.然而这些锁都没有直接来继承AQS,而是定义了一个Sync类去继承AQS.那么为什么要这样呢?because:锁面向的是使用用户,而同步器面向的则是线程控制,那么在锁的实现中聚合同步器而不是直接继承AQS就可以很好的隔离二者所关注的事情。</p>
</li>
<li><p>即AQS用来记录线程状态，并不管理线程，所以是内部定义，而不是直接继承</p>
</li>
<li><p>java.util.concurrent中的同步器类：</p>
<ul>
<li><p>RentrantLock</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 源码</span></span><br><span class="line"><span class="comment">         * Performs non-fair tryLock.  tryAcquire is implemented in</span></span><br><span class="line"><span class="comment">         * subclasses, but both need nonfair try for trylock method.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">            final Thread current = Thread.currentThread();</span><br><span class="line">            int c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                int nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    throw new Error("Maximum lock count exceeded");</span><br><span class="line">                setState(nextc);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">            int c = getState() - releases;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">                throw new IllegalMonitorStateException();</span><br><span class="line">            boolean free = false;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                free = true;</span><br><span class="line">                setExclusiveOwnerThread(null);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c);</span><br><span class="line">            return free;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ReentrantReadWriteLock</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>公平锁和非公平锁（是否考虑队列问题）</p>
<ul>
<li>公平锁（Fair）：加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得 </li>
<li>非公平锁（Nonfair）：加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待<br>非公平锁性能比公平锁高5~10倍，因为公平锁需要在多核的情况下维护一个队列，Java中的ReentrantLock 默认的lock()方法采用的是非公平锁。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>自旋锁</tag>
        <tag>锁重入</tag>
        <tag>volatile</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程实战3-单例模式与线程安全性问题</title>
    <url>/2018/04/09/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%983-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>单例模式是为了保证一个应用中只有一个实例对象，在单线程的情况下，只需对构造方法私有化，加上对象唯一指定就能实现，但是在多线程的情况下，就会出现问题</p>
</blockquote>
<ul>
<li>指令重排序：<ul>
<li>大多数现代微处理器都会采用将指令乱序执行（out-of-order execution，简称OoOE或OOE）的方法，在条件允许的情况下，直接运行当前有能力立即执行的后续指令，避开获取下一条指令所需数据时造成的等待3。通过乱序执行的技术，处理器可以大大提高执行效率。</li>
<li>即为了降低数据的切换获取，在不影响单线程程序逻辑的前提下，处理器会将同一资源的指令一起执行，而打乱中间的顺序。所以就会导致，如下，还没有new对象的同时（2），就已经制定了对象地址（3），即顺序为132。</li>
</ul>
</li>
</ul>
<p>单例模式的分类：</p>
<ul>
<li>饿汉式<ul>
<li>由于饿汉式是在初始化时就生成了对象，所以不存在安全问题</li>
</ul>
</li>
</ul>
<pre><code><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author: ZouTai</span></span><br><span class="line"><span class="comment"> * @date: 2018/4/8</span></span><br><span class="line"><span class="comment"> * @description: 饿汉式：初始化实例(线程一定安全)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public class Singleton &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、构造方法私有</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2、建立静态对象，单个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public static Singleton singleton = new Singleton();</span><br><span class="line"></span><br><span class="line">    public Singleton getInstance() &#123;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ul>
<li>懒汉式<ul>
<li>懒汉式是在用的是时候才会初始化对象，当多个线程访问，就会出现线程安全问题</li>
</ul>
</li>
</ul>
<pre><code><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author: ZouTai</span></span><br><span class="line"><span class="comment"> * @date: 2018/4/8</span></span><br><span class="line"><span class="comment"> * @description: 懒汉式：不初始化实例，在用的时候才初始化（线程不安全）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public class Singleton2 &#123;</span><br><span class="line">    private Singleton2() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static Singleton2 singleton = null;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 双重检查加锁-或者叫做细粒度锁</span></span><br><span class="line"><span class="comment">     * 偏向锁-》轻量级锁-》重量级锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public static Singleton2 getInstance() &#123;</span><br><span class="line">        <span class="comment">//自旋=while(true)占用cpu</span></span><br><span class="line">        <span class="keyword">if</span> (singleton == null) &#123; <span class="comment">// 读取时不会冲突</span></span><br><span class="line">            synchronized (Singleton2.class) &#123;</span><br><span class="line">                <span class="comment">// 之所以再次判断，是为了防止其他线程已经更改了</span></span><br><span class="line">                <span class="keyword">if</span> (singleton == null) &#123;</span><br><span class="line">                    singleton = new Singleton2();// 指令重排序</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 申请一块内存空间   // 1</span></span><br><span class="line">                   <span class="comment">// 在这块空间里实例化对象  // 2</span></span><br><span class="line">                   <span class="comment">// instance的引用指向这块空间地址   // 3</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
        <tag>多线程</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程实战2-Synchronized原理与使用</title>
    <url>/2018/04/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%982-Synchronized%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<ul>
<li><p>Synchronized分类：修饰实例方法、静态方法和代码块</p>
<ul>
<li>1、放在普通类方法上，内置锁就是实例对象</li>
<li>2、修饰静态方法，内置锁为当前的class字节码对象Sequence.class</li>
<li>3、修饰代码块，内置锁为括号里的对象</li>
</ul>
</li>
<li><p>锁分类：偏向锁、轻量级锁和重量级锁<br>Synchronized是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。因此，这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”。JDK中对Synchronized做的种种优化，其核心都是为了减少这种重量级锁的使用。JDK1.6以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和“偏向锁”。<br>偏向锁、轻量级锁都是乐观锁，重量级锁是悲观锁。这种设计是为了根据实际的运行状态在不断变化锁的性质，即最开始默认是单线程，即偏向锁，之后如果来了另一个线程就变为轻量级锁，此时两个所冲突并不大，资源是交互使用的。但是，再接着，发现这两个锁总是相互枪资源，就变成重量级锁。  </p>
<ul>
<li>偏向锁：一个对象刚开始实例化的时候，没有任何线程来访问它的时候。它是可偏向的，意味着，它现在认为只可能有一个线程来访问它，所以当第一个线程来访问它的时候，它会偏向这个线程，此时，对象持有偏向锁。偏向第一个线程，这个线程在修改对象头成为偏向锁的时候使用CAS操作，并将对象头中的ThreadID改成自己的ID，之后再次访问这个对象时，只需要对比ID，不需要再使用CAS锁重入，再进行操作。</li>
<li>轻量级锁：一旦有第二个线程访问这个对象，因为偏向锁不会主动释放，所以第二个线程可以看到对象时偏向状态，这时表明在这个对象上已经存在竞争了，检查原来持有该对象锁的线程是否依然存活，如果挂了，则可以将对象变为无锁状态，然后重新偏向新的线程，如果原来的线程依然存活，则马上执行那个线程的操作栈，检查该对象的使用情况，如果仍然需要持有偏向锁，则偏向锁升级为轻量级锁，（偏向锁就是这个时候升级为轻量级锁的）。如果不存在使用了，则可以将对象回复成无锁状态，然后重新偏向。轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。 </li>
<li>重量级锁：当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。</li>
</ul>
</li>
</ul>
<p><a href="http://www.cnblogs.com/paddix/p/5405678.html" target="_blank" rel="noopener">内部原理详解博客</a><br><a href="https://www.zhihu.com/question/53826114" target="_blank" rel="noopener">知乎-生动的解释</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>偏向锁</tag>
        <tag>monitor</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程实战1-多线程的周期、实现方式和意义</title>
    <url>/2018/04/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%91%A8%E6%9C%9F%E3%80%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%92%8C%E6%84%8F%E4%B9%89/</url>
    <content><![CDATA[<p>day01:线程的周期</p>
<p><img src="http://osiy4s0ad.bkt.clouddn.com/soundblog/1523156274841.jpg" alt="线程的周期"></p>
<p>day02:创建线程的多种方式(7中)：<br><strong>一般推荐采用Runnable接口或者Callable接口来实现多线程。</strong></p>
<p>西红丝鸡蛋汤：</p>
<ol>
<li>继承Thread类<ul>
<li>主线成为最简单的汤的做法，现在需要仿照这个做法，定做自己的</li>
<li>直接继承，可以使用一些父线程的共同属性</li>
</ul>
</li>
<li>实现Runnable接口<ul>
<li>做汤的方法都知道，但是需要自己安排</li>
<li>还可以继承其他类，可拓展性比较好</li>
<li>由于接口内部调用的是同一个target，多个线程共享一个target，所以更适合多线程共享统一资源。  <figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public void run() &#123;</span><br><span class="line">       <span class="keyword">if</span> (target != null) &#123;</span><br><span class="line">           target.run();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>带返回值的线程/实现Callable接口的<ul>
<li>大体的方式都知道，但是需要缺少西红柿，需要开个线程，把西红柿提前做好用于备用（返回值），等汤都做好了，只需要向其中加入西红柿就可以了（调用）</li>
<li>同第二种方式类似，只是这里的使用了FutureTask，作用相当于提前分配一个线程任务用于计算一个程序的结果，这个结果将在之后的主线程调用<code>int result = futureTask.get();</code>。</li>
</ul>
</li>
</ol>
<hr>
<ol start="4">
<li>匿名内部类的方式<ul>
<li>我的主要目的是做一顿晚饭（主类），所以西红柿鸡蛋汤并不是主体（只是主体的一部分），这时候，只需要在做饭内部，定义一个做西红柿鸡蛋汤的匿名内部类就行了。</li>
<li>匿名内部类，相当于直接在主线程中加入一个内部类，相当于一个小的脚本，不影响主类。</li>
</ul>
</li>
<li>定时器（quartz）<ul>
<li>为了准确把握做汤的时间，我们需要一个定时器，仅仅是sleep不能满足要求。因为，有时候，这个定时器需求蛮复杂，有些时候，我们做汤，需要隔一分钟尝一次味道，所以，这个时候就需要定时器，固定时间重复一个线程。</li>
</ul>
</li>
<li>线程池的实现<ul>
<li>由于汤做的太好了，开启了饭店，由于顾客很多，为了满足需求，需要很多的做汤程序，为了方便，这个时候就需要雇佣一批厨师（线程池），顾客随时到来，随时就可以启动做汤，但是，由于顾客流量不定，厨师太多太少，都不好。通过分析客户流量，发现10个厨师，刚好满足要求，所以就设置线程池大小为10。</li>
<li>为了满足高并发要求，需要提前备用多个线程在进行操作。</li>
</ul>
</li>
<li>Lambda表达式实现<ul>
<li>同上，需求很大时对西红柿的要求也很大，所以洗西红柿也需要多个人来进行，而且，和做汤不同，洗西红柿的只会洗西红柿（数据计算），所以jdk8就启用了一个lambda表达式，让这些专职工人只做一件事。</li>
<li>lambda表达式有一个数据计算并行流parallelStream，可以对list等直接进行并行计算：<code>return list.parallelStream().mapToInt(i -&gt; i * 2).sum();</code></li>
</ul>
</li>
<li>Spring实现多线程<ul>
<li>spring中有个@Async注解，可以实现多线程</li>
</ul>
</li>
</ol>
<hr>
<p>day03：多线程几个主要指标</p>
<ul>
<li><p>一、活跃性问题</p>
<ul>
<li><p>死锁：即线程资源调用互斥，哲学家吃饭问题（刀叉互斥）</p>
</li>
<li><p>饥饿（不公平）：</p>
<ul>
<li>由于某个线程太弱，优先级太低的问题，导致这个线程始终无法抢到CPU资源，就会导致，这个线程饥饿（排队买饭，前面总是有插队的，你就饿死了）</li>
<li>某一个线程获取了资源的锁，一直占用着，导致另一个线程无法获取此资源，也会饥饿</li>
<li>wait和notify，线程wait后，没有其他线程来notify它，也会被饿死。</li>
</ul>
</li>
<li><p>活锁：之所以称之为活锁，是相对与死锁而言，活锁并没有阻塞，还是在正常运行，只是，这种运行，执行一部分就回滚，一直在重复，相当于一直在做无用功。一般出现在事务回滚中，由于两个线程资源故障，导致都一起回滚，然而，重新开始，还是遇到了这个问题，就一起一直回滚下去。比如，两台机器发送数据，由于通道同时被占用，<strong>就都等了一秒</strong>，再发,这样冲突还是存在。</p>
</li>
<li><p><strong>如何避免饥饿？</strong></p>
<ul>
<li>设置合理的优先级</li>
<li>使用自己实现的锁来代替synchronized，自己会合理的设置锁</li>
</ul>
</li>
</ul>
</li>
<li><p>二、性能问题：多线程并不一定快</p>
<ul>
<li>线程多了，CPU不够，导致一个CPU要应付很多线程，由于线程之间切换，需要保存数据和提取数据，导致切换回占用太多的时间，就会降低整体速度（上下文切换）</li>
</ul>
</li>
<li><p>三、安全性问题</p>
<ul>
<li>出现安全性问题的三个条件：<ul>
<li>多线程环境</li>
<li>共享同一个资源</li>
<li>对资源进行非原子性操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><em>多线程的目的是为了将可以并发操作的操作进行并发执行，而将需要原子性操作的资源进行保护，所以之后会使用到细粒度锁。</em></p>
<p><a href="https://github.com/purice93/ConcurrentThread.git" target="_blank" rel="noopener">源码git</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>多线程</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>一部电影晓生活-韩国</title>
    <url>/2018/04/05/%E4%B8%80%E9%83%A8%E7%94%B5%E5%BD%B1%E6%99%93%E7%94%9F%E6%B4%BB-%E9%9F%A9%E5%9B%BD/</url>
    <content><![CDATA[<blockquote>
<p>和科学技术不同，艺术并不直接促进社会的变革，但是却是一种无形的引导。然而欣赏艺术的能力却并不总是被常人所拥有，而作为八大艺术之一的电影，却显得格外亲民，这种不需要太多“艺术”细胞的东西，相对于美术绘画、音乐旋律等，更容易使人产生共鸣。就像音乐的风格随着时代的不同而改变一样，电影的发展在不同的时期，不同的社会也会有着千差万别，其中多多少少代表着不同社会的发展或者是人们期望发展的方向。</p>
</blockquote>
<hr>
<p><strong>《蚯蚓》，英文名为《My Little Baby, Jaya》</strong></p>
<p>一部电影的主旨往往能够看出起名者想表达的内部含义，前者表达的是对社会的愤懑，后者却包含了更多的父爱。然而电影本身却远远并不只有这些，关键是我们的关注点在哪。</p>
<p>实话实说，对于这部电影，我本想有万字千文来表达，但是在删删改改之后，就直接清空了回收箱。实在是找不到规范的语言来陈述，找不到“礼貌”的词藻来表达，太多的愤世嫉俗让我显得不像是个书生。所以，为了显示一个文化人的身份，我还是化繁为简，简略表达以不失儒家风范。</p>
<p>总体而言，对于这个电影，或者其中发生的时间，看完一小时之后，我就心平气和了，以至于并没有太多的词语想要表达，也没有太多的感悟需要抒发，更没有产生多少的愤懑用来呐喊，唯一的共鸣可能就是偶尔的现实和理想的反差。</p>
<p>过多的同情让我麻木，过多的愤懑让我劳累，过多的反思让我不太喜欢看这些揭露社会黑暗的东西，毕竟这些黑暗的东西谁都知道，只是绝大多数人碰不到，也就无所谓了。然而，法律是需要为可能的发生的事情做准备的，而这就像是如今的韩国社会。许多法律的更改，许多的旧事重提，都是通过历史的翻案或者历史的卑劣记录来实现的。但是，韩国的国情在全世界而言都算是少数的，中国离那也差不多是十万八千零一里了，毕竟中国走的是中国特色社会主义道路，我们既不像韩国那样疯狂，也不会像日本那样保守，而是会在保守中，让历史慢慢前行。</p>
<p>其实，韩国的电影有些时候往往会让人看的更加痛快，一种吸满整口烟气然后一泻而下一样，简直是爽到肺！因为不管结尾是悲是喜，都会让人感到一种“完美”——好人虽然不一定有好的结局，但是坏人一定是会死的。还记得，我第一次爱上韩国电影应该是大二的时候，也是一部这种类型的电影《熔炉》，就如同今天爱上了惊悚片一样，当时也在搜集各种类似的片子，见证各种对社会的讽刺，以达到自己内心的“愉悦”，满足对言论自由的“局部”意淫，从《金福南杀人事件》、《恐怖直播》再到《辩护人》；从国内的《盲井》《盲山》再到《天狗》《天注定》，这些同等类型的片子，无论是揭露社会还是反思历史，多多少少都会带点承重感，承重感多了，就索然无味了，因为刚开始是怕自己会掉入这个深渊，而希望国家能去修补；而之后却是努力远离这个深渊，不关我事。</p>
<p>相对韩国的电影，心目中最喜欢的电影应该算是日本的，如果让我在电影院选择看一部电影，我绝对会去选择一部日本电影，去感受生活中的美好，去感受自然的清新，不去考历史，不去想未来，只活在当下。毕竟电影是种娱乐，而不是一种鞭策社会进步的工具——那是法律该做的事情，我可不希望在劳累的一周之后，本想着在周末来个身心愉悦，却还要在电影院为了社会而烦恼。所以，遍看世界各国主流电影，就会发现，欧美在畅想未来，日本在享受当前，韩国在鞭策历史，印度在讽刺现实，而国内却百花齐放：爱国之花最为灿烂，商业之花偶尔盛开，历史之花即将凋零。</p>
<p><em>科技永在发展，历史总是重复，悲剧往往类似</em></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>电影</tag>
        <tag>蚯蚓</tag>
        <tag>韩国</tag>
        <tag>批判</tag>
        <tag>自由</tag>
        <tag>人性</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式服务器中的session共享问题</title>
    <url>/2018/03/18/%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E7%9A%84session%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>为了使得分发后的多个tomcat服务器，可以对请求session进行共享，我们需要使用一个特殊的数据服务器。<br>一般有memcached和redis3。（redis没有这个功能）</p>
</blockquote>
<p><strong>session共享原理</strong></p>
<ul>
<li>http协议是无状态的，即你连续访问某个网页100次和访问1次对服务器来说是没有区别对待的，因为它记不住你。那么，在一些场合，确实需要服务器记住当前用户怎么办？比如用户登录邮箱后，接下来要收邮件、写邮件，总不能每次操作都让用户输入用户名和密码吧，为了解决这个问题，session的方案就被提了出来，事实上它并不是什么新技术，而且也不能脱离http协议以及任何现有的web技术</li>
<li>session的常见实现形式是会话cookie（session cookie），即未设置过期时间的cookie，这个cookie的默认生命周期为浏览器会话期间，只要关闭浏览器窗口，cookie就消失了。实现机制是当用户发起一个请求的时候，服务器会检查该请求中是否包含sessionid，如果未包含，则系统会创造一个名为JSESSIONID的输出cookie返回给浏览器(只放入内存，并不存在硬盘中)，并将其以HashTable的形式写到服务器的内存里面；当已经包含sessionid是，服务端会检查找到与该session相匹配的信息，如果存在则直接使用该sessionid，若不存在则重新生成新的session。这里需要注意的是session始终是有服务端创建的，并非浏览器自己生成的。但是浏览器的cookie被禁止后session就需要用get方法的URL重写的机制或使用POST方法提交隐藏表单的形式来实现</li>
<li>Session共享：<br>首先我们应该明白，为什么要实现共享，如果你的网站是存放在一个机器上，那么是不存在这个问题的，因为会话数据就在这台机器，但是如果你使用了负载均衡把请求分发到不同的机器呢？这个时候会话id在客户端是没有问题的，但是如果用户的两次请求到了两台不同的机器，而它的session数据可能存在其中一台机器，这个时候就会出现取不到session数据的情况，于是session的共享就成了一个问题</li>
<li>Session一致性解决方案：<ul>
<li>1、session复制<br>tomcat 本身带有复制session的功能。（不讲）</li>
<li>2、共享session<br>需要专门管理session的软件，<br>memcached缓存服务，可以和tomcat整合，帮助tomcat共享管理session。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>利用memcached实现session共享</strong></p>
<ul>
<li>安装mencached<blockquote>
<p>yum -y install memcached<br>service memcached start #启动memcached服务器</p>
</blockquote>
</li>
<li>复制memcached相关的jar包到tomcat的lib下<a href="https://code.google.com/archive/p/memcached-session-manager/downloads" target="_blank" rel="noopener">下载连接</a><br><img src="http://osiy4s0ad.bkt.clouddn.com/soundblog/1521338268310.jpg" alt="memcached相关jar包"></li>
<li>修改tomcat标记<code>vi conf/server.xml</code><br><img src="http://osiy4s0ad.bkt.clouddn.com/soundblog/1521338516695.jpg" alt="添加tomcat标记，用于访问标志"></li>
<li>vim中的查找命令<code>/tag</code>;即命令行模式键入”/“,”tag”即为所需查找的字符串</li>
<li>修改tomcat默认访问页面index.jsp，加入session<br><img src="http://osiy4s0ad.bkt.clouddn.com/soundblog/1521340498851.jpg" alt="修改默认界面index.jsp，添加session支持"> </li>
<li>未添加一致行前，访问nginx时，将产生多个session<br><img src="http://osiy4s0ad.bkt.clouddn.com/soundblog/1521349650737.jpg" alt="tomcat1"><br><img src="http://osiy4s0ad.bkt.clouddn.com/soundblog/1521342012606.jpg" alt="tomcat2"></li>
<li>添加一致性，tomcat连接memcached，将session存入memcached<blockquote>
<p>vi conf/context.xml</p>
</blockquote>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">&lt;Manager className=<span class="string">"de.javakaffee.web.msm.MemcachedBackupSessionManager"</span> </span><br><span class="line">	memcachedNodes=<span class="string">"n1:192.168.116.3:11211"</span> </span><br><span class="line">    sticky=<span class="string">"false"</span> </span><br><span class="line">    lockingMode=<span class="string">"auto"</span></span><br><span class="line">    sessionBackupAsync=<span class="string">"false"</span></span><br><span class="line">	requestUriIgnorePattern=<span class="string">".*\.(ico|png|gif|jpg|css|js)$"</span></span><br><span class="line">    sessionBackupTimeout=<span class="string">"1000"</span> transcoderFactoryClass=<span class="string">"de.javakaffee.web.msm.serializer.kryo.KryoTranscoderFactory"</span> </span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
<img src="http://osiy4s0ad.bkt.clouddn.com/soundblog/1521349290610.jpg" alt="添加memcached连接"></li>
<li>分别修改tomcat对应的index.jsp</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language="java" contentType="text/html; charset=UTF-8"  pageEncoding="UTF-8"%&gt;</span><br><span class="line">SessionID:&lt;%=session.getId()%&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line">SessionIP:&lt;%=request.getServerName()%&gt; </span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&lt;h1&gt;tomcat2 page&lt;/h1&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>重启memcached、nginx和tomcat，访问<code>192.168.116.3</code></li>
<li>效果：sessionID不变，只是服务器页面变化<br><img src="http://osiy4s0ad.bkt.clouddn.com/soundblog/1521349570726.jpg" alt="tomcat1"><br><img src="http://osiy4s0ad.bkt.clouddn.com/soundblog/1521349582665.jpg" alt="tomcat2"></li>
</ul>
<p><strong>注意事项：过程中可能存在各种各样的问题，导致错误。如复制空格问题。当实在无法找到错误原因时，可以文件整体还原，在修改，因为有时候可能是自己错误修改了文件，但是找不到地址了</strong></p>
<hr>
<p>完整参考流程：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.	安装memcached内存数据库</span><br><span class="line">yum –y install memcached</span><br><span class="line">可以用telnet localhost <span class="number">11211</span></span><br><span class="line">Set abc <span class="number">0</span> <span class="number">0</span> <span class="number">5</span></span><br><span class="line"><span class="number">12345</span></span><br><span class="line">get abc </span><br><span class="line"><span class="number">2</span>.	web服务器连接memcached的jar包拷贝到tomcat的lib</span><br><span class="line"><span class="number">3</span>.	修改server.xml里面修改Engine标签，添加jvmRoute属性，目的是查看sessionid里面带有tomcat的名字，就是这里配置的jvmRoute</span><br><span class="line">&lt;Engine name=<span class="string">"Catalina"</span> defaultHost=<span class="string">"localhost"</span> jvmRoute=<span class="string">"tomcat1"</span>&gt;</span><br><span class="line"><span class="number">4</span>.	配置tomcat的conf目录下的context.xml</span><br><span class="line">&lt;Manager className=<span class="string">"de.javakaffee.web.msm.MemcachedBackupSessionManager"</span></span><br><span class="line">        memcachedNodes=<span class="string">"n1:192.168.17.9:11211"</span></span><br><span class="line">    sticky=<span class="string">"false"</span></span><br><span class="line">    lockingMode=<span class="string">"auto"</span></span><br><span class="line">    sessionBackupAsync=<span class="string">"false"</span></span><br><span class="line">        requestUriIgnorePattern=<span class="string">".*\.(ico|png|gif|jpg|css|js)$"</span></span><br><span class="line">sessionBackupTimeout=<span class="string">"1000"</span> transcoderFactoryClass=<span class="string">"de.javakaffee.web.msm.serializer.kryo.KryoTranscoderFactory"</span> /&gt;</span><br><span class="line">配置memcachedNodes属性，配置memcached数据库的ip和端口，默认<span class="number">11211</span>，多个的话用空格隔开</span><br><span class="line">目的？让tomcat服务器从memcached缓存里面拿session或者是放session</span><br><span class="line"><span class="number">5</span>.	修改index.jsp，取sessionid看一看</span><br><span class="line">&lt;%@ page language="java" contentType="text/html; charset=UTF-8"  pageEncoding="UTF-8"%&gt;</span><br><span class="line">&lt;<span class="selector-tag">html</span> lang=<span class="string">"en"</span>&gt;</span><br><span class="line">SessionID:&lt;%=session.getId()%&gt;</span><br><span class="line">&lt;/br&gt;</span><br><span class="line">SessionIP:&lt;%=request.getServerName()%&gt;</span><br><span class="line">&lt;/br&gt;</span><br><span class="line">&lt;h1&gt;tomcat1&lt;/h1&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>


<p><strong>利用redis实现session共享</strong></p>
<ul>
<li>安装redis <code>yum -y install redis</code><br>可能会存在无yum源的问题：</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">CentOS默认的安装源在官方的centos.org上，而redis在第三方的yum源里，因此无法安装。这就是我们常常在yum源里找不到各种软件的原因，还需要自己去wget，然后configure,make,make install，这个过程太痛苦了，并且卸载软件的时候还容易出错。</span><br><span class="line">非官方的yum推荐用fedora的epel仓库。epel (Extra Packages <span class="keyword">for</span> Enterprise Linux)是基于Fedora的一个项目，该仓库下有非常多的软件，建议安装。yum添加epel源的命令为：yum install epel-release然后回车。安装完后，我们使用命令：yum repolist查看。然后重新安装redis</span><br></pre></td></tr></table></figure>
<ul>
<li><p>导入相关的redis-tomcat的jar包到tomcat中（下载链接同上）<br><img src="http://osiy4s0ad.bkt.clouddn.com/soundblog/1521382915270.jpg" alt="三个依赖jar包"></p>
</li>
<li><p>检测是否安装正确</p>
<blockquote>
<p>由于redis默认的打开端口是6379；memcached默认端口是11211；所以可以直接通过telnet来检查端口情况：<code>telnet localhost 6379</code></p>
</blockquote>
</li>
<li><p>修改redis相关配置<code>vi /etc/redis.conf</code>，将bind的127.0.0.1修改为本机地址，否则只能本机访问了。会出现各种错误！</p>
<blockquote>
<p>另外注意：修改的bind为第二个不是第一个！<br><img src="http://osiy4s0ad.bkt.clouddn.com/soundblog/1521446257269.jpg" alt="不是这里的"><br><img src="http://osiy4s0ad.bkt.clouddn.com/soundblog/1521446313973.jpg" alt="而是这里"></p>
</blockquote>
</li>
<li><p>添加redis配置到tomcat中，同memcached一样</p>
</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">&lt;Valve className=<span class="string">"com.orangefunction.tomcat.redissessions.RedisSessionHandlerValve"</span> /&gt;</span><br><span class="line">&lt;Manager className=<span class="string">"com.orangefunction.tomcat.redissessions.RedisSessionManager"</span></span><br><span class="line">         host=<span class="string">"192.168.116.3"</span></span><br><span class="line">         port=<span class="string">"6379"</span></span><br><span class="line">         database=<span class="string">"0"</span></span><br><span class="line">         maxInactiveInterval=<span class="string">"60"</span> /&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试效果<br><img src="http://osiy4s0ad.bkt.clouddn.com/soundblog/1521446558722.jpg" alt="tomcat1"><br><img src="http://osiy4s0ad.bkt.clouddn.com/soundblog/1521446569528.jpg" alt="tomcat2"></li>
</ul>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>session共享</tag>
        <tag>memcached</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习实战-8预测数值型数据-回归</title>
    <url>/2017/11/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-8%E9%A2%84%E6%B5%8B%E6%95%B0%E5%80%BC%E5%9E%8B%E6%95%B0%E6%8D%AE-%E5%9B%9E%E5%BD%92/</url>
    <content><![CDATA[<blockquote>
<p>回归和分类是机器学习两个主要的类别，通常会在面试的时候，被询问这两者之间的区别。对于我，有时候我也无法说清，虽然我感觉我已经弄懂了，但是这里还是说一说自己的理解。首先，我们学过一本书《随机过程》，这里面讲到了马尔科夫链等，这是一种在时间、位置等有序列属性的数据，也就是说，这些说句不仅仅存在关系，而且存在一种序列上的前后关系，如时间、地理位置等。而分类一般核心不在于此。所以，回归问题就是一种序列预测问题，比如预测房价-时间、房间-面积、股票-时间等序列关系，通过模拟之前的序列来预测之后的序列。最简单，如线性回归，这就像我们解一元方程y=ax一样，解出a就可以了。但是，存在一个问题，这个直线是不是太直了，可能是个曲线了？或者说，更应该是是一个近似曲线的波浪线了？所以，回归的问题就开始复杂了，此时，我们开始了一些波动预测。采用的一种方式就是，对于每一个数据都有一个权重，而不是只有一个。即我们不是求单个方程，而是求解整个片段的方程，每一个点都有权值，遮掩，我们就将这个权值序列向后移动，以此来预测后来的值，即已有[1-100],那么就可以预测[2-101]来得出x=101的值，以此类推。</p>
</blockquote>
<hr>
<p><strong>一、线性回归</strong></p>
<p>通俗一定，线性回归就是多元以此方程组，多元指的就是多个特征值。回归最早是由达尔文的表兄弟发明的，当时他的目的是为了通过豌豆上一代的尺寸来预测下一代的尺寸，这正是回归问题。为什么叫做回归？是因为当时他发现一般人的身高虽然遗传来自父母，但是整体上还是会向均值靠近，即回归（即便他的父母很高），这个名词和这里的意义不大，但是还是有那么点意思，即任何数据都会靠近正常预测水平，不会太不靠谱（强行解释–）</p>
<ol>
<li>原理<br>一般使用平方误差计算（因为单减误差会互相抵消）：<br><img src="./images/1511532350867.jpg" alt="enter description here"><br>对w求导，等于0，得：<br><img src="./images/1511532402276.jpg" alt="enter description here"></li>
</ol>
<ol start="2">
<li>衡量分离的好坏，有一个方式就是通过corrcoef函数来求解相关系数，越接近0，相关性越大，说明预测越好</li>
</ol>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="./images/Figure_1-2.png" alt="enter description here" title="Figure_1-2"></h2><p><strong>二、局部加权回归</strong></p>
<blockquote>
<p>线性回归有个很大的缺点，即欠拟合，太直了，不知道转弯，就是一条直线（它求得是最小均方误差的无偏估计）；所以，为了防止这种情况，引入一些偏差进来，相当于做一个缓冲作用，从而降低均方误差。局部加权回归LWLR就是其中的一种</p>
</blockquote>
<ol>
<li>对每一个数据都加入一个权重系数W,最终的回归系数w就是：<br><img src="./images/1511532923367.jpg" alt="enter description here"></li>
<li>核<br>这里的核类似于支持向量机中的核，通过这个核来对附近的点赋予更高的权重，一般使用的是高斯核：<br><img src="./images/1511533082575.jpg" alt="enter description here"></li>
<li>注意，这里的代码和线性回归不同，因为它不是一条直线，而是每个点都是一个单独计算的，所以最后的划线是片段性的。</li>
</ol>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="./images/Figure_1-3.png" alt="enter description here" title="Figure_1-3"></h2><p>**三、缩减系数来“理解”数据</p>
<blockquote>
<p>对于分类还是回归问题，我们时常遇到数据特征比样本数量还多的情况。如果是这种情况，由于(xTx)^-1不能计算，所以是无法解决的。为了解决这个问题，我们想到了在矩阵中加入一个额外的数据，类似于补充特征。这里讲述两种方式：<strong>岭回归</strong>和<strong>lasso法(本文采用类的前向逐步回归)</strong></p>
</blockquote>
<ol>
<li>岭回归</li>
</ol>
<ul>
<li>岭回归就是在上面提到的矩阵上加一个λI 从而使矩阵非奇异（参考奇异值分解），这样就可以求逆了。之后的公式为：<br><img src="./images/1511533825131.jpg" alt="enter description here"></li>
<li>为什么叫做缩减？因为通过引入惩罚项后，可以限制所有w的和，这样就能够减少不重要的参数，在统计学上就叫做缩减，这样能更好的理解数据（奇异值分解就是这个作用，提取出关键的信息点）</li>
<li>标准化问题：这里对特征进行了标准化处理，以使特征具有相同的重要性（这里的处理类似于归一化，但是在归一化的基础上又除以了跨度值）；而对于结果y只有归一化。<br><img src="./images/Figure_1-4.png" alt="enter description here" title="Figure_1-4"></li>
</ul>
<ol start="2">
<li>lasso</li>
</ol>
<ul>
<li>这种方式通过对每一个点进行上下浮动取值，来定点优化；从而遍历优化所有的w<br><img src="./images/Figure_1-5.png" alt="enter description here" title="Figure_1-5"></li>
<li><em>四、代码*</em></li>
</ul>
<ol>
<li>regression.py</li>
</ol>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="string">""</span><span class="string">" </span></span><br><span class="line"><span class="string">@author: zoutai</span></span><br><span class="line"><span class="string">@file: regression.py </span></span><br><span class="line"><span class="string">@time: 2017/11/24 </span></span><br><span class="line"><span class="string">@description:逻辑回归</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br><span class="line"></span><br><span class="line"># 相对于分类所不同的是，逻辑回归更适合处理数据之间有连续关系的数据</span><br><span class="line"># 线性回归就像是近似拟合直线，比如房价的走势等，找到一条最近似的直接来进行模拟，以便于能够预测将来的数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">from math import *</span><br><span class="line">from numpy import *</span><br><span class="line"></span><br><span class="line">def loadDataSet(fileName):      #general function to parse tab -delimited floats</span><br><span class="line">    numFeat = len(open(fileName).readline().split(<span class="string">'\t'</span>)) - <span class="number">1</span> <span class="selector-id">#get</span> number of fields</span><br><span class="line">    dataMat = []; labelMat = []</span><br><span class="line">    fr = open(fileName)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> fr.readlines():</span><br><span class="line">        lineArr =[]</span><br><span class="line">        curLine = line.strip().split(<span class="string">'\t'</span>)</span><br><span class="line">        <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(numFeat):</span><br><span class="line">            lineArr.append(<span class="attribute">float</span>(curLine[i]))</span><br><span class="line">        dataMat.append(lineArr)</span><br><span class="line">        labelMat.append(<span class="attribute">float</span>(curLine[-<span class="number">1</span>]))</span><br><span class="line">    return dataMat,labelMat</span><br><span class="line"></span><br><span class="line"># 1、线性回归-最小二乘法</span><br><span class="line"># 求解线性回归的权重参数w，求导解，公式为：w=(X.T * X)^(-1) * (X.T * Y)</span><br><span class="line">def standRegres(xArr,yArr):</span><br><span class="line">    xMat = mat(xArr);yMat = mat(yArr).T</span><br><span class="line">    xtx = xMat.T * xMat</span><br><span class="line"></span><br><span class="line">    # 这里需要保证xtx的秩不能为0，否则没有逆矩阵-1</span><br><span class="line">    <span class="keyword">if</span> linalg.det(xtx) == <span class="number">0.0</span>:</span><br><span class="line">        print(<span class="string">"This matrix is single,cannot do inverse"</span>)</span><br><span class="line">        return</span><br><span class="line">    w = xtx.I * (xMat.T * yMat)</span><br><span class="line">    return w</span><br><span class="line"></span><br><span class="line"># 2、局部加权回归LWLR</span><br><span class="line"># 1中的线性回归有个问题，就是欠拟合，太老实了；不知道转个弯变通一下。因为它求的是最小均方误差的无偏估计（即保证整个过程是条直线，不转弯）</span><br><span class="line"># 因此引入一定的偏差，从而降低预测的均方误差</span><br><span class="line"></span><br><span class="line"># 与线性回归有一点差别，这里面主要是引入了回归系数w</span><br><span class="line"># 公式为：w=(X.T * W * X)^(-1) * (X.T * W * Y)</span><br><span class="line">def lwlr(testPoint,xArr,yArr,k=1.0):</span><br><span class="line">    xMat = mat(xArr)</span><br><span class="line">    yMat = mat(yArr).T</span><br><span class="line">    m = shape(xMat)[<span class="number">0</span>]</span><br><span class="line">    weight = mat(eye(m))</span><br><span class="line">    <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(m):</span><br><span class="line">        diffI = testPoint - xMat[<span class="selector-tag">i</span>,:]</span><br><span class="line">        weight[i,i] = exp(diffI * diffI.T/(-2.0*k**2))</span><br><span class="line"></span><br><span class="line">    xtx = xMat.T * weight * xMat</span><br><span class="line">    <span class="keyword">if</span> linalg.det(xtx) == <span class="number">0.0</span>:</span><br><span class="line">        print(<span class="string">"This matrix is single,cannot do inverse"</span>)</span><br><span class="line">        return</span><br><span class="line">    w = xtx.I * (xMat.T * weight * yMat)</span><br><span class="line">    return testPoint * w # 注意矩阵相乘是的前后顺序</span><br><span class="line"></span><br><span class="line">def lwlrTest(testArr,xArr,yArr,k=1.0):</span><br><span class="line">    m = shape(testArr)[<span class="number">0</span>]</span><br><span class="line">    yHat  = zeros(m)</span><br><span class="line">    <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(m):</span><br><span class="line">        yHat[i] = lwlr(testArr[i],xArr,yArr,k)</span><br><span class="line">    return yHat</span><br><span class="line"></span><br><span class="line">def rssError(yArr,yHatArr):</span><br><span class="line">    return ((yArr - yHatArr)**<span class="number">2</span>).sum()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 3、岭回归</span><br><span class="line">def ridgeRegres(xMat, yMat, lam=0.2):</span><br><span class="line">    xTx = xMat.T * xMat</span><br><span class="line">    denom = xTx + eye(shape(xMat)[1]) * lam</span><br><span class="line">    <span class="keyword">if</span> linalg.det(denom) == <span class="number">0.0</span>:</span><br><span class="line">        print(<span class="string">"This matrix is singular, cannot do inverse"</span>)</span><br><span class="line">        return</span><br><span class="line">    ws = denom.I * (xMat.T * yMat)</span><br><span class="line">    return ws</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def ridgeTest(xArr, yArr):</span><br><span class="line">    xMat = mat(xArr);</span><br><span class="line">    yMat = mat(yArr).T</span><br><span class="line">    yMean = mean(yMat, <span class="number">0</span>)</span><br><span class="line">    yMat = yMat - yMean  # to eliminate X0 take mean off of Y</span><br><span class="line">    # regularize X's</span><br><span class="line">    xMeans = mean(xMat, 0)  # calc mean then subtract it off</span><br><span class="line">    xVar = var(xMat, 0)  # calc variance of Xi then divide by it</span><br><span class="line">    xMat = (xMat - xMeans) / xVar</span><br><span class="line">    numTestPts = <span class="number">30</span></span><br><span class="line">    wMat = zeros((numTestPts, shape(xMat)[<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(numTestPts):</span><br><span class="line">        ws = ridgeRegres(xMat, yMat, exp(<span class="selector-tag">i</span> - <span class="number">10</span>))</span><br><span class="line">        wMat[<span class="selector-tag">i</span>, :] = ws.T</span><br><span class="line">    return wMat</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 直到这里我才理解回归的精髓，即这里面并不是求解一个w值，而是求出一个序列的w序列，</span><br><span class="line"># 然后根据这个序列预测后一个序列的值！</span><br><span class="line"></span><br><span class="line"># 前向逐步线性回归（这里面重点是将x,y归一化；其中x是标准化处理，y进行归一化处理，都汇集到0处，</span><br><span class="line"># 这样，x-y系数就为1，近似单位一的正相关）</span><br><span class="line"># 即求解y=x上下浮动近似</span><br><span class="line"></span><br><span class="line"># 正则化</span><br><span class="line">def regularize(xMat):#regularize by columns</span><br><span class="line">    inMat = xMat.copy()</span><br><span class="line">    inMeans = mean(inMat,<span class="number">0</span>)   <span class="selector-id">#calc</span> mean then subtract it off</span><br><span class="line">    inVar = var(inMat,<span class="number">0</span>)      <span class="selector-id">#calc</span> variance of Xi then divide by it</span><br><span class="line">    inMat = (inMat - inMeans)/inVar</span><br><span class="line">    return inMat</span><br><span class="line"></span><br><span class="line"># 这里我弄不清了：为什么x需要除以一个数，而y不需要？</span><br><span class="line">def stageWise(xArr,yArr,eps=0.01,numIt=100):</span><br><span class="line">    xMat = mat(xArr);yMat = mat(yArr).T</span><br><span class="line">    yMean = mean(yMat)</span><br><span class="line">    yMat = yMat - yMean</span><br><span class="line">    xMat = regularize(xMat)</span><br><span class="line">    m,n = shape(xMat)</span><br><span class="line"></span><br><span class="line">    returnMat = zeros((numIt,n))</span><br><span class="line">    ws = zeros((n,<span class="number">1</span>))</span><br><span class="line">    wsTest = ws.copy()</span><br><span class="line">    wsMax = ws.copy()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(numIt):</span><br><span class="line">        print(ws.T)</span><br><span class="line">        lowestError = inf</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> signal <span class="keyword">in</span> [-<span class="number">1</span>,<span class="number">1</span>]:</span><br><span class="line">                wsTest = ws.copy()</span><br><span class="line">                wsTest[j] += eps * signal</span><br><span class="line">                yTest = xMat * wsTest</span><br><span class="line">                rssE = rssError(yTest<span class="selector-class">.A</span>,yMat.A)</span><br><span class="line">                <span class="keyword">if</span> rssE &lt; lowestError:</span><br><span class="line">                    lowestError = rssE</span><br><span class="line">                    wsMax = wsTest</span><br><span class="line">        ws = wsMax.copy()</span><br><span class="line">        returnMat[<span class="selector-tag">i</span>,:] = ws.T</span><br><span class="line">    return returnMat</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>测试段：</li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="string">""</span><span class="string">" </span></span><br><span class="line"><span class="string">@author: zoutai</span></span><br><span class="line"><span class="string">@file: test.py </span></span><br><span class="line"><span class="string">@time: 2017/11/24 </span></span><br><span class="line"><span class="string">@description: </span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">from unit08<span class="selector-class">.regression</span> import *</span><br><span class="line"></span><br><span class="line">xArr,yArr = loadDataSet(<span class="string">"ex0.txt"</span>)</span><br><span class="line">xMat = mat(xArr)</span><br><span class="line">yMat = mat(yArr)</span><br><span class="line">w = standRegres(xArr,yArr)</span><br><span class="line">yHat = mat(xArr) * w</span><br><span class="line"></span><br><span class="line">import matplotlib<span class="selector-class">.pyplot</span> as plt</span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax =fig.add_subplot(<span class="number">111</span>)</span><br><span class="line"></span><br><span class="line"># 1、flatten()将数据都表示称一维数据，但是数据格式还是原来的维数</span><br><span class="line"># 2、A[0]，A相当于原矩阵(?)</span><br><span class="line">ax.scatter(xMat[:,<span class="number">1</span>].flatten()<span class="selector-class">.A</span>[<span class="number">0</span>],yMat<span class="selector-class">.T</span>[:,<span class="number">0</span>].flatten()<span class="selector-class">.A</span>[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"># 这里画图没有排序，下一个实验会发现有错误</span><br><span class="line">ax.plot(xMat[:,<span class="number">1</span>].flatten()<span class="selector-class">.A</span>[<span class="number">0</span>],yHat)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 评测预测准确度：相关系数cov：函数corrcoef()</span><br><span class="line">covMat = corrcoef(yMat,yHat.T)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(covMat)</span></span></span><br><span class="line"># the result is:</span><br><span class="line"># [[ 1.          0.98647356]</span><br><span class="line">#  [ 0.98647356  1.        ]]</span><br><span class="line"># 对角表示自己和自己的关联度，为1,；0.98为这两个的关联度，越接近1，表示越好</span><br></pre></td></tr></table></figure>


<hr>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="string">""</span><span class="string">" </span></span><br><span class="line"><span class="string">@author: zoutai</span></span><br><span class="line"><span class="string">@file: test.py </span></span><br><span class="line"><span class="string">@time: 2017/11/24 </span></span><br><span class="line"><span class="string">@description: </span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">from unit08<span class="selector-class">.regression</span> import *</span><br><span class="line"></span><br><span class="line">xArr,yArr = loadDataSet(<span class="string">"ex0.txt"</span>)</span><br><span class="line">xMat = mat(xArr)</span><br><span class="line">yMat = mat(yArr)</span><br><span class="line"><span class="selector-id">#yHat</span> = lwlrTest(xArr,xArr,yArr,<span class="number">0.003</span>)</span><br><span class="line">yHat = lwlrTest(xArr,xArr,yArr,<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import matplotlib<span class="selector-class">.pyplot</span> as plt</span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax =fig.add_subplot(<span class="number">111</span>)</span><br><span class="line"></span><br><span class="line"># 1、flatten()将数据都表示称一维数据，但是数据格式还是原来的维数</span><br><span class="line"># 2、A[0]，A相当于原矩阵(?)</span><br><span class="line"></span><br><span class="line"># 排序</span><br><span class="line">srtInd = xMat[:,1].argsort(0) # 排序后的序号</span><br><span class="line">xSort = xMat[srtInd][:,<span class="number">0</span>,:]</span><br><span class="line"></span><br><span class="line">ax.scatter(xMat[:,<span class="number">1</span>].flatten()<span class="selector-class">.A</span>[<span class="number">0</span>],yMat<span class="selector-class">.T</span>[:,<span class="number">0</span>].flatten()<span class="selector-class">.A</span>[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">ax.plot(xSort[:,<span class="number">1</span>].flatten()<span class="selector-class">.A</span>[<span class="number">0</span>],yHat[srtInd],<span class="attribute">color</span>=<span class="string">'red'</span>,)</span><br><span class="line">ax.set_title(<span class="string">"k = 0.01"</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 评测预测准确度：相关系数cov：函数corrcoef()</span><br><span class="line">covMat = corrcoef(yMat,yHat.T)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(covMat)</span></span></span><br><span class="line"># the result is:</span><br><span class="line"># [[ 1.          0.98647356]</span><br><span class="line">#  [ 0.98647356  1.        ]]</span><br><span class="line"># 对角表示自己和自己的关联度，为1,；0.98为这两个的关联度，越接近1，表示越好</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 预测鲍鱼的年龄(前100个预测后100个)</span><br><span class="line"></span><br><span class="line"># 1加权回归法</span><br><span class="line">abX,abY = loadDataSet(<span class="string">"abalone.txt"</span>)</span><br><span class="line">yHat = lwlrTest(abX[<span class="number">100</span>:<span class="number">199</span>],abX[<span class="number">0</span>:<span class="number">99</span>],abY[<span class="number">0</span>:<span class="number">99</span>],<span class="number">10</span>)</span><br><span class="line">error1 = rssError(yHat<span class="selector-class">.T</span>,abY[<span class="number">100</span>:<span class="number">199</span>])</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">"the lwlr error is :"</span>,error1)</span></span></span><br><span class="line"></span><br><span class="line">ws = standRegres(abX[<span class="number">0</span>:<span class="number">99</span>],abY[<span class="number">0</span>:<span class="number">99</span>])</span><br><span class="line">yHat2 = abX[100:199] * ws</span><br><span class="line">error2 = rssError(yHat2.T.A,abY[100:199]) # .A运算应该是将mat矩阵转化为array数组</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">"stand error is :"</span>,error2)</span></span></span><br><span class="line"></span><br><span class="line"># the result is :</span><br><span class="line"># the lwlr error is : 517.571190538</span><br><span class="line"># stand error is : 518.636315325</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># test3、岭回归</span><br><span class="line">ridgeWeights = ridgeTest(abX,abY)</span><br></pre></td></tr></table></figure>


<hr>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="string">""</span><span class="string">" </span></span><br><span class="line"><span class="string">@author: zoutai</span></span><br><span class="line"><span class="string">@file: test.py </span></span><br><span class="line"><span class="string">@time: 2017/11/24 </span></span><br><span class="line"><span class="string">@description: </span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">from unit08<span class="selector-class">.regression</span> import *</span><br><span class="line"></span><br><span class="line">xArr,yArr = loadDataSet(<span class="string">"ex0.txt"</span>)</span><br><span class="line">xMat = mat(xArr)</span><br><span class="line">yMat = mat(yArr)</span><br><span class="line">import matplotlib<span class="selector-class">.pyplot</span> as plt</span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax =fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">abX,abY = loadDataSet(<span class="string">"abalone.txt"</span>)</span><br><span class="line"></span><br><span class="line"># test3、岭回归</span><br><span class="line"># 这个地方我没有仔细思考，直接摘录来了</span><br><span class="line">ridgeWeights = ridgeTest(abX,abY)</span><br><span class="line">ax.plot(ridgeWeights)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<hr>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="string">""</span><span class="string">" </span></span><br><span class="line"><span class="string">@author: zoutai</span></span><br><span class="line"><span class="string">@file: test.py</span></span><br><span class="line"><span class="string">@time: 2017/11/24</span></span><br><span class="line"><span class="string">@description:</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">from unit08<span class="selector-class">.regression</span> import *</span><br><span class="line"></span><br><span class="line">xArr,yArr = loadDataSet(<span class="string">"ex0.txt"</span>)</span><br><span class="line">xMat = mat(xArr)</span><br><span class="line">yMat = mat(yArr)</span><br><span class="line">import matplotlib<span class="selector-class">.pyplot</span> as plt</span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax =fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">abX,abY = loadDataSet(<span class="string">"abalone.txt"</span>)</span><br><span class="line"></span><br><span class="line"># test3、岭回归</span><br><span class="line"># 这个地方我没有仔细思考，直接摘录来了</span><br><span class="line">ridgeWeights = stageWise(abX,abY,<span class="number">0.001</span>,<span class="number">5000</span>)</span><br><span class="line">ax.plot(ridgeWeights)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>ML/DL</category>
      </categories>
      <tags>
        <tag>线性回归</tag>
        <tag>局部加权</tag>
        <tag>岭回归</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习实战-10k-means聚类</title>
    <url>/2017/11/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-10k-means%E8%81%9A%E7%B1%BB/</url>
    <content><![CDATA[<blockquote>
<p>一句话总结，即将数据集分为k个类别。原理：1、首先选取k个初始点作为中心；然后遍历所有的点，对于每一个点，计算k个中心中到这个点距离最小的中心，然后将这个点划分到这个中心；3、当所有的点划分完毕，重新计算类别的计算中心（将均值作为中心），直到中心点不再变化。但是这种方式可能陷入局部最小解，为了克服这个缺陷，提出了二分k-means算法，这种方式类似于二分法。即先划分两类，然后，再将其中一类划分为两类，这样就扩展到三类，一次类推。对于到底选取哪一类进行扩张，衡量刻度是到质心的总距离，选取最小的那一个。</p>
</blockquote>
<hr>
<p>一、应用场景<br>这是一种无监督的学习，一般用来划分，实际生活中常常遇到，比如村落的划分，经常是把村落聚集的一个划分为一个村落。同样比如美国的大选，对于某一些地区的选民，很显然有一部分选民很大程度上是一致的态度，如果能找到他们这一个群里，汇集起来，就可以专门针对，来进行宣传。同样，对于推荐系统等，找到某一类共同特制的人群，也可以进行定点推销。</p>
<hr>
<p>二、聚类算法<br>由于原理简单，只是动手做了原理部分，没有亲自实现案列部分。<br><img src="./images/Figure_1-2.png" alt="第二部分实验图-书上未给代码" title="Figure_1-2"><br>代码：kMeans.py</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="string">""</span><span class="string">" </span></span><br><span class="line"><span class="string">@author: zoutai</span></span><br><span class="line"><span class="string">@file: kMeans.py </span></span><br><span class="line"><span class="string">@time: 2017/11/20 </span></span><br><span class="line"><span class="string">@description: K-均值聚类</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br><span class="line"></span><br><span class="line">from numpy import *</span><br><span class="line"></span><br><span class="line">def loadDataSet(fileName):      #general function to parse tab -delimited floats</span><br><span class="line">    dataMat = []                <span class="selector-id">#assume</span> last column is target value</span><br><span class="line">    fr = open(fileName)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> fr.readlines():</span><br><span class="line">        curLine = line.strip().split(<span class="string">'\t'</span>)</span><br><span class="line">        fltLine = list(map(<span class="attribute">float</span>,curLine)) #map all elements to float()</span><br><span class="line">        dataMat.append(fltLine)</span><br><span class="line">    return dataMat</span><br><span class="line"></span><br><span class="line"># 距离计算函数：欧氏距离</span><br><span class="line">def distEclud(vecA,vecB):</span><br><span class="line">    return sqrt(sum(power(vecA-vecB,<span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">def randCent(dataSet,k):</span><br><span class="line">    n = shape(dataSet)[<span class="number">1</span>]</span><br><span class="line">    centroids = mat(zeros((k,n)))</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">        minJ = min(dataSet[:,j])</span><br><span class="line">        rangJ = <span class="attribute">float</span>(max(dataSet[:,j])-minJ)</span><br><span class="line">        centroids[:,j] = minJ + rangJ * random.rand(k,1) # 随机数范围0-1，矩阵为k*1</span><br><span class="line">    return centroids</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">def kMeans(dataSet,k,distMeas=distEclud,createCent=randCent):</span><br><span class="line">    m = shape(dataSet)[<span class="number">0</span>]</span><br><span class="line">    clusterAssment = mat(zeros((m,<span class="number">2</span>)))</span><br><span class="line">    centroids = createCent(dataSet,k)</span><br><span class="line">    clusterChanged = True</span><br><span class="line">    while clusterChanged:</span><br><span class="line">        clusterChanged = False</span><br><span class="line">        <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(m):</span><br><span class="line">            minDist = inf;minIndex = -1</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(k):</span><br><span class="line">                distJI = distEclud(centroids[j,:],dataSet[<span class="selector-tag">i</span>,:])</span><br><span class="line">                <span class="keyword">if</span> distJI &lt; minDist:</span><br><span class="line">                    minDist = distJI</span><br><span class="line">                    minIndex = j</span><br><span class="line">            # 是否更新质心，重新扫描。（即如果全部的点最后都不改变了，则停止学习）</span><br><span class="line">            <span class="keyword">if</span> clusterAssment[<span class="selector-tag">i</span>,<span class="number">0</span>] != minIndex:</span><br><span class="line">                clusterChanged = True</span><br><span class="line">            clusterAssment[i,:] = minIndex,minDist**2 # 记录点所属的簇</span><br><span class="line">        print(centroids)</span><br><span class="line">        # 更新质心</span><br><span class="line">        <span class="keyword">for</span> cent <span class="keyword">in</span> range(k):</span><br><span class="line">            ptsInClust = dataSet[nonzero(clusterAssment[:,0]==cent)[0]] # 第cent簇的点集合</span><br><span class="line">            centroids[cent,:] = mean(ptsInClust,axis=<span class="number">0</span>) #取均值作为质心</span><br><span class="line">    return centroids,clusterAssment</span><br><span class="line"></span><br><span class="line">def biKmeans(dataSet,k,disMeas=distEclud):</span><br><span class="line">    m = shape(dataSet)[<span class="number">0</span>]</span><br><span class="line">    clusterAssment = mat(zeros((m,<span class="number">2</span>)))</span><br><span class="line">    # 1，先求出所有点的质心</span><br><span class="line">    centroid0 = mean(dataSet,axis=<span class="number">0</span>).tolist()[<span class="number">0</span>]</span><br><span class="line">    centList = [centroid0] # 保存所有的质心</span><br><span class="line"></span><br><span class="line">    # 遍历，求出每个点到质心的距离^2</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">        clusterAssment[j,1] = distEclud(mat(centroid0),dataSet[j,:])**2 # ^2是错误的</span><br><span class="line"></span><br><span class="line">    while len(centList) &lt; k:</span><br><span class="line">        lowestSSE = inf</span><br><span class="line"></span><br><span class="line">        # 2,接下来，对已经划分完成的，尝试将每一个k类二次划分，找出最好的，就相当于增加了一个类</span><br><span class="line">        <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(len(centList)):</span><br><span class="line">            ptsInCurrCluster = dataSet[nonzero(clusterAssment[:,0].A==i)[0],:] # 生成所有第i类的数据集datasetI</span><br><span class="line">            # 不知道哪里逻辑错了，这里需要判断空</span><br><span class="line">            <span class="keyword">if</span> len(ptsInCurrCluster)==<span class="number">0</span>:</span><br><span class="line">                continue</span><br><span class="line">            centroidIMat,splitClustAss = kMeans(ptsInCurrCluster,2,disMeas) # 求出新的子划分</span><br><span class="line"></span><br><span class="line">            # 计算新的总误差大小：sum = 1第I个新的子划分+2（原始的划分-第I个划分）</span><br><span class="line">            # 1.第I个新的子划分误差</span><br><span class="line">            firstSplit = sum(splitClustAss[:,<span class="number">1</span>])</span><br><span class="line">            secondSplit = sum(clusterAssment[nonzero(clusterAssment[:,<span class="number">0</span>]<span class="selector-class">.A</span> != i)[<span class="number">0</span>],<span class="number">1</span>])</span><br><span class="line">            print(<span class="string">"firstSplit is :"</span>,firstSplit,<span class="string">"secondSplit is ；"</span>,secondSplit)</span><br><span class="line"></span><br><span class="line">            # 如果小于原始误差，则划分保存</span><br><span class="line">            <span class="keyword">if</span> firstSplit + secondSplit &lt; lowestSSE:</span><br><span class="line">                bestCentToSplit = i</span><br><span class="line">                bestNewCents = centroidIMat</span><br><span class="line">                bestClustAss = splitClustAss.copy()</span><br><span class="line">                lowestSSE = firstSplit+secondSplit</span><br><span class="line"></span><br><span class="line">        # 更新分配结果，将上面得到的最好结果保存:</span><br><span class="line">        # 将新划分的两类划分给原始集合：第一类划分下标为被分解的簇bestCentToSplit，第二类，为新的簇，即len(centList)</span><br><span class="line">        bestClustAss[nonzero(bestClustAss[:,<span class="number">0</span>]<span class="selector-class">.A</span> == <span class="number">0</span>)[<span class="number">0</span>],<span class="number">0</span>] = bestCentToSplit</span><br><span class="line">        bestClustAss[nonzero(bestClustAss[:,<span class="number">0</span>]<span class="selector-class">.A</span> == <span class="number">1</span>)[<span class="number">0</span>],<span class="number">0</span>] = len(centList)</span><br><span class="line"></span><br><span class="line">        print(<span class="string">"the bestCentToSplit is"</span>,bestCentToSplit)</span><br><span class="line"></span><br><span class="line">        # 将第bestCentToSplit个修改；增加另外一个</span><br><span class="line">        centList[bestCentToSplit] = bestNewCents[<span class="number">0</span>,:]</span><br><span class="line">        centList.append(bestNewCents[<span class="number">1</span>,:])</span><br><span class="line">        # 赋均值</span><br><span class="line">        clusterAssment[nonzero(clusterAssment[:,<span class="number">0</span>]<span class="selector-class">.A</span> == bestCentToSplit)[<span class="number">0</span>],:] = bestClustAss</span><br><span class="line">    return centList,clusterAssment</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import urllib</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def geoGrab(stAddress, city):</span><br><span class="line">    apiStem = 'http://where.yahooapis.com/geocode?'  # create a dict and constants for the goecoder</span><br><span class="line">    params = &#123;&#125;</span><br><span class="line">    params['flags'] = 'J'  # JSON return type</span><br><span class="line">    params[<span class="string">'appid'</span>] = <span class="string">'aaa0VN6k'</span></span><br><span class="line">    params['location'] = '%s %s' % (stAddress, city)</span><br><span class="line">    url_params = urllib.urlencode(params)</span><br><span class="line">    yahooApi = apiStem + url_params  # print url_params</span><br><span class="line">    print(yahooApi)</span><br><span class="line">    c = urllib.urlopen(yahooApi)</span><br><span class="line">    return json.loads(c.read())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">from <span class="selector-tag">time</span> import sleep</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def massPlaceFind(fileName):</span><br><span class="line">    fw = open(<span class="string">'places.txt'</span>, <span class="string">'w'</span>)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> open(fileName).readlines():</span><br><span class="line">        line = line.strip()</span><br><span class="line">        lineArr = line.split(<span class="string">'\t'</span>)</span><br><span class="line">        retDict = geoGrab(lineArr[<span class="number">1</span>], lineArr[<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">if</span> retDict[<span class="string">'ResultSet'</span>][<span class="string">'Error'</span>] == <span class="number">0</span>:</span><br><span class="line">            lat = <span class="attribute">float</span>(retDict[<span class="string">'ResultSet'</span>][<span class="string">'Results'</span>][<span class="number">0</span>][<span class="string">'latitude'</span>])</span><br><span class="line">            lng = <span class="attribute">float</span>(retDict[<span class="string">'ResultSet'</span>][<span class="string">'Results'</span>][<span class="number">0</span>][<span class="string">'longitude'</span>])</span><br><span class="line">            print(lineArr[<span class="number">0</span>], lat, lng)</span><br><span class="line">            fw.write(line,<span class="string">'\t'</span>, lat,<span class="string">'\t'</span>, lng,<span class="string">'\n'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"error fetching"</span>)</span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line">    fw.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def distSLC(vecA, vecB):  # Spherical Law of Cosines</span><br><span class="line">    a = sin(vecA[0, 1] * pi / 180) * sin(vecB[0, 1] * pi / 180)</span><br><span class="line">    b = cos(vecA[0, 1] * pi / 180) * cos(vecB[0, 1] * pi / 180) * \</span><br><span class="line">        cos(pi * (vecB[0, 0] - vecA[0, 0]) / 180)</span><br><span class="line">    return arccos(a + b) * 6371.0  # pi is imported with numpy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import matplotlib</span><br><span class="line">import matplotlib<span class="selector-class">.pyplot</span> as plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def clusterClubs(numClust=5):</span><br><span class="line">    numClust = numClust+1 # 不知道哪里逻辑错了，必须+1，最后会有一个空集</span><br><span class="line">    datList = []</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">'places.txt'</span>).readlines():</span><br><span class="line">        lineArr = line.split(<span class="string">'\t'</span>)</span><br><span class="line">        datList.append([<span class="attribute">float</span>(lineArr[<span class="number">4</span>]), float(lineArr[<span class="number">3</span>])])</span><br><span class="line">    datMat = mat(datList)</span><br><span class="line">    myCentroids, clustAssing = biKmeans(datMat, numClust, disMeas=distSLC)</span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    rect = [<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.8</span>, <span class="number">0.8</span>]</span><br><span class="line">    scatterMarkers = [<span class="string">'s'</span>, <span class="string">'o'</span>, <span class="string">'^'</span>, <span class="string">'8'</span>, <span class="string">'p'</span>, \</span><br><span class="line">                      <span class="string">'d'</span>, <span class="string">'v'</span>, <span class="string">'h'</span>, <span class="string">'&gt;'</span>, <span class="string">'&lt;'</span>]</span><br><span class="line">    axprops = dict(xticks=[], yticks=[])</span><br><span class="line">    ax0 = fig.add_axes(rect, label=<span class="string">'ax0'</span>, **axprops)</span><br><span class="line">    imgP = plt.imread(<span class="string">'Portland.png'</span>)</span><br><span class="line">    ax0.imshow(imgP)</span><br><span class="line">    ax1 = fig.add_axes(rect, label=<span class="string">'ax1'</span>, frameon=False)</span><br><span class="line">    <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(numClust):</span><br><span class="line">        ptsInCurrCluster = datMat[nonzero(clustAssing[:, <span class="number">0</span>]<span class="selector-class">.A</span> == i)[<span class="number">0</span>], :]</span><br><span class="line">        markerStyle = scatterMarkers[i % len(scatterMarkers)]</span><br><span class="line">        ax1.scatter(ptsInCurrCluster[:, <span class="number">0</span>].flatten()<span class="selector-class">.A</span>[<span class="number">0</span>], ptsInCurrCluster[:, <span class="number">1</span>].flatten()<span class="selector-class">.A</span>[<span class="number">0</span>], marker=markerStyle,</span><br><span class="line">                    s=<span class="number">90</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    newDataSet = zeros((len(myCentroids),<span class="number">2</span>))</span><br><span class="line">    newDataSet = [list(array(myCentroids[i])[<span class="number">0</span>]) <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(len(myCentroids))]</span><br><span class="line">    ax1.scatter(mat(newDataSet)[:, <span class="number">0</span>].flatten()<span class="selector-class">.A</span>[<span class="number">0</span>], mat(newDataSet)[:, <span class="number">1</span>].flatten()<span class="selector-class">.A</span>[<span class="number">0</span>], marker=<span class="string">'+'</span>, s=<span class="number">300</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>

<p>画图代码：plotTest.py</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="string">""</span><span class="string">" </span></span><br><span class="line"><span class="string">@author: zoutai</span></span><br><span class="line"><span class="string">@file: plotTest.py </span></span><br><span class="line"><span class="string">@time: 2017/11/22 </span></span><br><span class="line"><span class="string">@description: </span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br><span class="line"></span><br><span class="line"># 画这个图费了好长时间，主要的问题还是在于各种数据类型的转换和匹配，真是想说python真是个垃圾语言，对初学者很难适应</span><br><span class="line"></span><br><span class="line">import matplotlib<span class="selector-class">.pyplot</span> as plt</span><br><span class="line">from numpy import *</span><br><span class="line">def plotGraph(dataSet,centList):</span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line"></span><br><span class="line">    newDataSet = zeros((len(centList),<span class="number">2</span>))</span><br><span class="line">    newDataSet = [list(array(centList[i])[<span class="number">0</span>]) <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(len(centList))]</span><br><span class="line">    # for i in range(len(centList)):</span><br><span class="line">    #     newDataSet.(array(centList[i])[0])</span><br><span class="line">    newMat = mat(newDataSet)</span><br><span class="line">    print(newMat)</span><br><span class="line">    # ax.plot(dataSet[:,0],dataSet[:,1],marker = 'x')</span><br><span class="line">    # ax.plot(centList[:,0],centList[:,1],marker = '+',color='r')</span><br><span class="line">    ax.scatter(dataSet[:,<span class="number">0</span>].flatten()<span class="selector-class">.A</span>[<span class="number">0</span>],dataSet[:,<span class="number">1</span>].flatten()<span class="selector-class">.A</span>[<span class="number">0</span>],marker=<span class="string">'^'</span>,s=<span class="number">90</span>)</span><br><span class="line">    ax.scatter(newMat[:,<span class="number">0</span>].flatten()<span class="selector-class">.A</span>[<span class="number">0</span>],newMat[:,<span class="number">1</span>].flatten()<span class="selector-class">.A</span>[<span class="number">0</span>],marker=<span class="string">'o'</span>,s=<span class="number">90</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>

<p>测试代码：test.py</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="string">""</span><span class="string">" </span></span><br><span class="line"><span class="string">@author: zoutai</span></span><br><span class="line"><span class="string">@file: test.py </span></span><br><span class="line"><span class="string">@time: 2017/11/21 </span></span><br><span class="line"><span class="string">@description: </span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br><span class="line">from unit10<span class="selector-class">.kMeans</span> import *</span><br><span class="line">from unit10<span class="selector-class">.plotTest</span> import *</span><br><span class="line">from numpy import *</span><br><span class="line"></span><br><span class="line"># test1</span><br><span class="line">dataMat = mat(loadDataSet(<span class="string">'testSet.txt'</span>))</span><br><span class="line">myCentroids,clustAssing = kMeans(dataMat,<span class="number">4</span>)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(myCentroids)</span></span></span><br><span class="line"></span><br><span class="line"># test2</span><br><span class="line"># dataMat3 = mat(loadDataSet('testSet2.txt'))</span><br><span class="line"># centList,newAssment = biKmeans(dataMat3,3)</span><br><span class="line"># print(centList)</span><br><span class="line"># plotGraph(dataMat3,centList)</span><br><span class="line"># # dataLast = row_stack(dataMat3,mat(centList))</span><br><span class="line"># print(centList)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># test3</span><br><span class="line"><span class="function"><span class="title">clusterClubs</span><span class="params">(<span class="number">5</span>)</span></span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>ML/DL</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>means</tag>
        <tag>聚类</tag>
        <tag>无监督</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习实战-14利用SVD简化数据-改进推荐系统</title>
    <url>/2017/11/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-14%E5%88%A9%E7%94%A8SVD%E7%AE%80%E5%8C%96%E6%95%B0%E6%8D%AE-%E6%94%B9%E8%BF%9B%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<blockquote>
<p>虽然本章标题是SVD，但是感觉本章的内容核心却有点像是推荐系统，SVD的主要作用优化数据，简化运算。对于推荐系统，生活中处处都是，比如火热的网易云音乐，其中就是用到的因子推荐算法，记得我的第一篇博客就是从知乎上转载下来的；另外还有今日头条；其他的应用其实也有，但是自我感觉，这两个应用应该是最好的。记得最近俱乐部有一个网络订餐推荐系统的项目，而这正是书中所举的例子，作为一个推荐系统，其实饮食推荐系统和音乐推荐有很多类似或者可能完全相同处理。它的基本逻辑就是找和你经常吃同样美食的用户A，然后给你推荐用户A吃过的，而你却没吃的。比如你和A，你们都喜欢吃川菜，但是A吃过夫妻肺片，并且对其评价很好，而你没吃过，这时候，推荐系统通过计算就很可能给你推荐夫妻肺片。</p>
</blockquote>
<blockquote>
<p>由于吴军《数学之美》中对此解释非常好，所以这里转载：<br>“三个矩阵有非常清楚的物理含义。第一个矩阵X中的每一行表示意思相关的一类词，其中的每个非零元素表示这类词中每个词的重要性（或者说相关性），数值越大越相关。最后一个矩阵Y中的每一列表示同一主题一类文章，其中每个元素表示这类文章中每篇文章的相关性。中间的矩阵则表示类词和文章雷之间的相关性。因此，我们只要对关联矩阵A进行一次奇异值分解，w 我们就可以同时完成了近义词分类和文章的分类。（同时得到每类文章和每类词的相关性）。”</p>
</blockquote>
<hr>
<p><strong>一、SVD的应用</strong></p>
<blockquote>
<p>优点：简化数据、去除噪声、提高算法效果<br>缺点：逻辑转换可能难以理解<br>使用类型：数值型数据</p>
</blockquote>
<ol>
<li>隐性语义索引LSI（信息检索）<br>这里，我谈谈我的理解，可能不太准确。首先我们谈谈一般搜索的两个问题：</li>
</ol>
<ul>
<li>关键词写错。比如我搜索“北晶”，我的本意是搜索“北京”，但是搜索引擎还是会给我推荐“北京”的结果。为什么？如果是简单的搜索，搜索引擎将查找所有与“北晶”相关的信息，而忽视“北京”。但是通过SVD，可以将“北京”“背景”“背静”等相似拼音的词语归为一个集合，这样，当搜索不存在是就会判断是否输入错误，已在集合里面查找相关的词语。</li>
<li>同义词搜索。比如我们搜索“SVD”，尽管SVD和PCA可能存在许多的差别，但是在系统内部，由于使用SVD对所有的文章进行处理后发现，SVD和PCA经常一起出现在一篇文章中，因此将这两个次聚为一类，这时当我们搜索“SVD”时，其实，也会给我门提供PCA的信息。<br>上面就是SVD对搜索引擎的改进</li>
</ul>
<ol start="2">
<li>推荐系统<br>在前言中，通过餐厅个性化订餐系统讲述了SVD的应用，其实，这是和信息检索一个道理，就是找到和你口味相同的所有用户，推荐他们吃过，而你没吃过的食物。</li>
</ol>
<hr>
<p><strong>二、矩阵分解和推导</strong><br>SVD也是对矩阵进行分解，但是和特征分解不同，SVD并不要求要分解的矩阵为方阵。假设我们的矩阵A是一个m×n的矩阵，那么我们定义矩阵A的SVD为：<br><img src="./images/1510971623115.jpg" alt="enter description here"><br>　　　　其中U是一个m×m的矩阵，Σ是一个m×n的矩阵，除了主对角线上的元素以外全为0，主对角线上的每个元素都称为奇异值，V是一个n×n的矩阵。U和V都是酉矩阵，即满足UTU=I,VTV=I。下图可以很形象的看出上面SVD的定义：<br><img src="./images/1510971651851.jpg" alt="enter description here"></p>
<p><strong>具体的数学逻辑推导参考：<a href="https://www.zhihu.com/question/22237507" target="_blank" rel="noopener">知乎</a></strong></p>
<p><strong>三、SVD实际应用案例</strong><br>接下来是通过SVD来优化推荐系统，以及压缩图像<br>首先梳理几个点：</p>
<ul>
<li>1.原始推荐系统如何推荐：一般推家系统都是通过计算两个用户的相似度，来进行更推荐</li>
<li>2.相似度的计算：（最后都要归一化到0-1）<ul>
<li>欧式距离</li>
<li>余弦相似度</li>
<li>皮尔逊相关系数<br><img src="./images/1510972417221.jpg" alt="几个相似度计算公式"></li>
</ul>
</li>
<li>3.改进推荐系统：原始的推荐系统需要大量的计算，通过使用SVD简化数据，能够大大加快运算的速度</li>
<li>4.重构矩阵：即尽可能的保留原始矩阵的信息<ul>
<li>我们可以发现得到的特征值，前3个比其他的值大很多，所以可以将最后2个值去掉，因为他们的影响很小。<br><img src="./images/1510972602969.jpg" alt="enter description here"><br><img src="./images/1510972613257.jpg" alt="enter description here"><br><img src="./images/1510972618083.jpg" alt="enter description here"></li>
<li>上面例子就可以将原始数据用如下结果近似：<br><img src="./images/1510972646344.jpg" alt="enter description here"></li>
</ul>
</li>
</ul>
<p><strong>四、推荐系统和图像压缩案例1、2</strong></p>
<ul>
<li>代码svdRec.py</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="string">""</span><span class="string">" </span></span><br><span class="line"><span class="string">@author: zoutai</span></span><br><span class="line"><span class="string">@file: svdRec.py </span></span><br><span class="line"><span class="string">@time: 2017/11/17 </span></span><br><span class="line"><span class="string">@description: </span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br><span class="line">from numpy import *</span><br><span class="line">def loadExData():</span><br><span class="line">    return[[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">           [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">           [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">           [<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">           [<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">           [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">3</span>],</span><br><span class="line">           [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>],]</span><br><span class="line"></span><br><span class="line">def loadExData2():</span><br><span class="line">    return[[<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">           [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>],</span><br><span class="line">           [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>],</span><br><span class="line">           [<span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">           [<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">           [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>],</span><br><span class="line">           [<span class="number">4</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>],</span><br><span class="line">           [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>],</span><br><span class="line">           [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>],</span><br><span class="line">           [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span>],</span><br><span class="line">           [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">def loadExData3():</span><br><span class="line">    return[</span><br><span class="line">           [<span class="number">4</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">           [<span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">3</span>],</span><br><span class="line">           [<span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">           [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>],</span><br><span class="line">           [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">           [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">           [<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line"># 三个相似度计算函数：欧氏距离、余弦函数、皮尔逊相关系数</span><br><span class="line"># 量度在0-1之间，0表示相似度最小，反之越大</span><br><span class="line">def eulidSim(inA,inB):</span><br><span class="line">    return <span class="number">1.0</span>/(<span class="number">1.0</span> + linalg.norm(inA,inB))</span><br><span class="line"></span><br><span class="line">def cosSim(inA,inB):</span><br><span class="line">    num = float(inA.T*inB) # 分子Numerator，分母denominator</span><br><span class="line">    denom = linalg.norm(inA)*linalg.norm(inB)</span><br><span class="line">    return <span class="number">0.5</span>+<span class="number">0.5</span>*(num/denom)</span><br><span class="line"></span><br><span class="line"># 这个内部逻辑不是很清楚</span><br><span class="line">def pearsSim(inA,inB):</span><br><span class="line">    <span class="keyword">if</span> len(inA) &lt; <span class="number">3</span>:</span><br><span class="line">        return  <span class="number">1.0</span></span><br><span class="line">    return 0.5 + 0.5 * corrcoef(inA,inB,rowvar=0)[0][9]</span><br><span class="line"></span><br><span class="line">#第一个推荐引擎，不使用SVD，单纯的相似度计算公式来衡量</span><br><span class="line"># standEst对没有进行评分的物品，进行评分的策略</span><br><span class="line">def standEst(dataMat,user,simMeas,item):</span><br><span class="line">    n = shape(dataMat)[<span class="number">1</span>]</span><br><span class="line">    simTotal = 0.0; rateSimTotal = 0.0</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">        userRating = dataMat[user,j]</span><br><span class="line">        <span class="keyword">if</span> userRating == <span class="number">0</span>:</span><br><span class="line">            continue</span><br><span class="line">        # 寻找对Item和j项商品都进行评分了的所有用户ID</span><br><span class="line">        overLap = nonzero(logical_and(dataMat[:,item]<span class="selector-class">.A</span> &gt; <span class="number">0</span>,dataMat[:,j]<span class="selector-class">.A</span> &gt; <span class="number">0</span>))[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> len(overLap) == <span class="number">0</span>:</span><br><span class="line">            similarity = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            similarity = simMeas(dataMat[overLap,item],dataMat[overLap,j])</span><br><span class="line">        simTotal += similarity</span><br><span class="line">        rateSimTotal += similarity * userRating</span><br><span class="line">    <span class="keyword">if</span> simTotal == <span class="number">0</span>:</span><br><span class="line">        return <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        return rateSimTotal/simTotal</span><br><span class="line"></span><br><span class="line"># estMethod=standEst：传递一个函数</span><br><span class="line">def recommend(dataMat,user,N=3,sigMeas=cosSim,estMethod=standEst):</span><br><span class="line">    unratedItems = nonzero(dataMat[user,:].A==0)[1] # 查找当前user的未评级商品id</span><br><span class="line">    <span class="keyword">if</span> len(unratedItems) == <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">"you rate allItems"</span>)</span><br><span class="line">    itemScores = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> unratedItems:</span><br><span class="line">        iScore = estMethod(dataMat,user,sigMeas,item)</span><br><span class="line">        itemScores.append((item,iScore))</span><br><span class="line">    # 寻找前N项商品，逆序排序；</span><br><span class="line">    # 疑问：这个jj啥意思？我想应该是：</span><br><span class="line">    # jj[1]取的是分数，即按分数来进行排序，取分数最高的N项</span><br><span class="line">    return sorted(itemScores,key=lambda jj:jj[<span class="number">1</span>],reverse=True)[:N]</span><br><span class="line"></span><br><span class="line"># 基于SVD的评分估计-取代standEst</span><br><span class="line">def svdEst(dataMat,user,simMeas,item):</span><br><span class="line">    n = shape(dataMat)[<span class="number">1</span>]</span><br><span class="line">    simTotal = 0.0; rateSimTotal = 0.0</span><br><span class="line"></span><br><span class="line">    # 进行奇异值SVD分解</span><br><span class="line">    U,sigma,VT = linalg.svd(dataMat)</span><br><span class="line">    sigma4 = mat(eye(<span class="number">4</span>)*sigma[:<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">        userRating = dataMat[user,j]</span><br><span class="line">        <span class="keyword">if</span> userRating == <span class="number">0</span> or j == item:</span><br><span class="line">            continue</span><br><span class="line">        # 寻找对Item和j项商品都进行评分了的所有用户ID</span><br><span class="line">        similarity = simMeas(dataMat[item,]<span class="selector-class">.T</span>,dataMat[j,].T)</span><br><span class="line">        simTotal += similarity</span><br><span class="line">        rateSimTotal += similarity * userRating</span><br><span class="line">    <span class="keyword">if</span> simTotal == <span class="number">0</span>:</span><br><span class="line">        return <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        return rateSimTotal/simTotal</span><br><span class="line"></span><br><span class="line">def printMat(inMat,thresh=0.8):</span><br><span class="line">    <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="attribute">float</span>(inMat[i,k]) &gt; thresh:</span><br><span class="line">                print(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="number">0</span>)</span><br><span class="line">        print(<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"># 其实就是一个分解在组合的过程</span><br><span class="line">def imgCompress(numSV=3,thresh=0.8):</span><br><span class="line">    myl = []</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">'0_5.txt'</span>).readlines():</span><br><span class="line">        newLine = []</span><br><span class="line">        <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">            newLine.append(int(line[i]))</span><br><span class="line">        myl.append(newLine)</span><br><span class="line">    myMat = mat(myl)</span><br><span class="line">    print(<span class="string">"原始矩阵："</span>)</span><br><span class="line">    print(myMat,thresh)</span><br><span class="line">    U,sigma,VT = linalg.svd(myMat)</span><br><span class="line">    SigRecon = mat(zeros((numSV,numSV)))</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(numSV):</span><br><span class="line">        SigRecon[k,k] = sigma[k]</span><br><span class="line">    reconMat = U[:,:numSV]*SigRecon*VT[:numSV,:]</span><br><span class="line">    print(<span class="string">"压缩后"</span>)</span><br><span class="line">    printMat(reconMat,thresh)</span><br></pre></td></tr></table></figure>


<ul>
<li>测试代码：test.py </li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="string">""</span><span class="string">" </span></span><br><span class="line"><span class="string">@author: zoutai</span></span><br><span class="line"><span class="string">@file: test.py </span></span><br><span class="line"><span class="string">@time: 2017/11/17 </span></span><br><span class="line"><span class="string">@description: </span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br><span class="line">from numpy import *</span><br><span class="line">from unit14<span class="selector-class">.svdRec</span> import *</span><br><span class="line">set_printoptions(suppress=True) # 设置numpy不以科学计数法输出，即e</span><br><span class="line"># tets1</span><br><span class="line">U,sigma,VT = linalg.svd([[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">7</span>,<span class="number">7</span>]])</span><br><span class="line">#print(U,sigma,VT)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># test2</span><br><span class="line">U,sigma,VT = linalg.svd(loadExData())</span><br><span class="line"># 对角矩阵，但是写成一维数组的形式；[  9.64365076e+00   5.29150262e+00   7.40623935e-16   4.05103551e-16  2.21838243e-32]</span><br><span class="line">print(sigma) # 通过观察sigma发现，前三项远大于后面几项，所以取前三项就能代表所有项</span><br><span class="line"></span><br><span class="line"># 重构对角矩阵（前三项）</span><br><span class="line">sigma3 = mat([[sigma[<span class="number">0</span>],<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,sigma[<span class="number">1</span>],<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,sigma[<span class="number">2</span>]]])</span><br><span class="line"># 还原数据</span><br><span class="line">newDataMat = U[:,:3] * sigma3 * VT[:3,:]</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(array(newDataMat)</span></span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># test3-餐厅菜肴推荐----result:[(2, 2.5), (1, 2.0243290220056256)]</span><br><span class="line"># 再次提醒自己：数据格式，mat，array等的区别，用法</span><br><span class="line">recommendItems = recommend(mat(loadExData3()),<span class="number">2</span>)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">"为第2个用户推荐菜单是："</span>,recommendItems)</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># test4-利用SVD提高优化效果----result:[(3, 3.2440521369249682), (10, 3.1576182912586654), (8, 3.1428571428571428)]</span><br><span class="line">recommendItems4 = recommend(mat(loadExData2()),<span class="number">2</span>,estMethod=svdEst)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">"为第2个用户推荐菜单是："</span>,recommendItems4)</span></span></span><br><span class="line"># 这个此时对不上号，可能存在错误</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 基于SVD的图像压缩</span><br><span class="line"><span class="function"><span class="title">imgCompress</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p><strong>最后、补充内容</strong></p>
<ul>
<li>推荐引擎的检验：检查检验、最小均方根误差</li>
<li>推荐系统其他的改进<ul>
<li>大规模数据，SVD会降低程序的速度，SVD可以在调入时运行一次。之后每天运行一次或者频率更低。不需要频繁运行。并且需要离线运行</li>
<li>节约存储空间：通过观察，我们发现，上面的矩阵存在很多的0值，所以可以不保存这些值，节约内存和计算开销</li>
<li>另外相似度得分不需要每次都计算：可以离线保存相似度得分。另外计算时，物品之间的相似度不同的用户是一样的可以复用</li>
<li>冷启动（面试）：即对于一个新用户或者新的商品，如何推荐？没有相关数据<ul>
<li>可以首次推荐当做搜索问题来处理，用户主动搜索才会出现</li>
</ul>
</li>
<li>对于图像压缩：如果理解SVD的数学公式推导，就不难理解，其实，就是将像素在坐标轴上进行压缩。比如高中，我们学数学向量坐标时，经常做的作业就是平移压缩扩大，比函数y=f(x),横坐标缩小两倍就是：y=f(2x)</li>
</ul>
</li>
</ul>
<p><a href="https://zhuanlan.zhihu.com/p/30238979" target="_blank" rel="noopener">参考链接</a></p>
]]></content>
      <categories>
        <category>ML/DL</category>
      </categories>
      <tags>
        <tag>降维</tag>
        <tag>机器学习</tag>
        <tag>SVD</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习实战-13利用PCA来简化数据</title>
    <url>/2017/11/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-13%E5%88%A9%E7%94%A8PCA%E6%9D%A5%E7%AE%80%E5%8C%96%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<blockquote>
<p>最近正在做一个语音分离的任务，其中有一个语音分离的方法叫做NMF，中文非负矩阵分解，即将矩阵表示为V=WH，m<em>n = m</em>r * r*n；其实这种矩阵分解的方式和本章的内容类似，也是对矩阵进行降维或者简化矩阵；其实有时候并不仅仅是降维，这种方式，也是一种变相提取特征值得过程，其中的W相当于特征向量组，H相当于特征的权重向量组。即PCA不仅仅对数据进行降维，降低了数据的运算量；同时也是一种提取特真的好方法。</p>
</blockquote>
<p><strong>一、前言</strong><br>什么是降维，想象一下，初中时我们学习物理，记得老师经常说，让我们把一个物体看做一个“质点”，比如足球，它就是一个点，就不要关注上面的花纹。所以在足球比赛时，尽管电视机的画面很多，有花有草还有“演员”，但是我们关注的只是足球那一个点。这里的思想其实就是降维，即去掉我们不需要关注的数据或者维度</p>
<p><strong>二、降维技术</strong><br>几种降维技术：</p>
<ol>
<li>主成分分析PCA（principal component analysis）:将数据从原始的坐标系转换到新的坐标系。第一个坐标系选择为原数据方差最大的方向（最大吗？我咋感觉是最小。。），第二个坐标系选择与第一个坐标系（上一个）相正交且方差最大的方向，以此类推，重复次数为原始数据的维数。其实，最后我们发现，大部分方差都包含在前面的几个坐标轴中，所以只需要取前几个坐标轴就行，这就降维了！举个例子：就相当于，我们分类人群性别时，如果知道人群的头发是否是长头发和是否穿牛仔，牛仔的辨识度很差，基本可以抛弃，就不用在考虑这个特征（男女都穿牛仔，没有区分度）</li>
<li>因此分析FA（factor analysis）：这个有点像我们线性倒数中的求解矩阵的基，或者说是单位向量。我们的数据很多，但是猜测我们的数据都是有某些单位向量（隐变量）线性组合来的。即，给了很多坐标数据(1,1)(2,2)(1,3)(2,6)(3,9),看起来很复杂，仔细想想，其实只需要两个数据就能表达，即（1,1）和（1,3），其他都是这两个点的线性组合。官方定义：假设观察数据是某些隐变量和某些噪声的线性组合，我们只需要找到这些隐变量就行</li>
<li>独立成分分析ICA（independence component analysis）：这个和FA有点类似，应该就是单通道语音分离的方式。但是与FA不同的是，我们的这些基（隐变量）不是单个的，可能是一个组合或者一个高斯模型。即我们假设我们的数据是由N个互相独立的数据源组成，与PCA不同，这些数据源互相独立就，这样我们就能分别分离。比如，一个混合的语音信号，这里面有张三的话、李四的话和王健林的话，这里面张三这几个人的话就是相互独立的数据集。</li>
</ol>
<p><strong>三、PCA</strong></p>
<blockquote>
<p>转载：<br>优点：降低数据的复杂性，识别最重要的多个特征。<br>缺点：不一定需要，且可能损失有用信息。<br>使用数据类型：数值型数据。</p>
</blockquote>
<ul>
<li><strong>移动坐标轴</strong></li>
</ul>
<p>考虑一下图1中的大量数据点。若要求画出一条直线，这条线要尽可能覆盖这些点，三条直线中B最长。在PCA中，对数据的坐标进行旋转，该旋转的过程取决于数据的本身。第一条坐标轴旋转到覆盖数据的最大方差为止，即直线B。数据的最大方差给出了数据的最重要的信息。<br><img src="./images/1510845763195.jpg" alt="图1　覆盖整个数据集的三条直线，其中直线B最长，并给出了数据集中差异化最大的方向"></p>
<p>在选择了覆盖数据最大差异性的坐标轴后，继续选择第二条坐标轴。假如该坐标轴与第一条坐标轴垂直，它就是覆盖数据次大差异性的坐标轴。更严谨的说法是正交（orthogonal）。在二维平面下，垂直和正交是一回事。在图1中，直线C就是第二条坐标轴。利用PCA，可将数据坐标轴旋转至数据角度上的那些最重要的方向。<br><img src="./images/1510845793308.jpg" alt="图2　二维空间的三个类别。当在该数据集上应用PCA时，就可以去掉一维，从而使得该分类问题变得更容易处理 "></p>
<p>实现坐标轴旋转后，可讨论降维。坐标轴的旋转并没有减少数据的维度。图2中包含三个不同的类别。要区分这三个类别，可使用决策树。决策树每次都是基于一个特征来做决策。我们会发现，在x轴上可找到一些值，这些值能够很好地将这3个类别分开。这样可得到一些规则，比如当(X&lt;4)时，数据属于类别0。若使用SVM这样稍复杂的分类器，可得到更好的分类面和分类规则，比如当(w0<em>x + w1</em>y + b) &gt; 0时，数据也属于类别0。SVM可能比决策树得到更好的分类间隔，但分类超平面却很难解释。</p>
<p>通过PCA进行降维处理，可同时获得SVM和决策树的优点：一方面，得到了和决策树一样的简单分类器，同时分类间隔和SVM一样好。考虑图2中下面的图，其中的数据来自于上面的图并经PCA转换后绘制而成。如果仅使用原始数据，那么这里的间隔会比决策树的间隔大。另外，由于只需要考虑一维信息，因此数据可通过比SVM简单得多的、且容易采用的规则进行区分。</p>
<p>在图2中，只需一维信息即可，因为另一维信息只是对分类缺乏贡献的噪声数据。在二维平面下，这看上去微不足道，但在高维空间则意义重大。</p>
<p>对PCA的基本过程简单阐述后，接下来可通过代码实现PCA过程。前面提到第一个主成分就是从数据差异性最大（即方差最大）的方向提取出来的，第二个主成分则来自于数据差异次大的方向，并且该方向与第一个主成分方向正交。通过数据集的协方差矩阵及其特征值分析，可以求得这些主成分的值。</p>
<p>一旦得到了协方差矩阵的特征向量，就可以保留最大的N个值。这些特征向量也给出了N个最重要的真实结构。可以通过将数据乘上这N个特征向量而将它转到新的空间。</p>
<ul>
<li>numpy实现PCA降维<br>代码：pca.py</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="string">""</span><span class="string">" </span></span><br><span class="line"><span class="string">@author: zoutai</span></span><br><span class="line"><span class="string">@file: pca.py </span></span><br><span class="line"><span class="string">@time: 2017/11/16 </span></span><br><span class="line"><span class="string">@description: PCA降维</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br><span class="line"></span><br><span class="line">from numpy import *</span><br><span class="line"></span><br><span class="line">def loadDataSet(fileName, delim='\t'):</span><br><span class="line">    fr = open(fileName)</span><br><span class="line">    stringArr = [line.strip().split(delim) <span class="keyword">for</span> line <span class="keyword">in</span> fr.readlines()]</span><br><span class="line">    datArr = [list(map(<span class="attribute">float</span>,line)) for line in stringArr]</span><br><span class="line">    return mat(datArr)</span><br><span class="line"></span><br><span class="line">def pca(dataMat, topNfeat = 9999999):</span><br><span class="line">    meanVals = mean(dataMat,axis=<span class="number">0</span>)</span><br><span class="line">    meanRemoved = dataMat - meanVals</span><br><span class="line">    covMat = cov(meanRemoved,rowvar=0) # 计算协方差矩阵</span><br><span class="line">    eigVal,eigVector = linalg.eig(covMat) # 求协方差矩阵的特征值和特征向量</span><br><span class="line"></span><br><span class="line">    # 对特征值进行排序</span><br><span class="line">    sortEigVals = argsort(eigVal)</span><br><span class="line">    sigValInd = sortEigVals[:-(topNfeat+1):-1] # 从倒数第topNfeat+1个，取到导数第一个</span><br><span class="line">    selectedEigVertor = eigVector[:,sigValInd]</span><br><span class="line"></span><br><span class="line">    # 还原数据</span><br><span class="line">    lowDataMat = meanRemoved * selectedEigVertor</span><br><span class="line">    reconMat = lowDataMat * selectedEigVertor.T + meanVals</span><br><span class="line">    return lowDataMat,reconMat</span><br><span class="line"></span><br><span class="line"># 补全缺失值</span><br><span class="line">def replaceNanWithMean():</span><br><span class="line">    datMat = loadDataSet(<span class="string">'secom.data'</span>, <span class="string">' '</span>)</span><br><span class="line">    numFeat = shape(datMat)[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(numFeat):</span><br><span class="line">        meanVal = mean(datMat[nonzero(~isnan(datMat[:,i].A))[<span class="number">0</span>],i]) <span class="selector-id">#values</span> that are not NaN (<span class="selector-tag">a</span> number)</span><br><span class="line">        datMat[nonzero(isnan(datMat[:,i].A))[<span class="number">0</span>],i] = meanVal  <span class="selector-id">#set</span> NaN values to mean</span><br><span class="line">    return datMat</span><br></pre></td></tr></table></figure>
<p>代码：test.py</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="string">""</span><span class="string">" </span></span><br><span class="line"><span class="string">@author: zoutai</span></span><br><span class="line"><span class="string">@file: test.py </span></span><br><span class="line"><span class="string">@time: 2017/11/16 </span></span><br><span class="line"><span class="string">@description: </span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br><span class="line">from unit13<span class="selector-class">.pca</span> import *</span><br><span class="line">import matplotlib</span><br><span class="line">import matplotlib<span class="selector-class">.pyplot</span> as plt</span><br><span class="line"></span><br><span class="line">dataMat = loadDataSet(<span class="string">'testSet.txt'</span>)</span><br><span class="line">lowMat,reconMat = pca(dataMat,<span class="number">1</span>)</span><br><span class="line"># lowMat,reconMat = pca(dataMat,2) #数据本身只有两个特征，因此当选择2时，数据不区分，数据重合没有线</span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = fig.add_subplot(<span class="number">211</span>)</span><br><span class="line">ax.scatter(dataMat[:,<span class="number">0</span>].flatten()<span class="selector-class">.A</span>[<span class="number">0</span>],dataMat[:,<span class="number">1</span>].flatten()<span class="selector-class">.A</span>[<span class="number">0</span>],marker=<span class="string">'^'</span>,s=<span class="number">90</span>)</span><br><span class="line">ax.scatter(reconMat[:,<span class="number">0</span>].flatten()<span class="selector-class">.A</span>[<span class="number">0</span>],reconMat[:,<span class="number">1</span>].flatten()<span class="selector-class">.A</span>[<span class="number">0</span>],marker=<span class="string">'o'</span>,s=<span class="number">90</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># test2-利用PCA对半导体数据进行降维</span><br><span class="line"># 方差百分比=（选取的特征值之和）/(所有的特征值之和)</span><br><span class="line">dataMat = replaceNanWithMean()</span><br><span class="line">meanVals = mean(dataMat,axis=<span class="number">0</span>)</span><br><span class="line">meanRemoved = dataMat - meanVals</span><br><span class="line">covMat = cov(meanRemoved,rowvar=<span class="number">0</span>)</span><br><span class="line">eigVals,eigVector = linalg.eig(mat(covMat))</span><br><span class="line">sortEigVals = sort(eigVals)</span><br><span class="line">eigSum = sum(sortEigVals)</span><br><span class="line">sigValInd = sortEigVals[:-(20+1):-1] # 从倒数第topNfeat+1个，取到导数第一个</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(sigValInd)</span></span></span><br><span class="line">print(eigVals) # 通过观察可以发现，大部分特征值都是0，只有少部分有用</span><br><span class="line">x=[]</span><br><span class="line">y=[]</span><br><span class="line">allSum = []</span><br><span class="line"><span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">20</span>):</span><br><span class="line">    print(sigValInd[:i])</span><br><span class="line">    addSum = sum(sigValInd[i-<span class="number">1</span>:i])</span><br><span class="line">    x.append(i)</span><br><span class="line">    y.append(<span class="number">10</span>*addSum/eigSum)</span><br><span class="line">    allSum.append(<span class="number">10</span>*sum(sigValInd[<span class="number">0</span>:i])/eigSum)</span><br><span class="line">ax = fig.add_subplot(<span class="number">212</span>)</span><br><span class="line">ax.plot(x,y,marker = <span class="string">'x'</span>)</span><br><span class="line">ax.plot(x,allSum,marker = <span class="string">'+'</span>,<span class="attribute">color</span>=<span class="string">'r'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><strong>小结</strong><br>本章的PCA降维要求将所有的数据都调入内存，即离线形式；目前有一种在线方式的PCA分析，可以参考论文：Incremental Eigenanalysis For Classification<br>参考链接：<a href="http://blog.csdn.net/zhongkelee/article/details/44064401" target="_blank" rel="noopener">http://blog.csdn.net/zhongkelee/article/details/44064401</a></p>
]]></content>
      <categories>
        <category>ML/DL</category>
      </categories>
      <tags>
        <tag>PCA</tag>
        <tag>降维</tag>
        <tag>机器学习</tag>
        <tag>特征提取</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习实战-6支持向量机</title>
    <url>/2017/11/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-6%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/</url>
    <content><![CDATA[<blockquote>
<p>在机器学习几大算法中，支持向量应该算是应用最广泛的，但是却也是理解最困难的。相对于其他的算法而言，这个算法的逻辑可能并不难难，难的是它的内部逻辑转换，如何转化求解最大超平面。其实最近我在想，机器学习有时候感觉理解起来并不太难，有时候相对于其他知识来说，比如电磁场，固体物理等，简直是最简单的，甚至感觉某些人把这个学科神话了。但是这句话我是说不出口的，因为我只是学了个皮毛。学了很多，却总是忘记，因此，在之后的博客中，我将尽可能的详细记录，以便之后自己回顾复习，又花了两天时间，发现这个smo是难以理解，感觉坑有点深，最近事情有比较多，暂且先放一放，转载一篇。</p>
</blockquote>
<hr>
<ul>
<li>前言：对于这一章，有许多的关键点需要掌握，而且每一个关键点都不简单。从前往后一次是：1、什么是支持向量；2、将这种问题转化为对偶问题的凸二次规划问题；3、为了解决速度慢的问题，新的算法使用了SMO算法；4、进一步优化SMO，提出Platt SMO算法。</li>
<li>1、支持向量：相对于逻辑回归而言，SVM其实也是通过一条线段来分割平面，所不同的是，支持向量机的函数刻度不同，SVM找的是离超平面距离最小的“几个”点（几个而不是全部），使其距离最大，即maxmin</li>
<li>2、maxmin这种问题是一种带约束条件的优化问题，可以使用《工程优化》中的知识来求解，即拉格朗日乘子法，引入拉格朗日乘子法后，可以将这个问题转化为对偶形式的凸二次规划问题</li>
<li>3、尽管通过一般的方法，也能够解决凸二次规划问题，但是这种方式太慢，大数据情况下不太实际。1999年微软研究院提出了一种SMO算法，这种算法，通过每次只优化一对alpha值来进行迭代，从而求得最优化的值，迭代过程尽量趋向于不满足kkt条件的（kkt条件是凸二次规划的条件，具体是什么，这方面没有仔细看，理解可能有误）。</li>
<li>4、但是通过观察SMO算法，发现简化的SMO其实存在许多重复的计算，因此，提出了一种启发式方法（启发式，即基于当前的条件选择下一步最优的，每次只知道下“一”步的策略）。其他逻辑和SMO一样，不同的是alpha选择的方式，两种方式交替进行：一种是在所有的数据集上单遍扫描，另一种是只在非边界alpha进行单遍扫描（其中很多alpha值是在边界上）</li>
<li>多说一句，听起来很简单，但是逻辑很复杂</li>
</ul>
<p><strong>后面的暂且转载：</strong><a href="http://www.cnblogs.com/jerrylead/archive/2011/03/18/1988419.html" target="_blank" rel="noopener">链接</a></p>
<div id="cnblogs_post_body"><p><strong><span style="font-size: medium;" size="4">11 SMO优化算法（Sequential minimal optimization）</span></strong> </p>
<p>SMO算法由Microsoft Research的John C. Platt在1998年提出，并成为最快的二次规划优化算法，特别针对线性SVM和数据稀疏时性能更优。关于SMO最好的资料就是他本人写的《Sequential Minimal Optimization A Fast Algorithm for Training Support Vector Machines》了。 </p>
<p>我拜读了一下，下面先说讲义上对此方法的总结。 </p>
<p>首先回到我们前面一直悬而未解的问题，对偶函数最后的优化问题： </p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182042433212.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image001" alt="clip_image001" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182042433179.png" border="0" height="146" width="423"></a> </p>
<p>要解决的是在参数<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182042431751.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image003" alt="clip_image003" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182042445098.png" border="0" height="21" width="84"></a>上求最大值W的问题，至于<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182042448097.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image005" alt="clip_image005" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182042441095.png" border="0" height="21" width="21"></a>和<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182042454094.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image007" alt="clip_image007" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182042451868.png" border="0" height="21" width="20"></a>都是已知数。C由我们预先设定，也是已知数。 </p>
<p>按照坐标上升的思路，我们首先固定除<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182042464867.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image009" alt="clip_image009" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182042467866.png" border="0" height="21" width="14"></a>以外的所有参数，然后在<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182042479228.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image009[1]" alt="clip_image009[1]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182042477767.png" border="0" height="21" width="14"></a>上求极值。等一下，这个思路有问题，因为如果固定<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182042489129.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image009[2]" alt="clip_image009[2]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182042482128.png" border="0" height="21" width="14"></a>以外的所有参数，那么<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182042481538.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image009[3]" alt="clip_image009[3]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182042496522.png" border="0" height="21" width="14"></a>将不再是变量（可以由其他值推出），因为问题中规定了 </p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182042498997.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image010" alt="clip_image010" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182042495060.png" border="0" height="57" width="183"></a> </p>
<p>因此，我们需要一次选取两个参数做优化，比如<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182042506423.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image009[4]" alt="clip_image009[4]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182042503009.png" border="0" height="21" width="14"></a>和<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182042509945.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image012" alt="clip_image012" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182042516847.png" border="0" height="21" width="15"></a>，此时<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182042519846.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image012[1]" alt="clip_image012[1]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182042529256.png" border="0" height="21" width="15"></a>可以由<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182042524207.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image009[5]" alt="clip_image009[5]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182042534697.png" border="0" height="21" width="14"></a>和其他参数表示出来。这样回带到W中，W就只是关于<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182042548469.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image009[6]" alt="clip_image009[6]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182042556418.png" border="0" height="21" width="14"></a>的函数了，可解。 </p>
<p>这样，SMO的主要步骤如下： </p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/20110318204256430.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image013" alt="clip_image013" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/20110318204257680.png" border="0" height="185" width="570"></a> </p>
<p>意思是，第一步选取一对<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182042575630.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image015" alt="clip_image015" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182042584169.png" border="0" height="21" width="13"></a>和<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182042585531.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image017" alt="clip_image017" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182042582118.png" border="0" height="21" width="13"></a>，选取方法使用启发式方法（后面讲）。第二步，固定除<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182042591528.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image015[1]" alt="clip_image015[1]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/20110318204259383.png" border="0" height="21" width="13"></a>和<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043003381.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image017[1]" alt="clip_image017[1]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043006380.png" border="0" height="21" width="13"></a>之外的其他参数，确定W极值条件下的<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043017742.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image015[2]" alt="clip_image015[2]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043016314.png" border="0" height="21" width="13"></a>，<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043017676.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image017[2]" alt="clip_image017[2]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/20110318204302675.png" border="0" height="21" width="13"></a>由<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043021722.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image015[3]" alt="clip_image015[3]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043036672.png" border="0" height="21" width="13"></a>表示。 </p>
<p>SMO之所以高效就是因为在固定其他参数后，对一个参数优化过程很高效。 </p>
<p>下面讨论具体方法： </p>
<p>假设我们选取了初始值<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043031655.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image003[1]" alt="clip_image003[1]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043033051.png" border="0" height="21" width="84"></a>满足了问题中的约束条件。接下来，我们固定<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043031622.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image019" alt="clip_image019" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043038001.png" border="0" height="21" width="84"></a>，这样W就是<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043049048.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image009[7]" alt="clip_image009[7]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043042395.png" border="0" height="21" width="14"></a>和<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043045394.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image012[2]" alt="clip_image012[2]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043058393.png" border="0" height="21" width="15"></a>的函数。并且<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043059755.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image009[8]" alt="clip_image009[8]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043066342.png" border="0" height="21" width="14"></a>和<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043061292.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image012[3]" alt="clip_image012[3]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043072655.png" border="0" height="21" width="15"></a>满足条件： </p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043078718.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image020" alt="clip_image020" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043073145.png" border="0" height="55" width="233"></a> </p>
<p>由于<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043075620.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image019[1]" alt="clip_image019[1]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/20110318204308604.png" border="0" height="21" width="84"></a>都是已知固定值，因此为了方面，可将等式右边标记成实数值<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043089175.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image022" alt="clip_image022" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043086950.png" border="0" height="21" width="6"></a>。 </p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043089425.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image023" alt="clip_image023" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043093536.png" border="0" height="33" width="167"></a> </p>
<p>当<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043096535.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image025" alt="clip_image025" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043107897.png" border="0" height="21" width="22"></a>和<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/20110318204310896.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image027" alt="clip_image027" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043102258.png" border="0" height="21" width="22"></a>异号时，也就是一个为1，一个为-1时，他们可以表示成一条直线，斜率为1。如下图： </p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043119717.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="image" alt="image" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/20110318204311764.png" border="0" height="307" width="433"></a> </p>
<p>横轴是<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043122126.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image009[9]" alt="clip_image009[9]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043124253.png" border="0" height="21" width="14"></a>，纵轴是<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043136695.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image012[4]" alt="clip_image012[4]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043165776.png" border="0" height="21" width="15"></a>，<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043166299.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image009[10]" alt="clip_image009[10]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043177661.png" border="0" height="21" width="14"></a>和<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043179024.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image012[5]" alt="clip_image012[5]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043185610.png" border="0" height="21" width="15"></a>既要在矩形方框内，也要在直线上，因此 </p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043182546.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image044" alt="clip_image044" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043181117.png" border="0" height="42" width="165"></a>，<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043184465.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image046" alt="clip_image046" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043183036.png" border="0" height="42" width="201"></a> </p>
<p>同理，当<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043199938.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image025[1]" alt="clip_image025[1]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043192937.png" border="0" height="21" width="22"></a>和<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043207888.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image027[1]" alt="clip_image027[1]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/20110318204320886.png" border="0" height="21" width="22"></a>同号时， </p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043205870.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image048" alt="clip_image048" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/20110318204321853.png" border="0" height="42" width="199"></a>，<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043214200.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image050" alt="clip_image050" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043212772.png" border="0" height="42" width="167"></a> </p>
<p>然后我们打算将<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043216086.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image009[11]" alt="clip_image009[11]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043229085.png" border="0" height="21" width="14"></a>用<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043225672.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image012[6]" alt="clip_image012[6]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043232607.png" border="0" height="21" width="15"></a>表示： </p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043233446.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image051" alt="clip_image051" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043233097.png" border="0" height="39" width="185"></a> </p>
<p>然后反代入W中，得 </p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043236968.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image052" alt="clip_image052" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043246935.png" border="0" height="32" width="424"></a> </p>
<p>展开后W可以表示成<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043245506.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image054" alt="clip_image054" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043248854.png" border="0" height="21" width="91"></a>。其中a,b,c是固定值。这样，通过对W进行求导可以得到<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043258264.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image012[7]" alt="clip_image012[7]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043251263.png" border="0" height="21" width="15"></a>，然而要保证<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043257850.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image012[8]" alt="clip_image012[8]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043265624.png" border="0" height="21" width="15"></a>满足<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043264196.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image056" alt="clip_image056" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043262767.png" border="0" height="21" width="69"></a>，我们使用<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043269702.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image058" alt="clip_image058" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043273050.png" border="0" height="21" width="88"></a>表示求导求出来的<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043275525.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image012[9]" alt="clip_image012[9]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043277652.png" border="0" height="21" width="15"></a>，然而最后的<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043274587.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image012[10]" alt="clip_image012[10]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043285949.png" border="0" height="21" width="15"></a>，要根据下面情况得到： </p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043289504.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image059" alt="clip_image059" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043299471.png" border="0" height="73" width="434"></a> </p>
<p>这样得到<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043296407.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image061" alt="clip_image061" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043294945.png" border="0" height="21" width="36"></a>后，我们可以得到<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043309896.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image009[12]" alt="clip_image009[12]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043304846.png" border="0" height="21" width="14"></a>的新值<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043319797.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image063" alt="clip_image063" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043311159.png" border="0" height="21" width="35"></a>。 </p>
<p>下面进入Platt的文章，来找到启发式搜索的方法和求b值的公式。 </p>
<p>这边文章使用的符号表示有点不太一样，不过实质是一样的，先来熟悉一下文章中符号的表示。 </p>
<p>文章中定义特征到结果的输出函数为 </p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043317222.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image064" alt="clip_image064" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043321649.png" border="0" height="39" width="398"></a> </p>
<p>与我们之前的<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043328585.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image066" alt="clip_image066" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043325520.png" border="0" height="21" width="62"></a>实质是一致的。 </p>
<p>原始的优化问题为： </p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043329075.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image067" alt="clip_image067" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043337406.png" border="0" height="41" width="495"></a> </p>
<p>求导得到： </p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043337373.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image068" alt="clip_image068" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043338976.png" border="0" height="53" width="534"></a> </p>
<p>经过对偶后为： </p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043347307.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image069" alt="clip_image069" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043347274.png" border="0" height="55" width="371"></a> </p>
<p>s.t. <a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043346925.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image070" alt="clip_image070" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043349400.png" border="0" height="29" width="109"></a> </p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043353827.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image071" alt="clip_image071" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043356303.png" border="0" height="58" width="107"></a> </p>
<p>这里与W函数是一样的，只是符号求反后，变成求最小值了。<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043357142.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image073" alt="clip_image073" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043363728.png" border="0" height="21" width="11"></a>和<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043365091.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image075" alt="clip_image075" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043361677.png" border="0" height="21" width="20"></a>是一样的，都表示第i个样本的输出结果（1或-1）。 </p>
<p>经过加入松弛变量<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043373040.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image077" alt="clip_image077" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043371578.png" border="0" height="21" width="11"></a>后，模型修改为： </p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043389909.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image078" alt="clip_image078" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043383464.png" border="0" height="54" width="555"></a> </p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043384303.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image079" alt="clip_image079" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/20110318204339366.png" border="0" height="38" width="398"></a> </p>
<p>由公式（7）代入（1）中可知， </p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043396430.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image080" alt="clip_image080" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/20110318204339857.png" border="0" height="56" width="444"></a> </p>
<p>这个过程和之前对偶过程一样。 </p>
<p>重新整理我们要求的问题为： </p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043405218.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image081" alt="clip_image081" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043419056.png" border="0" height="141" width="538"></a> </p>
<p>与之对应的KKT条件为： </p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043412611.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image082" alt="clip_image082" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043416166.png" border="0" height="85" width="439"></a> </p>
<p>这个KKT条件说明，在两条间隔线外面的点，对应前面的系数<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043427528.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image084" alt="clip_image084" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043424115.png" border="0" height="21" width="12"></a>为0，在两条间隔线里面的对应<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043435477.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image084[1]" alt="clip_image084[1]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043436001.png" border="0" height="21" width="12"></a>为C，在两条间隔线上的对应的系数<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043438999.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image084[2]" alt="clip_image084[2]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/20110318204344362.png" border="0" height="21" width="12"></a>在0和C之间。 </p>
<p>将我们之前得到L和H重新拿过来： </p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043443917.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image085" alt="clip_image085" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043442247.png" border="0" height="42" width="533"></a> </p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043454723.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image086" alt="clip_image086" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043457198.png" border="0" height="40" width="530"></a> </p>
<p>之前我们将问题进行到这里，然后说将<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043453785.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image009[13]" alt="clip_image009[13]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043465147.png" border="0" height="21" width="14"></a>用<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043463718.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image012[11]" alt="clip_image012[11]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043465081.png" border="0" height="21" width="15"></a>表示后代入W中，这里将代入<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043473935.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image088" alt="clip_image088" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/20110318204347522.png" border="0" height="21" width="11"></a>中，得 </p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043481012.jpg" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image090" alt="clip_image090" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043487391.jpg" border="0" height="39" width="554"></a> </p>
<p>其中 </p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043493770.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image091" alt="clip_image091" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043495373.png" border="0" height="97" width="526"></a> </p>
<p>这里的<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043494784.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image093" alt="clip_image093" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043509734.png" border="0" height="21" width="20"></a>和<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043502176.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image095" alt="clip_image095" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043513539.png" border="0" height="21" width="20"></a>代表某次迭代前的原始值，因此是常数，而<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043515981.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image009[14]" alt="clip_image009[14]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043522568.png" border="0" height="21" width="14"></a>和<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043527518.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image012[12]" alt="clip_image012[12]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043538881.png" border="0" height="21" width="15"></a>是变量，待求。公式（24）中的最后一项是常数。 </p>
<p>由于<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043535467.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image009[15]" alt="clip_image009[15]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043546830.png" border="0" height="21" width="14"></a>和<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043548192.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image012[13]" alt="clip_image012[13]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043541191.png" border="0" height="21" width="15"></a>满足以下公式 </p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043557254.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image097" alt="clip_image097" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043558093.png" border="0" height="62" width="343"></a> </p>
<p>因为<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/20110318204355253.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image099" alt="clip_image099" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043559140.png" border="0" height="21" width="60"></a>的值是固定值，在迭代前后不会变。 </p>
<p>那么用s表示<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/20110318204356502.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image101" alt="clip_image101" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043562662.png" border="0" height="21" width="27"></a>，上式两边乘以<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043564024.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image103" alt="clip_image103" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043572596.png" border="0" height="21" width="13"></a>时，变为： </p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043577023.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image104" alt="clip_image104" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043577862.png" border="0" height="44" width="432"></a> </p>
<p>其中 </p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043573925.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image106" alt="clip_image106" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043582497.png" border="0" height="62" width="142"></a> </p>
<p>代入（24）中，得 </p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/20110318204358828.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image107" alt="clip_image107" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043582431.png" border="0" height="72" width="550"></a> </p>
<p>这时候只有<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/20110318204359205.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image012[14]" alt="clip_image012[14]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/20110318204359728.png" border="0" height="21" width="15"></a>是变量了，求导 </p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043596235.jpg" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image109" alt="clip_image109" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182043599790.jpg" border="0" height="51" width="554"></a> </p>
<p>如果<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044003105.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image088[1]" alt="clip_image088[1]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044009691.png" border="0" height="21" width="11"></a>的二阶导数大于0（凹函数），那么一阶导数为0时，就是极小值了。 </p>
<p>假设其二阶导数为0（一般成立），那么上式化简为： </p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044019658.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image110" alt="clip_image110" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044016037.png" border="0" height="37" width="553"></a> </p>
<p>将w和v代入后，继续化简推导，得（推导了六七行推出来了） </p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044012416.jpg" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image112" alt="clip_image112" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044022383.jpg" border="0" height="42" width="554"></a> </p>
<p>我们使用<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044026462.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image114" alt="clip_image114" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044025349.png" border="0" height="21" width="8"></a>来表示： </p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044031412.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image115" alt="clip_image115" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044062477.png" border="0" height="36" width="489"></a> </p>
<p>通常情况下目标函数是正定的，也就是说，能够在直线约束方向上求得最小值，并且<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044065476.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image117" alt="clip_image117" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044078475.png" border="0" height="21" width="34"></a>。 </p>
<p>那么我们在（30）两边都除以<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044071822.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image114[1]" alt="clip_image114[1]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044077852.png" border="0" height="21" width="8"></a>可以得到 </p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/20110318204408327.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image118" alt="clip_image118" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044083326.png" border="0" height="49" width="443"></a> </p>
<p>这里我们使用<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/20110318204408261.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image061[1]" alt="clip_image061[1]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044093260.png" border="0" height="21" width="36"></a>表示优化后的值，<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/20110318204409195.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image012[15]" alt="clip_image012[15]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044091558.png" border="0" height="21" width="15"></a>是迭代前的值，<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044103717.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image120" alt="clip_image120" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044107065.png" border="0" height="21" width="72"></a>。 </p>
<p>与之前提到的一样<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044104000.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image061[2]" alt="clip_image061[2]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044106126.png" border="0" height="21" width="36"></a>不是最终迭代后的值，需要进行约束： </p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044116409.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image121" alt="clip_image121" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044119964.png" border="0" height="92" width="497"></a> </p>
<p>那么 </p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044116027.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image122" alt="clip_image122" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044126866.png" border="0" height="46" width="465"></a> </p>
<p>在特殊情况下，<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044121817.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image114[2]" alt="clip_image114[2]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/20110318204413355.png" border="0" height="21" width="8"></a>可能不为正，如果核函数K不满足Mercer定理，那么目标函数可能变得非正定，<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044133354.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image114[3]" alt="clip_image114[3]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044132765.png" border="0" height="21" width="8"></a>可能出现负值。即使K是有效的核函数，如果训练样本中出现相同的特征x，那么<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044145763.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image114[4]" alt="clip_image114[4]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044148762.png" border="0" height="21" width="8"></a>仍有可能为0。SMO算法在<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/20110318204415124.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image114[5]" alt="clip_image114[5]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044151487.png" border="0" height="21" width="8"></a>不为正值的情况下仍有效。为保证有效性，我们可以推导出<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/2011031820441558.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image114[6]" alt="clip_image114[6]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044166994.png" border="0" height="21" width="8"></a>就是<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044163580.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image088[2]" alt="clip_image088[2]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044178531.png" border="0" height="21" width="11"></a>的二阶导数，<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044173481.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image124" alt="clip_image124" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044176795.png" border="0" height="21" width="34"></a>，<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044183382.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image088[3]" alt="clip_image088[3]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044184745.png" border="0" height="21" width="11"></a>没有极小值，最小值在边缘处取到（类比<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044196107.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image126" alt="clip_image126" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044192694.png" border="0" height="21" width="50"></a>），<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044205692.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image128" alt="clip_image128" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044203467.png" border="0" height="21" width="34"></a>时更是单调函数了，最小值也在边缘处取得，而<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044217545.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image012[16]" alt="clip_image012[16]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044219987.png" border="0" height="21" width="15"></a>的边缘就是L和H。这样将<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044229398.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image130" alt="clip_image130" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044227969.png" border="0" height="21" width="41"></a>和<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044224905.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image132" alt="clip_image132" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044228252.png" border="0" height="21" width="43"></a>分别代入<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044234839.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image088[4]" alt="clip_image088[4]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044231774.png" border="0" height="21" width="11"></a>中即可求得<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/20110318204423346.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image088[5]" alt="clip_image088[5]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044231708.png" border="0" height="21" width="11"></a>的最小值，相应的<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044244707.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image130[1]" alt="clip_image130[1]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044249657.png" border="0" height="21" width="41"></a>还是<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044252656.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image132[1]" alt="clip_image132[1]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044257955.png" border="0" height="21" width="43"></a>也可以知道了。具体计算公式如下： </p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044261477.jpg" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image134" alt="clip_image134" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044278313.jpg" border="0" height="152" width="554"></a> </p>
<p>至此，迭代关系式出了b的推导式以外，都已经推出。 </p>
<p>b每一步都要更新，因为前面的KKT条件指出了<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044274900.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image084[3]" alt="clip_image084[3]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044289850.png" border="0" height="21" width="12"></a>和<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044283198.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image136" alt="clip_image136" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044283688.png" border="0" height="21" width="24"></a>的关系，而<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044294211.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image138" alt="clip_image138" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044297559.png" border="0" height="21" width="12"></a>和b有关，在每一步计算出<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044294145.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image084[4]" alt="clip_image084[4]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044305508.png" border="0" height="21" width="12"></a>后，根据KKT条件来调整b。 </p>
<p>b的更新有几种情况： </p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044317045.jpg" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image140" alt="clip_image140" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044327752.jpg" border="0" height="226" width="554"></a> </p>
<p>来自罗林开的ppt </p>
<p>这里的界内指<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044326323.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image142" alt="clip_image142" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044323259.png" border="0" height="21" width="65"></a>，界上就是等于0或者C了。 </p>
<p>前面两个的公式推导可以根据<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044337686.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image144" alt="clip_image144" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044333749.png" border="0" height="62" width="257"></a> </p>
<p>和对于<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044337096.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image142[1]" alt="clip_image142[1]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044335668.png" border="0" height="21" width="65"></a>有<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044332603.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image146" alt="clip_image146" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044341142.png" border="0" height="21" width="50"></a>的KKT条件推出。 </p>
<p>这样全部参数的更新公式都已经介绍完毕，附加一点，如果使用的是线性核函数，我们就可以继续使用w了，这样不用扫描整个样本库来作内积了。 </p>
<p>w值的更新方法为： </p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044341109.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image147" alt="clip_image147" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044351076.png" border="0" height="37" width="535"></a> </p>
<p>根据前面的 </p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044359406.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image068[1]" alt="clip_image068[1]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044356550.png" border="0" height="53" width="534"></a> </p>
<p>公式推导出。 </p>

<p><strong><span style="font-size: medium;" size="4">12 SMO中拉格朗日乘子的启发式选择方法</span></strong> </p>
<p>终于到了最后一个问题了，所谓的启发式选择方法主要思想是每次选择拉格朗日乘子的时候，优先选择样本前面系数<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044353485.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image142[2]" alt="clip_image142[2]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044366832.png" border="0" height="21" width="65"></a>的<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/20110318204436911.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image084[5]" alt="clip_image084[5]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044372273.png" border="0" height="21" width="12"></a>作优化（论文中称为无界样例），因为在界上（<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044378860.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image084[6]" alt="clip_image084[6]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044385762.png" border="0" height="21" width="12"></a>为0或C）的样例对应的系数<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044382697.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image084[7]" alt="clip_image084[7]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044384060.png" border="0" height="21" width="12"></a>一般不会更改。 </p>
<p>这条启发式搜索方法是选择第一个拉格朗日乘子用的，比如前面的<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/20110318204439646.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image012[17]" alt="clip_image012[17]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044392009.png" border="0" height="21" width="15"></a>。那么这样选择的话，是否最后会收敛。可幸的是Osuna定理告诉我们只要选择出来的两个<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044408595.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image084[8]" alt="clip_image084[8]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044409958.png" border="0" height="21" width="12"></a>中有一个违背了KKT条件，那么目标函数在一步迭代后值会减小。违背KKT条件不代表<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044408529.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image142[3]" alt="clip_image142[3]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044405465.png" border="0" height="21" width="65"></a>，在界上也有可能会违背。是的，因此在给定初始值<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044418812.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image084[9]" alt="clip_image084[9]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044415399.png" border="0" height="21" width="12"></a>=0后，先对所有样例进行循环，循环中碰到违背KKT条件的（不管界上还是界内）都进行迭代更新。等这轮过后，如果没有收敛，第二轮就只针对<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044418746.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image142[4]" alt="clip_image142[4]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044417318.png" border="0" height="21" width="65"></a>的样例进行迭代更新。 </p>
<p>在第一个乘子选择后，第二个乘子也使用启发式方法选择，第二个乘子的迭代步长大致正比于<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044414253.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image149" alt="clip_image149" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044422824.png" border="0" height="21" width="54"></a>，选择第二个乘子能够最大化<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044425823.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image149[1]" alt="clip_image149[1]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044429170.png" border="0" height="21" width="54"></a>。即当<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044439661.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image151" alt="clip_image151" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044431023.png" border="0" height="21" width="14"></a>为正时选择负的绝对值最大的<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044439595.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image153" alt="clip_image153" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/20110318204444118.png" border="0" height="21" width="14"></a>，反之，选择正值最大的<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044443465.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image153[1]" alt="clip_image153[1]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/2011031820444452.png" border="0" height="21" width="14"></a>。 </p>
<p>最后的收敛条件是在界内（<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044446987.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image142[5]" alt="clip_image142[5]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044455559.png" border="0" height="21" width="65"></a>）的样例都能够遵循KKT条件，且其对应的<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044456049.png" target="_blank" rel="noopener"><img style="background-image: none; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; padding-top: 0px; border: 0px;" title="clip_image084[10]" alt="clip_image084[10]" src="http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103182044467412.png" border="0" height="21" width="12"></a>只在极小的范围内变动。 </p>
<p>至于如何写具体的程序，请参考John C. Platt在论文中给出的伪代码。 </p>
<p><strong><span style="font-size: medium;" size="4">13 总结</span></strong> </p>
<p>这份SVM的讲义重点概括了SVM的基本概念和基本推导，中规中矩却又让人醍醐灌顶。起初让我最头疼的是拉格朗日对偶和SMO，后来逐渐明白拉格朗日对偶的重要作用是将w的计算提前并消除w，使得优化函数变为拉格朗日乘子的单一参数优化问题。而SMO里面迭代公式的推导也着实让我花费了不少时间。 </p>
<p>对比这么复杂的推导过程，SVM的思想确实那么简单。它不再像logistic回归一样企图去拟合样本点（中间加了一层sigmoid函数变换），而是就在样本中去找分隔线，为了评判哪条分界线更好，引入了几何间隔最大化的目标。 </p>
<p>之后所有的推导都是去解决目标函数的最优化上了。在解决最优化的过程中，发现了w可以由特征向量内积来表示，进而发现了核函数，仅需要调整核函数就可以将特征进行低维到高维的变换，在低维上进行计算，实质结果表现在高维上。由于并不是所有的样本都可分，为了保证SVM的通用性，进行了软间隔的处理，导致的结果就是将优化问题变得更加复杂，然而惊奇的是松弛变量没有出现在最后的目标函数中。最后的优化求解问题，也被拉格朗日对偶和SMO算法化解，使SVM趋向于完美。 </p>
<p>另外，其他很多议题如SVM背后的学习理论、参数选择问题、二值分类到多值分类等等还没有涉及到，以后有时间再学吧。其实朴素贝叶斯在分类二值分类问题时，如果使用对数比，那么也算作线性分类器。</p></div>


]]></content>
      <categories>
        <category>ML/DL</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>SVM</tag>
        <tag>支持向量机</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习实战-7AdaBoost提升算法</title>
    <url>/2017/11/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-7AdaBoost%E6%8F%90%E5%8D%87%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>这一章的主要思想就是“三个臭皮匠赛一个诸葛亮”。一般而言，我们都是通过一个分类器进行分类，但是一个分类器可能会出现偶然误差错误，就像一个人总会出现失误一样。所以，我们学习多个不同的分类器，然后将这些分类器通过加上不同的权重组合起来，就形成了一种强大的集成分类器。而这其中，可以再次改进，对不同的分类器，分类效果不同的，权重也可能不同，这样，分类效果好的分类器能够得到更大的“投票权”</p>
</blockquote>
<p>前言</p>
<ul>
<li>元算法/集成学习：即考虑多个专家的意见而不是一个人独断专权</li>
<li>AdaBoost：<ul>
<li>优点：泛化错误率低，易编码，无参数调整，可使用在大多数分类器上</li>
<li>缺点：对离群点敏感，即对极端值拟合不好（如极大极小值）</li>
</ul>
</li>
</ul>
<hr>
<p>7.1 数据如何划分–多重抽样分类器（集成学习的分类）</p>
<ul>
<li>7.1.1 bagging：Bootstrap aggregating，引导聚集算法/装袋算法<ul>
<li>原理：从原始数据总随机有放回的抽取n次组成一个数据集，训练为一个分类器。这样重复进行m次,就得出m个分类器。分类器的权重相等。记住这些分类器数据集是并行进行的，与boosting有区别。</li>
<li>改进算法：随机森林（random forest）</li>
</ul>
</li>
<li>7.1.2 boosting（Boost–增强）<ul>
<li>原理：与bagging类似，不同的是，每个分类器的数据集不是并行的，而是串行的。即每个新的分类器都是根据已经训练出来的分类器的性能来进行训练的，之后的分类器需要使用到之前已经训练好的分类器的数据集。boosting集中关注那些被错误分类的数据集。</li>
<li>bagging分类器的权重是相等的，boosting的权重是不相等的，每个权重代表的是分类器在上一次迭代时的成功度。</li>
<li>boosting的版本有很多，AdaBoost是其中一种（AdaBoost–Adaptive Boosting–自适应增强）</li>
</ul>
</li>
</ul>
<hr>
<p>7.2 原理和算法</p>
<ul>
<li>这里含有许多的公式证明，即为什么使用这些公式，而不使用其它的公式，其中的道理，很难说的清除，暂且保留（可参考《统计学习方法》P139，《西瓜书》P175）</li>
<li>第一个分类器的权重alpha:<ul>
<li>定义错误率w = (被错误分类的样本)/(样本总数)</li>
<li>alpha = （1/2）*ln((1-w)/w);即错误率越低，权重越大。实际代码操作，变化巨大</li>
</ul>
</li>
<li>一个分类器中每个样本的权重更新：<ul>
<li>D = D * exp(+-1 * alpha) / sum(D);被正确分类则为-1，否则为+1。注意：这里在代码中有技巧，因为标签为+-1，可以抵消</li>
</ul>
</li>
</ul>
<hr>
<p>7.3 单层决策树–决策树桩（decision stump）</p>
<ul>
<li>代码boost.py</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="string">""</span><span class="string">" </span></span><br><span class="line"><span class="string">@author: zoutai</span></span><br><span class="line"><span class="string">@file: boost.py</span></span><br><span class="line"><span class="string">@date: 2017/11/04</span></span><br><span class="line"><span class="string">@description: 单层决策树-找出最好的一个特征，且最好的中间阈值;</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br><span class="line">from numpy import *</span><br><span class="line">from unit07<span class="selector-class">.adaboost</span> import *</span><br><span class="line"></span><br><span class="line"># 这个函数的作用是：对第dimen个特征进行分类，样本点dimen特征小于阈值的被标记为-1，否则标记为+1,。</span><br><span class="line"># 输出为M*1的二维数组，相当于把每个样本当做只有一个特征来划分。这里的1、-1对应标签的1、-1，后面会比较。</span><br><span class="line"># 注意：这里需要对python特别熟悉，shape(dataMat)[0] == m；</span><br><span class="line"># dataMat[:,dimen] &lt;= threshVal返回的是第一列下标，逻辑复杂但是表达却相当简化，这也许就是python的魅力吧</span><br><span class="line">def stumpClassify(dataMat,dimen,threshVal,threshInequal):</span><br><span class="line">    sampleArray = ones((shape(dataMat)[<span class="number">0</span>],<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">if</span> threshInequal == <span class="string">'lt'</span>:</span><br><span class="line">        sampleArray[dataMat[:,dimen] &lt;= threshVal] = -<span class="number">1.0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        sampleArray[dataMat[:,dimen] &gt; threshVal] = <span class="number">1.0</span></span><br><span class="line">    return sampleArray</span><br><span class="line"></span><br><span class="line">def buildStump(dataArr, classLabels,D):</span><br><span class="line">    dataMat = mat(dataArr);labelMat = mat(classLabels).T</span><br><span class="line">    m,n = shape(dataMat)</span><br><span class="line">    numSteps = 10;</span><br><span class="line">    bestStump = &#123;&#125;; # 用于保存重要的结果值，如阈值，样本中节点下标等。</span><br><span class="line">    bestClass = mat(zeros((m,1))) # 分类结果mat，与sampleArray对应</span><br><span class="line">    minError = inf</span><br><span class="line">    # 遍历特征变量</span><br><span class="line">    <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(n):</span><br><span class="line">        # 找出第i个特征值的最小值和最大值</span><br><span class="line">        rangeMin = dataMat[:,i].min();rangeMax = dataMat[:,i].max()</span><br><span class="line">        stepSize = (rangeMax-rangeMin)/numSteps # 每一步特征值间隔</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(-<span class="number">1</span>,int(numSteps)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> inequal <span class="keyword">in</span> [<span class="string">'lt'</span>,<span class="string">'gt'</span>]:</span><br><span class="line">                threshVal = (rangeMin+<span class="attribute">float</span>(j)*stepSize)</span><br><span class="line">                dimenPredictedVals = stumpClassify(dataMat,<span class="selector-tag">i</span>,threshVal,inequal)</span><br><span class="line">                errArr = mat(ones((m,<span class="number">1</span>)))</span><br><span class="line">                errArr[dimenPredictedVals == labelMat] = 0 # 正确分类的设为0，错误的默认为1</span><br><span class="line">                # 重点来了，这里才是提升树的核心：通过D来调整特征值对应权值w的比重。D第一次需要初始化</span><br><span class="line">                weightError = D.T*errArr</span><br><span class="line">                print("split: dim %d,thresh %.2f,hresh inequal: %s,the weighted error is %.3f" % (i,threshVal,inequal,weightError))</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> weightError &lt; minError:</span><br><span class="line">                    minError = weightError</span><br><span class="line">                    bestClass = dimenPredictedVals.copy() # 会被修改，所以需要copy</span><br><span class="line">                    bestStump[<span class="string">'dim'</span>] = i</span><br><span class="line">                    bestStump[<span class="string">'thresh'</span>] = threshVal</span><br><span class="line">                    bestStump[<span class="string">'ineq'</span>] = inequal</span><br><span class="line">    return bestStump,minError,bestClass</span><br></pre></td></tr></table></figure>
<ul>
<li>代码adaboost.py</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">from numpy import *</span><br><span class="line">from unit07<span class="selector-class">.boost</span> import *</span><br><span class="line"></span><br><span class="line"><span class="string">""</span><span class="string">" </span></span><br><span class="line"><span class="string">@author: zoutai</span></span><br><span class="line"><span class="string">@file: adaboost.py </span></span><br><span class="line"><span class="string">@date: 2017/11/04</span></span><br><span class="line"><span class="string">@description:</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br><span class="line"></span><br><span class="line">def loadSimpData():</span><br><span class="line">    datMat = matrix([[ <span class="number">1</span>. ,  <span class="number">2.1</span>],</span><br><span class="line">        [ <span class="number">2</span>. ,  <span class="number">1.1</span>],</span><br><span class="line">        [ <span class="number">1.3</span>,  <span class="number">1</span>. ],</span><br><span class="line">        [ <span class="number">1</span>. ,  <span class="number">1</span>. ],</span><br><span class="line">        [ <span class="number">2</span>. ,  <span class="number">1</span>. ]])</span><br><span class="line">    classLabels = [<span class="number">1.0</span>, <span class="number">1.0</span>, -<span class="number">1.0</span>, -<span class="number">1.0</span>, <span class="number">1.0</span>]</span><br><span class="line">    return datMat,classLabels</span><br><span class="line"></span><br><span class="line">def adaboostTrainDS(dataArr,classLabels,numIt):</span><br><span class="line">    weakClassArr = [] # 弱分类器</span><br><span class="line">    m = shape(dataArr)[<span class="number">0</span>]</span><br><span class="line">    D = mat(ones((m,<span class="number">1</span>))/m)</span><br><span class="line">    sumBestClass = mat(zeros((m,<span class="number">1</span>)))</span><br><span class="line">    <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(numIt):</span><br><span class="line">        bestStump,error,bestClass = buildStump(dataArr,classLabels,D)</span><br><span class="line">        print(D.T)</span><br><span class="line">        # 核心：alpha是单个分类器的权重</span><br><span class="line">        alpha = <span class="attribute">float</span>(<span class="number">0.5</span>*log((<span class="number">1.0</span>-error)/max(error,<span class="number">1</span>e-<span class="number">16</span>))) # 这里max是防止分母为<span class="number">0</span></span><br><span class="line">        bestStump[<span class="string">'alpha'</span>] = alpha</span><br><span class="line">        weakClassArr.append(bestStump)</span><br><span class="line">        print(bestClass.T)</span><br><span class="line">        # 更新每个决策树的权重</span><br><span class="line">        # 以下使用了P117和P118的公式</span><br><span class="line">        expon = multiply(-1.0*alpha*mat(classLabels).T,bestClass) # classLabels*bestClass 相同则为正</span><br><span class="line">        D = multiply(D,exp(expon))</span><br><span class="line">        print(<span class="string">"---"</span>,sum(D))</span><br><span class="line">        D = D/D.sum()</span><br><span class="line"></span><br><span class="line">        # 以下是为了累计计算错误率，当错误率为0时，终止循环。</span><br><span class="line">        # 但是我有个疑问，问什么要乘以alpha？。如果不乘以alpha，后面也不用sign函数，不可以吗？</span><br><span class="line">        sumBestClass += alpha*bestClass</span><br><span class="line">        print(sumBestClass.T)</span><br><span class="line">        sumError = multiply(sign(sumBestClass) != mat(classLabels)<span class="selector-class">.T</span>,ones((m,<span class="number">1</span>)))</span><br><span class="line">        errorRate = sum(sumError) / m</span><br><span class="line">        print(<span class="string">"total errorRate is : "</span>,errorRate)</span><br><span class="line">        <span class="keyword">if</span> errorRate == <span class="number">0.0</span>:</span><br><span class="line">            break</span><br><span class="line">    return weakClassArr,sumBestClass</span><br><span class="line"></span><br><span class="line"># 对给定数据，在每一个分类器上都进行分类，然后加权求解</span><br><span class="line">def adaClassify(testData,classArr):</span><br><span class="line">    testMat = mat(testData)</span><br><span class="line">    m = shape(testData)[<span class="number">0</span>]</span><br><span class="line">    sumClassArr = mat(zeros((m,<span class="number">1</span>)))</span><br><span class="line">    <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(len(classArr)):</span><br><span class="line">        oneClassArr = stumpClassify(testMat,classArr[i][<span class="string">'dim'</span>],classArr[i][<span class="string">'thresh'</span>],classArr[i][<span class="string">'ineq'</span>])</span><br><span class="line">        sumClassArr += classArr[i][<span class="string">'alpha'</span>]*oneClassArr</span><br><span class="line">        print(sumClassArr) # 加权计算每一个分类，</span><br><span class="line">    return sign(sumClassArr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 将文本数据转化为矩阵训练数据</span><br><span class="line">def loadDataSet(filename):</span><br><span class="line">    dataMat = []; labelMat = []</span><br><span class="line">    file = open(filename)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> file.readlines():</span><br><span class="line">        lineArr = []</span><br><span class="line">        line = line.strip().split()</span><br><span class="line">        <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(len(line)-<span class="number">1</span>):</span><br><span class="line">            lineArr.append(<span class="attribute">float</span>(line[i]))</span><br><span class="line">        dataMat.append(lineArr)</span><br><span class="line">        labelMat.append(<span class="attribute">float</span>(line[-<span class="number">1</span>]))</span><br><span class="line">    return dataMat,labelMat</span><br><span class="line"></span><br><span class="line"># ROC曲线绘制及AUC计算函数</span><br><span class="line">def plotROC(sumClass,classLabels):</span><br><span class="line">    import matplotlib<span class="selector-class">.pyplot</span> as plt</span><br><span class="line">    cur = (<span class="number">1.0</span>,<span class="number">1.0</span>)</span><br><span class="line">    ySum = <span class="number">0.0</span></span><br><span class="line">    numPosClas = sum(array(classLabels) == 1.0) # 计算真阳例的分母--真实结果为正的数目</span><br><span class="line">    numNoPosClas = len(classLabels) - numPosClas # 计算假阳例的分母--...</span><br><span class="line">    yStep = <span class="number">1</span>/<span class="attribute">float</span>(numPosClas) # y轴上个步进长度，下同理</span><br><span class="line">    xStep = <span class="number">1</span>/<span class="attribute">float</span>(numNoPosClas)</span><br><span class="line">    sortedIndicies = argsort(sumClass) # 重点：argsort函数返回的是数组值从小到大的索引值 参考：http://blog.csdn.net/maoersong/article/details/21875705</span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    fig.clf()</span><br><span class="line">    ax = plt.subplot(<span class="number">111</span>)</span><br><span class="line">    # 这里理解是一个难点！</span><br><span class="line">    # 1、书上说了，由于排序是由大到小，也就是，开始值小的部分，训练师被分为-1，之后数大的部分被分为+1；所以只能从右上开始画。、</span><br><span class="line">    # 这样，显然开始画图部分是从不预测值不是+1开始的</span><br><span class="line">    # 但是看图时，是从左下开始，预测值更可能是1.0</span><br><span class="line">    # 表达能力有限啊!我自己都说不清楚。。</span><br><span class="line">    # 这个ROC开起来可能好像没用到训练情况，其实，这里的关键在于排序。这样，排序的前面所有都是-1，后面所有都是+1；。</span><br><span class="line">    # 但是为什么没有使用预测结果，因为最终都将是归为x=1,y=1.目的是让+1尽可能靠近前面，面积AUC更大，这就是ROC的意义！</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> sortedIndicies.tolist()[<span class="number">0</span>]:</span><br><span class="line">        if classLabels[index] == 1.0: # 这里的1.0是指预测为正，将实际值classLabels与此比较，如果相同，y值下降</span><br><span class="line">            delX = 0;delY = yStep;</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            delX = xStep;delY = 0;</span><br><span class="line">            ySum += cur[<span class="number">1</span>]</span><br><span class="line">        ax.plot([cur[<span class="number">0</span>],cur[<span class="number">0</span>]-delX],[cur[<span class="number">1</span>],cur[<span class="number">1</span>]-delY],c=<span class="string">'b'</span>)</span><br><span class="line">        cur = (cur[<span class="number">0</span>]-delX,cur[<span class="number">1</span>]-delY)</span><br><span class="line">    ax.plot([<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>],<span class="string">'b--'</span>)</span><br><span class="line">    plt.xlabel('False positive Rate');</span><br><span class="line">    plt.ylabel('True positive Rate');</span><br><span class="line">    ax.axis([<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line">    plt.show()</span><br><span class="line">    print(<span class="string">"the Area Under the Curve is :"</span>,ySum*xStep)</span><br></pre></td></tr></table></figure>

<ul>
<li>测试代码test.py</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="string">""</span><span class="string">" </span></span><br><span class="line"><span class="string">@author: zoutai</span></span><br><span class="line"><span class="string">@file: test.py </span></span><br><span class="line"><span class="string">@time: 2017/11/04 </span></span><br><span class="line"><span class="string">@description: </span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br><span class="line"></span><br><span class="line"># 这里记录一个python错误：当两个类出现互相调用时，可能会出现无法调用的情况，如adaboost和boost两个方法互相调用</span><br><span class="line"># 所以，测试运行代码尽量另外单独写，比如test</span><br><span class="line">from unit07<span class="selector-class">.adaboost</span> import *</span><br><span class="line"></span><br><span class="line"># # 测试1:基于加权的分类器</span><br><span class="line"># dataMat,lebalMat = loadSimpData()</span><br><span class="line"># # D是这里的核心：D是每一个样本的权重，通过D.T*errArr来得出错误率，除以m是为了归一化</span><br><span class="line"># # 在单层决策树中并没有迭代，但是才后面的提升过程中，主要就是D的不断迭代修改，来进行训练优化</span><br><span class="line"># D = mat(ones((5,1))/5)</span><br><span class="line"># bestStump,minError,bestClass = buildStump(dataMat,lebalMat,D)</span><br><span class="line"># print(bestStump)</span><br><span class="line"># print(minError)</span><br><span class="line"># print(bestClass)</span><br><span class="line"></span><br><span class="line"># # 测试2:基于adaboost的弱分类器，多个阈值，单层</span><br><span class="line"># dataMat,lebalMat = loadSimpData()</span><br><span class="line"># weakClassArray = adaboostTrainDS(dataMat,lebalMat,9)</span><br><span class="line"># print(weakClassArray)</span><br><span class="line"></span><br><span class="line"># # 测试3：测试一个数据集，看效果</span><br><span class="line"># dataMat,lebalMat = loadSimpData()</span><br><span class="line"># # 这里的30是迭代次数，也是分类器个数。其实3次时，errorRate==0,就够了，此时分类器就是3个</span><br><span class="line"># weakClassArray = adaboostTrainDS(dataMat,lebalMat,30)</span><br><span class="line"># predictResult = adaClassify([[0,0]],weakClassArray) # [[0,0]]这个地方书上写错了</span><br><span class="line"># print("the result is:",predictResult)</span><br><span class="line"></span><br><span class="line"># # 测试4-马疝病-预测得病的马是否能存活</span><br><span class="line"># dataMat,lebalMat = loadDataSet('horseColicTraining2.txt')</span><br><span class="line"># classArr = adaboostTrainDS(dataMat,lebalMat,10)</span><br><span class="line"># print(classArr)</span><br><span class="line"># testMat,testLabelMat = loadDataSet('horseColicTest2.txt')</span><br><span class="line"># predictArr10 = adaClassify(testMat,classArr)</span><br><span class="line"># num = len(testMat)</span><br><span class="line"># errorArr = mat(ones((num,1)))</span><br><span class="line"># errorRate = sum(errorArr[predictArr10 != mat(testLabelMat).T])/num</span><br><span class="line"># print(errorRate)</span><br><span class="line"># # 说明一点，这里的数据与第四章不同；另外我的测试结果和书上也不同</span><br><span class="line"># # 测试结果：</span><br><span class="line"># # 1   --   0.367892976589   --   0.283582089552</span><br><span class="line"># # 10  --   0.354515050167   --   0.328358208955</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 画ROC曲线</span><br><span class="line"># 疑问：这个地方实在是没弄懂，这个曲线有什么用？只是用了训练的排序，没有用训练的预测值。</span><br><span class="line">dataMat,lebalMat = loadDataSet(<span class="string">'horseColicTraining2.txt'</span>)</span><br><span class="line">classArr,sumClass = adaboostTrainDS(dataMat,lebalMat,<span class="number">10</span>)</span><br><span class="line"><span class="function"><span class="title">plotROC</span><span class="params">(sumClass.T,lebalMat)</span></span></span><br></pre></td></tr></table></figure>

<p>后续：</p>
<ol>
<li>非均衡分类器<blockquote>
<p>–| 即训练出来的分类器并不是一定准确的，即便错误率很低，但是在某些情况下在这种错误是不能出现的。比如，垃圾邮件的分类，本来是好的邮件被当做垃圾邮件会造成邮件的丢失。<br>–| 一般而言，这种分类器是由于正例样本和反例样本数目相差很大造成的。</p>
</blockquote>
</li>
</ol>
<ul>
<li>分类的其他度量指标：正确率、召回率、ROC曲线<ul>
<li>1正确率：前面使用的就是正确率来度量，但是我们可以改进前面的度量方式。如采用混淆矩阵（书中后面讲到的代价函数)</li>
<li>2召回率：预测为正的数据占所有实际为正例的比例。在召回率很大时，真正判错的正例不多</li>
<li>3ROC曲线，当面积AUC越大，说明分类器越好，作为模型选择的一种方式<br><img src="./images/1509893412709.jpg" alt="混淆矩阵"></li>
</ul>
</li>
</ul>
<ol start="2">
<li>处理分均衡问题的数据抽样方法<blockquote>
<p>即对某一个类别的样本少的进行重复抽样–过抽样；对样本多的进行少抽样或删除–欠抽样</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>总结：集成分类器可能进一步突出单个分类器的不足，如过拟合问题；但是如果分类器之间的差别较大时，这个问题就会缓和一些。这种不同可以使算法不同，也可以是数据不同。</p>
</blockquote>
]]></content>
      <categories>
        <category>ML/DL</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>boost</tag>
        <tag>提升树</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习实战-4朴素贝叶斯-python3</title>
    <url>/2017/11/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-4%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF-python3/</url>
    <content><![CDATA[<p>==这一章原理很简单，相关的知识到处都是，《数学之美》讲过，《统计学习方法》西瓜书都有详细的概述。但是就是一个简单的概率问题，如果真正遇到实际问题，却也并不是很好解决的。这其中往往是实际操作时往往和理论空想不同，数据的合理安排非常重要。贝叶斯的使用非常广泛，其实就目前而言，现实生活中很多的人工智能方面的处理其实就是用的贝叶斯，特别是对于商业数据的处理分析。比如搜索公司中的网页关联分析，社交软件中根据行为表现进行群体划分，以及新闻中的精准推送等。==</p>
<hr>
<p>一、贝叶斯公式</p>
<ol>
<li>这个定理解决了现实生活里经常遇到的问题：已知某条件概率，如何得到两个事件交换后的概率，也就是在已知P(A|B)的情况下如何求得P(B|A)。</li>
<li>一般而言就是这个概率公式：P(B|A) = P(AB)/P(A) = P(A|B)P(B)/P(A)</li>
</ol>
<p>二、贝叶斯原理和流程</p>
<ul>
<li>由于这方面的讲述比较多，而且，在我看来，只要知道了上面的公式含义，基本上就知道了使用的方法。这里主要说明一点，原理虽然简单，但是直接操作可能会出现无从下手。所以最好的方式是直接看实例代码，这样更容易懂。之后再做其他的，流程其实是类似的。</li>
</ul>
<p>三、样例1：文本情感分类</p>
<ol>
<li>目标：其实就是根据文章的评论，来区分评论的倾向，是积极0，还是否消极1；</li>
<li>步骤：对于训练集，分别提取出积极消极对应的词汇；对于测试集，计算测试集词汇在训练集在积极和消极中的“比重”，来确定将其分为哪一类。</li>
<li>代码：bayes.py</li>
</ol>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 案例3：使用beyes从个人广告中获取区域倾向</span><br><span class="line"># 书上说的有点婉转，使得不能很好的和本章联系；其实这里就是给你两个城市的人们说话的用词，</span><br><span class="line"># 然后通过这些用词来区分某个人属于哪个城市，另外这间接的可以得出城市的词云库信息；</span><br><span class="line"># 另外这种方式也是广告商们如何分析用户的行为信息来确定用户的年龄和职业来进行精确推送；还有一些婚恋网站匹配等</span><br><span class="line">from unit04<span class="selector-class">.filterEmail</span> import *</span><br><span class="line">import feedparser</span><br><span class="line"></span><br><span class="line"># 这里使用了词袋模型</span><br><span class="line">def calcMostFreq(vocabList,fullText):</span><br><span class="line">    import operator</span><br><span class="line">    freqDict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> vocabList:</span><br><span class="line">        freqDict[word] = fullText.cout(word)</span><br><span class="line">    sortedFreq = sorted(freqDict.items(),key=operator<span class="selector-class">.itemgetter</span>,reverse=True)</span><br><span class="line">    return sortedFreq[:<span class="number">30</span>]</span><br><span class="line"></span><br><span class="line">def localWords(feed1,feed0):</span><br><span class="line">    docList = [];classList = [];fullText = []</span><br><span class="line">    minLen = min(len(feed1[<span class="string">'entries'</span>]),len(feed0[<span class="string">'entries'</span>]))</span><br><span class="line">    <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(minLen):</span><br><span class="line">        wordList = textParse(feed1[<span class="string">'entries'</span>][i][<span class="string">'summary'</span>])</span><br><span class="line">        docList.append(wordList)</span><br><span class="line">        fullText.extend(wordList)</span><br><span class="line">        classList.append(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        wordList = textParse(feed0[<span class="string">'entries'</span>][i][<span class="string">'summary'</span>])</span><br><span class="line">        docList.append(wordList)</span><br><span class="line">        fullText.extend(wordList)</span><br><span class="line">        classList.append(<span class="number">0</span>)</span><br><span class="line">    vocabList = createVocabSet(docList)</span><br><span class="line">    top30Words = calcMostFreq(vocabList,fullText)</span><br><span class="line">    # 去掉出现频率最高的那些词</span><br><span class="line">    <span class="keyword">for</span> pairW <span class="keyword">in</span> top30Words:</span><br><span class="line">        <span class="keyword">if</span> pairW[<span class="number">0</span>] <span class="keyword">in</span> vocabList:</span><br><span class="line">            vocabList.remove(pairW[<span class="number">0</span>])</span><br><span class="line">    trainSet = list(range(2 * minLen));</span><br><span class="line">    testSet = []</span><br><span class="line">    <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">        import numpy</span><br><span class="line">        randIndex = int(numpy<span class="selector-class">.random</span>.uniform(<span class="number">0</span>,len(trainSet)))</span><br><span class="line">        testSet.append(trainSet[randIndex])</span><br><span class="line">        del(trainSet[randIndex])</span><br><span class="line">    trainMat = [];trainClassList = []</span><br><span class="line">    <span class="keyword">for</span> docIndex <span class="keyword">in</span> trainSet:</span><br><span class="line">        trainMat.append(bagOfWordsVec(vocabList,docList[docIndex]))</span><br><span class="line">        trainClassList.append(classList[docIndex])</span><br><span class="line">    pSpam,p0V,p1V = trainNB0(array(trainMat),trainClassList)</span><br><span class="line"></span><br><span class="line">    errorCount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> docIndex <span class="keyword">in</span> testSet:</span><br><span class="line">        testVec = bagOfWordsVec(vocabList,docList[docIndex])</span><br><span class="line">        <span class="keyword">if</span> classifyNB(testVec,p0V,p1V,pSpam) != classList[docIndex]:</span><br><span class="line">            errorCount += <span class="number">1</span></span><br><span class="line">    print(<span class="string">'the  rate is :'</span>,<span class="attribute">float</span>(errorCount)/len(testSet))</span><br><span class="line">    return pSpam,p0V,p1V</span><br><span class="line"></span><br><span class="line"># 测试</span><br><span class="line"># 说明：可能是由于网络访问的原因，这个无法完成</span><br><span class="line"># ny = feedparser.parse('http://newyork.craiglist.org/stp/insex.rss')</span><br><span class="line"># sf = feedparser.parse('http://sfbay.craiglist.org/stp/insex.rss')</span><br><span class="line">ny = feedparser.parse(<span class="string">'http://newyork.craiglist.org/stp/index.rss'</span>)</span><br><span class="line">sf = feedparser.parse(<span class="string">'http://sfbay.craiglist.org/stp/index.rss'</span>)</span><br><span class="line">vocabList,pSF,pNY = localWords(ny,sf)</span><br><span class="line"></span><br><span class="line"># 得到两个城市的词频</span><br><span class="line"><span class="function"><span class="title">getTopWords</span><span class="params">(ny,sf)</span></span></span><br></pre></td></tr></table></figure>
<p>测试代码：test.py</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">from unit04<span class="selector-class">.bayes</span> import *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">postingList,classVec = loadDataSet()</span><br><span class="line">vocabSet = createVocabSet(postingList)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(vocabSet)</span></span></span><br><span class="line">vocSetOfList = setOfWordsVec(postingList[<span class="number">0</span>],vocabSet)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(vocSetOfList)</span></span></span><br><span class="line"></span><br><span class="line">trainMat = []</span><br><span class="line"><span class="keyword">for</span> rowlist <span class="keyword">in</span> postingList:</span><br><span class="line">    rowlistset = setOfWordsVec(rowlist,vocabSet)</span><br><span class="line">    trainMat.append(rowlistset)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(trainMat)</span></span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(classVec)</span></span></span><br><span class="line"></span><br><span class="line">pA,p0,p1 = trainNB0(trainMat, classVec)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(p0)</span></span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(p1)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">"test P64----classify"</span>)</span></span></span><br><span class="line">testingNB() # 我的测试结果是the error rate is : 0.6，一直在这左右徘徊。不知道为什么书上的误差会这么底，我的可能错了？</span><br></pre></td></tr></table></figure>

<p>四、样例2：垃圾邮件过滤/邮件分类<br>filterEmail.py</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"># 案例2：过滤垃圾邮件</span><br><span class="line">from unit04<span class="selector-class">.bayes</span> import *</span><br><span class="line">def textParse(bigString):</span><br><span class="line">    import re</span><br><span class="line">    sentence = re.split(<span class="string">'\W+'</span>,bigString)</span><br><span class="line">    return [word.lower for word in sentence if len(word) &gt; 2] # 去掉长度小于2的单词</span><br><span class="line"></span><br><span class="line">def spamTest(): # spam垃圾邮件</span><br><span class="line">    # import os</span><br><span class="line">    # os.chdir(r'E:/JavaEE_IJ_WorkSpace/MLInAction')</span><br><span class="line">    docList = [];fullText = [];classList = []</span><br><span class="line">    <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">26</span>):</span><br><span class="line">        wordList = textParse(open('email/spam/%d.txt' % i).read())</span><br><span class="line">        docList.append(wordList)</span><br><span class="line">        fullText.extend(wordList)</span><br><span class="line">        classList.append(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        wordList = textParse(open('email/ham/%d.txt' % i).read())</span><br><span class="line">        docList.append(wordList)</span><br><span class="line">        fullText.extend(wordList)</span><br><span class="line">        classList.append(<span class="number">0</span>)</span><br><span class="line">    vocabList = createVocabSet(docList)</span><br><span class="line">    trainSet = list(range(50));testSet = []</span><br><span class="line">    <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        import numpy</span><br><span class="line">        randIndex = int(numpy<span class="selector-class">.random</span>.uniform(<span class="number">0</span>,len(trainSet)))</span><br><span class="line">        testSet.append(trainSet[randIndex])</span><br><span class="line">        del(trainSet[randIndex])</span><br><span class="line">    trainMat = [];trainClassList = []</span><br><span class="line">    <span class="keyword">for</span> docIndex <span class="keyword">in</span> trainSet:</span><br><span class="line">        trainMat.append(setOfWordsVec(vocabList,docList[docIndex]))</span><br><span class="line">        trainClassList.append(classList[docIndex])</span><br><span class="line">    pSpam,p0V,p1V = trainNB0(array(trainMat),trainClassList)</span><br><span class="line"></span><br><span class="line">    errorCount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> docIndex <span class="keyword">in</span> testSet:</span><br><span class="line">        testVec = setOfWordsVec(vocabList,docList[docIndex])</span><br><span class="line">        <span class="keyword">if</span> classifyNB(testVec,p0V,p1V,pSpam) != classList[docIndex]:</span><br><span class="line">            errorCount += <span class="number">1</span></span><br><span class="line">    print(<span class="string">'the error rate is :'</span>,<span class="attribute">float</span>(errorCount)/len(testSet))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">spamTest</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>五、样例3：根据某个人说话词语来判断所在的城市<br>getYourCityFromWord.py</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 案例3：使用beyes从个人广告中获取区域倾向</span><br><span class="line"># 书上说的有点婉转，使得不能很好的和本章联系；其实这里就是给你两个城市的人们说话的用词，</span><br><span class="line"># 然后通过这些用词来区分某个人属于哪个城市，另外这间接的可以得出城市的词云库信息；</span><br><span class="line"># 另外这种方式也是广告商们如何分析用户的行为信息来确定用户的年龄和职业来进行精确推送；还有一些婚恋网站匹配等</span><br><span class="line">from unit04<span class="selector-class">.filterEmail</span> import *</span><br><span class="line">import feedparser</span><br><span class="line"></span><br><span class="line"># 这里使用了词袋模型</span><br><span class="line">def calcMostFreq(vocabList,fullText):</span><br><span class="line">    import operator</span><br><span class="line">    freqDict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> vocabList:</span><br><span class="line">        freqDict[word] = fullText.cout(word)</span><br><span class="line">    sortedFreq = sorted(freqDict.items(),key=operator<span class="selector-class">.itemgetter</span>,reverse=True)</span><br><span class="line">    return sortedFreq[:<span class="number">30</span>]</span><br><span class="line"></span><br><span class="line">def localWords(feed1,feed0):</span><br><span class="line">    docList = [];classList = [];fullText = []</span><br><span class="line">    minLen = min(len(feed1[<span class="string">'entries'</span>]),len(feed0[<span class="string">'entries'</span>]))</span><br><span class="line">    <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(minLen):</span><br><span class="line">        wordList = textParse(feed1[<span class="string">'entries'</span>][i][<span class="string">'summary'</span>])</span><br><span class="line">        docList.append(wordList)</span><br><span class="line">        fullText.extend(wordList)</span><br><span class="line">        classList.append(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        wordList = textParse(feed0[<span class="string">'entries'</span>][i][<span class="string">'summary'</span>])</span><br><span class="line">        docList.append(wordList)</span><br><span class="line">        fullText.extend(wordList)</span><br><span class="line">        classList.append(<span class="number">0</span>)</span><br><span class="line">    vocabList = createVocabSet(docList)</span><br><span class="line">    top30Words = calcMostFreq(vocabList,fullText)</span><br><span class="line">    # 去掉出现频率最高的那些词</span><br><span class="line">    <span class="keyword">for</span> pairW <span class="keyword">in</span> top30Words:</span><br><span class="line">        <span class="keyword">if</span> pairW[<span class="number">0</span>] <span class="keyword">in</span> vocabList:</span><br><span class="line">            vocabList.remove(pairW[<span class="number">0</span>])</span><br><span class="line">    trainSet = list(range(2 * minLen));</span><br><span class="line">    testSet = []</span><br><span class="line">    <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">        import numpy</span><br><span class="line">        randIndex = int(numpy<span class="selector-class">.random</span>.uniform(<span class="number">0</span>,len(trainSet)))</span><br><span class="line">        testSet.append(trainSet[randIndex])</span><br><span class="line">        del(trainSet[randIndex])</span><br><span class="line">    trainMat = [];trainClassList = []</span><br><span class="line">    <span class="keyword">for</span> docIndex <span class="keyword">in</span> trainSet:</span><br><span class="line">        trainMat.append(bagOfWordsVec(vocabList,docList[docIndex]))</span><br><span class="line">        trainClassList.append(classList[docIndex])</span><br><span class="line">    pSpam,p0V,p1V = trainNB0(array(trainMat),trainClassList)</span><br><span class="line"></span><br><span class="line">    errorCount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> docIndex <span class="keyword">in</span> testSet:</span><br><span class="line">        testVec = bagOfWordsVec(vocabList,docList[docIndex])</span><br><span class="line">        <span class="keyword">if</span> classifyNB(testVec,p0V,p1V,pSpam) != classList[docIndex]:</span><br><span class="line">            errorCount += <span class="number">1</span></span><br><span class="line">    print(<span class="string">'the  rate is :'</span>,<span class="attribute">float</span>(errorCount)/len(testSet))</span><br><span class="line">    return pSpam,p0V,p1V</span><br><span class="line"></span><br><span class="line"># 测试</span><br><span class="line"># 说明：可能是由于网络访问的原因，这个无法完成</span><br><span class="line"># ny = feedparser.parse('http://newyork.craiglist.org/stp/insex.rss')</span><br><span class="line"># sf = feedparser.parse('http://sfbay.craiglist.org/stp/insex.rss')</span><br><span class="line">ny = feedparser.parse(<span class="string">'http://newyork.craiglist.org/stp/index.rss'</span>)</span><br><span class="line">sf = feedparser.parse(<span class="string">'http://sfbay.craiglist.org/stp/index.rss'</span>)</span><br><span class="line">vocabList,pSF,pNY = localWords(ny,sf)</span><br><span class="line"></span><br><span class="line"># 得到两个城市的词频</span><br><span class="line"><span class="function"><span class="title">getTopWords</span><span class="params">(ny,sf)</span></span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>ML/DL</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>贝叶斯</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习实战-11关联分析Apriori算法-pytohn3</title>
    <url>/2017/10/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-11%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90Apriori%E7%AE%97%E6%B3%95-pytohn3/</url>
    <content><![CDATA[<p>==感悟：这一章的理论很浅，浅到似乎只需要一个数学公式就能够表达。但是这一章却花费了我整整两天时间。有时候我在想，为什么总是有人很多人想得多做得少，理论很深却只会纸上谈兵。很长的一段时间我就是这种人，自以为智力还算可以，很多数学问题自认为很简单，看了很多书，学了很多知识，但真正向别人讲解时，却怎么也讲不清，其实最深处的原因，还是自身根本就没有熟练地理解其中的含义，有些东西并不是想当然的。其实会和熟差距是非常远的。这让我想起了高中时期，任何题目一眼飘过就能立马动笔，几乎遇不到不会做的试题。而这种情况的出现却是依靠高一高二不断地练习达到的。就像现在这样，其实道理很简单，但是我们还是站在别人的肩膀上行走，你并不是熟路人，瞬时的记忆不可能完成，如果没人提点，庞大的知识体系你根本无法构建，即便一个很小的问题你都不知从何开始。而，这本书中，很多地方都体现了很好地数据处理逻辑，如果给我们自己来组织，很可能不知道从哪着手，或者无法合理地安排函数结构，也可能无法达到强大的可修改性。其中的很多逻辑，在理论上很简单，但是通过代码来表达，不同的形式，也可能千差万别。==</p>
<hr>
<p><strong>一、关联分析</strong></p>
<ol>
<li>什么是关联分析：关联分析就是你找出两个事物之间的联系。比如找出吸烟和肺癌之间的联系，或者典型的啤酒和尿布的故事。</li>
<li>两个指标：</li>
</ol>
<ul>
<li>支持度：数据集中包含该项数据的比例</li>
<li>可信度、置信度：通过P推断出H的可靠性概率：P-&gt;H = （P U H）/(P),可信度越高，相关度越大</li>
</ul>
<ol start="3">
<li>Apriori算法：</li>
</ol>
<ul>
<li>原理：算法的主要作用是为了减少计算量。正原理，如果某个项是频繁的，则它所有的子项也是频繁的；同理，如果某个子项是非频繁的，那么它的所有超集也是非频繁的。这样，如果我们这些高计算频繁项，然后扩展对应的超集，这样就排除了非频繁的。具体的代码表达可能很复杂，需要判断各种情况。而且其中也存在一些可以简化计算的其他方式。</li>
<li>代码1：函数逻辑 Apriori.py：</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">def loadDataSet():</span><br><span class="line">    return [[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">5</span>]]</span><br><span class="line"></span><br><span class="line">def loadDataSet2():</span><br><span class="line">    return [[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 得出数据集的单个元素Set</span><br><span class="line">def createC1(dataSet):</span><br><span class="line">    <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">    :param dataSet:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    "</span><span class="string">""</span></span><br><span class="line">    C1 = []</span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> dataSet:</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> data:</span><br><span class="line">            <span class="keyword">if</span> not [item] <span class="keyword">in</span> C1: #需要通过[]将元素封装为元组，便于后续作为一个整体进行集合运算</span><br><span class="line">                C1.append([item])</span><br><span class="line">    return C1</span><br><span class="line"></span><br><span class="line"># 计算单个元素的支持度，即占比</span><br><span class="line">def scanD(data, Ck, minSupport):</span><br><span class="line">    <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">    相当于遍历D，求出所有的Ck中的元素支持度大于minsupport的</span></span><br><span class="line"><span class="string">    :return: 满足支持度的元素、所有元素-支持度的map</span></span><br><span class="line"><span class="string">    :param data: dataSet</span></span><br><span class="line"><span class="string">    :param Ck:元素集合</span></span><br><span class="line"><span class="string">    :param minSupport:最小支持度阈值</span></span><br><span class="line"><span class="string">    "</span><span class="string">""</span></span><br><span class="line">    eleMap = &#123;&#125; # 元素-元素总个数 的映射</span><br><span class="line">    <span class="keyword">for</span> oneData <span class="keyword">in</span> data:</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> Ck:</span><br><span class="line">            if element.issubset(oneData): # set子集</span><br><span class="line">                # 这样写会报错，因为字典的key不可变，而set是可变的，不能作为字典&#123;&#125;的key，所以需要使用frozenset(冻结set，不可变)</span><br><span class="line">                # TypeError: unhashable type: 'set' --&gt; element</span><br><span class="line">                if not eleMap.__contains__(element): # 这里与原书不同</span><br><span class="line">                    eleMap[element] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    eleMap[element] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    # 计算元素支持度</span><br><span class="line">    # 注意：错误object of type 'map' has no len()</span><br><span class="line">    # 原因：In Python 3, map returns an iterator not a list:</span><br><span class="line">    # python3中map是一个迭代器，不能使用len(),需要将map转化为list才能使用</span><br><span class="line">    # numsum = float(len(data))</span><br><span class="line">    numsum = len(list(data)) # 这个地方报错是因为在其它代码处，使用了list作为变量！记住：永远不要使用关键词作为变量</span><br><span class="line">    supportMap = &#123;&#125; # 所有元素支持度的值</span><br><span class="line">    retList = [] # 满足支持度的元素</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> eleMap:</span><br><span class="line">        try:</span><br><span class="line">            support = eleMap[key]/<span class="attribute">float</span>(numsum)</span><br><span class="line">        except:</span><br><span class="line">            support = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">if</span> support &gt;= minSupport:</span><br><span class="line">            retList.insert(0,key) # 将key插入到第0个位置之前（即最开始位置）</span><br><span class="line">        supportMap[key] = support</span><br><span class="line">    return retList,supportMap</span><br><span class="line"></span><br><span class="line"># 将组合Lk合称为每个集合为k个元素的集合</span><br><span class="line"># 如[&#123;1&#125;,&#123;2&#125;,&#123;3&#125;]--&gt;[&#123;1,2&#125;,&#123;2,3&#125;,&#123;1,3&#125;]</span><br><span class="line">def aprioriGen(Lk, k):</span><br><span class="line">    retList = []</span><br><span class="line">    lenLk = len(Lk)</span><br><span class="line">    <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(lenLk):</span><br><span class="line">        # 注意：下面的逻辑复杂，需要参考书中p208</span><br><span class="line">        # k-2,是为了将前k-2项相同时，集合合并；比如当k=2时，只有一个元素&#123;1&#125;、&#123;2&#125;，此时k-2=0，L1==L2,直接并集运算</span><br><span class="line">        # k=3时，有两个元素&#123;1,2&#125;、&#123;1,3&#125;、&#123;2,3&#125;、&#123;5,6&#125;；由于只能合并为大小为k=3的集合，所以必然只有k-2项是相同的，也只需要组合这种情况</span><br><span class="line">        # 此时组合只有&#123;1,2,3&#125;；</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,lenLk):</span><br><span class="line">            L1 = list(Lk[i])[: k-<span class="number">2</span>]</span><br><span class="line">            L2 = list(Lk[j])[: k-<span class="number">2</span>]</span><br><span class="line">            # print '-----i=', i, k-2, Lk, Lk[i], list(Lk[i])[: k-2]</span><br><span class="line">            # print '-----j=', j, k-2, Lk, Lk[j], list(Lk[j])[: k-2]</span><br><span class="line">            L1.sort()</span><br><span class="line">            L2.sort()</span><br><span class="line">            # 第一次 L1,L2 为空，元素直接进行合并，返回元素两两合并的数据集</span><br><span class="line">            # if first k-2 elements are equal</span><br><span class="line">            <span class="keyword">if</span> L1 == L2:</span><br><span class="line">                # set union</span><br><span class="line">                # print 'union=', Lk[i] | Lk[j], Lk[i], Lk[j]</span><br><span class="line">                retList.append(Lk[i] | Lk[j])</span><br><span class="line">    return retList</span><br><span class="line"></span><br><span class="line"># 提升一级：计算所有可能集合的支持度</span><br><span class="line"># 找出数据集 dataSet 中支持度 &gt;= 最小支持度的候选项集以及它们的支持度。即我们的频繁项集。</span><br><span class="line">def apriori(dataSet, minSupport=0.5):</span><br><span class="line">    <span class="string">""</span><span class="string">"apriori（首先构建集合 C1，然后扫描数据集来判断这些只有一个元素的项集是否满足最小支持度的要求。那么满足最小支持度要求的项集构成集合 L1。然后 L1 中的元素相互组合成 C2，C2 再进一步过滤变成 L2，然后以此类推，知道 CN 的长度为 0 时结束，即可找出所有频繁项集的支持度。）</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        dataSet 原始数据集</span></span><br><span class="line"><span class="string">        minSupport 支持度的阈值</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        L 频繁项集的全集</span></span><br><span class="line"><span class="string">        supportData 所有元素和支持度的全集</span></span><br><span class="line"><span class="string">    "</span><span class="string">""</span></span><br><span class="line">    # C1 即对 dataSet 进行去重，排序，放入 list 中，然后转换所有的元素为 frozenset</span><br><span class="line">    C1 = createC1(dataSet)</span><br><span class="line">    C1 = list(map(frozenset,C1))</span><br><span class="line">    # print 'C1: ', C1</span><br><span class="line">    # 对每一行进行 set 转换，然后存放到集合中</span><br><span class="line">    D = list(map(set, dataSet))</span><br><span class="line">    # print 'D=', D</span><br><span class="line">    # 计算候选数据集 C1 在数据集 D 中的支持度，并返回支持度大于 minSupport 的数据</span><br><span class="line">    L1, supportData = scanD(D, C1, minSupport)</span><br><span class="line">    # print "L1=", L1, "\n", "outcome: ", supportData</span><br><span class="line"></span><br><span class="line">    # L 加了一层 list, L 一共 2 层 list</span><br><span class="line">    L = [L1]</span><br><span class="line">    k = 2 # 一组合有两个元素为起点</span><br><span class="line">    # 判断 L 的第 k-2 项的数据长度是否 &gt; 0。第一次执行时 L 为 [[frozenset([1]), frozenset([3]), frozenset([2]), frozenset([5])]]。L[k-2]=L[0]=[frozenset([1]), frozenset([3]), frozenset([2]), frozenset([5])]，最后面 k += 1</span><br><span class="line">    while (len(L[k-<span class="number">2</span>]) &gt; <span class="number">0</span>):</span><br><span class="line">        # print 'k=', k, L, L[k-2]</span><br><span class="line">        # 输出k个元素组合时，所对应的集合，并求解对应满足的支持度</span><br><span class="line">        Ck = aprioriGen(L[k-2], k) # 例如: 以 &#123;0&#125;,&#123;1&#125;,&#123;2&#125; 为输入且 k = 2 则输出 &#123;0,1&#125;, &#123;0,2&#125;, &#123;1,2&#125;. 以 &#123;0,1&#125;,&#123;0,2&#125;,&#123;1,2&#125; 为输入且 k = 3 则输出 &#123;0,1,2&#125;</span><br><span class="line">        # print 'Ck', Ck</span><br><span class="line"></span><br><span class="line">        Lk, supK = scanD(D, Ck, minSupport) # 计算候选数据集 CK 在数据集 D 中的支持度，并返回支持度大于 minSupport 的数据</span><br><span class="line">        # 保存所有候选项集的支持度，如果字典没有，就追加元素，如果有，就更新元素</span><br><span class="line">        supportData.update(supK) # 理解update的含义</span><br><span class="line">        # 下面是为了排除最后一个[]空值</span><br><span class="line">        <span class="keyword">if</span> len(Lk) == <span class="number">0</span>:</span><br><span class="line">            break</span><br><span class="line">        # Lk 表示满足频繁子项的集合，L 元素在增加，例如:</span><br><span class="line">        # l=[[set(1), set(2), set(3)]]</span><br><span class="line">        # l=[[set(1), set(2), set(3)], [set(1, 2), set(2, 3)]]</span><br><span class="line">        L.append(Lk)</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">        # print 'k=', k, len(L[k-2])</span><br><span class="line">    return L, supportData</span><br><span class="line"></span><br><span class="line"># 输出关联项及对应的值；如p-&gt;h</span><br><span class="line">def generateRules(L,supportData,minConf):</span><br><span class="line">    bigRuleList = []</span><br><span class="line">    <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(<span class="number">1</span>,len(L)):</span><br><span class="line">        <span class="keyword">for</span> freqSet <span class="keyword">in</span> L[i]:</span><br><span class="line">            H1 = [frozenset([item]) for item in freqSet] # 这里的H1是freqSet的变形，起初看了半天没明白</span><br><span class="line">            <span class="keyword">if</span> i==<span class="number">1</span>:</span><br><span class="line">                calcCong(freqSet,H1,supportData,bigRuleList,minConf)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ruleFromConseq(freqSet,H1,supportData,bigRuleList,minConf)</span><br><span class="line">    return bigRuleList</span><br><span class="line"></span><br><span class="line">def calcCong(freqSet,H,supportData,bigRuleList,minConf=0.7):</span><br><span class="line">    prunedH = [] # 单词pruned-修剪</span><br><span class="line">    <span class="keyword">for</span> conseq <span class="keyword">in</span> H:</span><br><span class="line">        conf = supportData[freqSet]/supportData[freqSet-conseq]</span><br><span class="line">        <span class="keyword">if</span> conf &gt;= minConf:</span><br><span class="line">            print(freqSet-conseq,<span class="string">'--&gt;'</span>,conseq,<span class="string">'is:'</span>,conf)</span><br><span class="line">            bigRuleList.append((freqSet-conseq,conseq,conf))</span><br><span class="line">            prunedH.append(conseq)</span><br><span class="line">    return prunedH</span><br><span class="line"></span><br><span class="line"># 这个是为了解决另一个情况，例如：&#123;2，3，4&#125;，我们需要找&#123;2,3&#125;--&gt;&#123;4&#125;,还需要知道&#123;2&#125;--&gt;&#123;3,4&#125;,即hmp1=&#123;2,3&#125;,m=2</span><br><span class="line">def ruleFromConseq(freqSet,H,supportData,bigRuleList,minConf=0.7):</span><br><span class="line">    length = len(H[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span> len(freqSet) &gt; (length+<span class="number">1</span>):</span><br><span class="line">        sonH = aprioriGen(H,length+<span class="number">1</span>)</span><br><span class="line">        isSonH = calcCong(freqSet,sonH,supportData,bigRuleList,minConf)</span><br><span class="line">        # 这里使用了一个数学逻辑，如果isSonH只有一个，就说明无法再划分</span><br><span class="line">        #（定理：如果某条规则不满足可信度，左部所有的子集也不满足可信度）</span><br><span class="line">        if len(isSonH) &gt; 1: # 去掉这个语句也行，只是计算量增大</span><br><span class="line">            ruleFromConseq(freqSet,isSonH,supportData,bigRuleList,minConf)</span><br></pre></td></tr></table></figure>

<ul>
<li>代码2：测试函数 test.py：</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"># 另外我发现一个问题：党创建一个python项目时，会自动创建一个__init__.py文件，</span><br><span class="line"># 这是默认初始化文件，如果直接运行这个文件，首先初始化会运行一次这个文件，之后会再次运行这个文件。也就是这个文件被运行了两次。</span><br><span class="line">from unit11 import Apriori # 这个按照格式来，否则会报错，虽然错误不影响内部逻辑</span><br><span class="line"></span><br><span class="line">dataSet = Apriori.loadDataSet2()</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(dataSet)</span></span></span><br><span class="line"></span><br><span class="line">C1 = Apriori.createC1(dataSet)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(C1)</span></span></span><br><span class="line"></span><br><span class="line">D = map(set,dataSet)</span><br><span class="line"># print(list(D))</span><br><span class="line"># C = map(set,C1)</span><br><span class="line">C = map(frozenset,C1)</span><br><span class="line"># print(list(C))</span><br><span class="line"></span><br><span class="line"># 注意通过list(map)来将map转为list，只能第一次有效，第二次返回的list为空（可能是由于map是迭代的，一次list遍历后，就到了末尾）</span><br><span class="line">data1 = list(D)</span><br><span class="line"><span class="selector-tag">label</span> = list(C)</span><br><span class="line">L1,suppDataMap = Apriori.scanD(data1,<span class="selector-tag">label</span>,<span class="number">0.5</span>)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">'满足的支持度元素是：'</span>+str(L1)</span></span>)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">'所有元素的支持度是：'</span>+str(suppDataMap)</span></span>)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">'--------p207'</span>)</span></span></span><br><span class="line"></span><br><span class="line">L,suppDataMap2 = Apriori.apriori(data1)</span><br><span class="line"><span class="keyword">for</span> onel <span class="keyword">in</span> L:</span><br><span class="line">    print(onel)</span><br><span class="line">    print(str(suppDataMap2))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">'-----11'</span>)</span></span></span><br><span class="line">rules = Apriori.generateRules(L,suppDataMap2,<span class="number">0.5</span>)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(rules)</span></span></span><br><span class="line"></span><br><span class="line"># 由于国会测试那个需要申请key，比较麻烦，就没写</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">'发现毒蘑菇的相似特征'</span>)</span></span></span><br><span class="line"># 毒蘑菇分类</span><br><span class="line">mushDataSet = [line.split() <span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">'mushroom.dat'</span>).readlines()]</span><br><span class="line">L,supportMapMush = Apriori.apriori(mushDataSet,<span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line"># 其中L为关联集合标签，标签中2代表是毒蘑菇，所以只需要判断那些标签含有2，就可以大体确定那些可能是毒蘑菇</span><br><span class="line"># 注意数据中的数字代表特征，所有的特征从1开始标，不能重复</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> L:</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> row:</span><br><span class="line">        # set.intersection(item)</span><br><span class="line">        # Return a new set with elements common to the set and all others.</span><br><span class="line">        # 即返回一个包含此元素的新的set</span><br><span class="line">        <span class="keyword">if</span> item.intersection(<span class="string">'2'</span>):</span><br><span class="line">            print(item)</span><br></pre></td></tr></table></figure>
<p>以下链接可能解释还行，没看，可以参考一下；另外请参考书籍<br>相关链接：<a href="http://blog.csdn.net/u010859707/article/details/78180301" target="_blank" rel="noopener">http://blog.csdn.net/u010859707/article/details/78180301</a></p>
]]></content>
      <categories>
        <category>ML/DL</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>关联分析</tag>
        <tag>Apriori</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习实战-5Logistic回归</title>
    <url>/2017/10/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-5Logistic%E5%9B%9E%E5%BD%92/</url>
    <content><![CDATA[<p>几个关键词：逻辑回归、极大似然估计、激活函数</p>
<h2 id="参考书籍：西瓜书P54-《统计学习方法》P77"><a href="#参考书籍：西瓜书P54-《统计学习方法》P77" class="headerlink" title="参考书籍：西瓜书P54,《统计学习方法》P77"></a>参考书籍：西瓜书P54,《统计学习方法》P77</h2><ol>
<li><p>回归和分类的区别<br>回归是一种连续变量的预测，比如函数拟合，股票线等，人的年龄。分类的特征却不是连续变化的，比如西瓜的颜色是不能连续量化的</p>
</li>
<li><p>线性回归</p>
</li>
</ol>
<ul>
<li>举个例子，如果我们现在有两个未知数x1,x2,即特征值；一个输出变量y，即分类结果；我们需要求解一个方程<code>w1x1+w2x2+b = y</code>,来拟合这种曲线来预测之后的曲线。一般而言我们是直接去方程组的，但是，这里数据量很大，而且我们的方程是用来预测的，不可能直接求出精确的值，这样会过拟合。</li>
<li>因而，我们考虑一种近似求解，通过训练来改变w的值，来拟合直线。这里我们可以把这个函数考虑为一个感知机。误差为<code>error = y - (w1x1+w2x2+b)</code> ，对其对其进行w求导得出梯度值，通过<code>w = w + grad(error,w)</code>来更新权值</li>
<li>但是对于二分类而言，x1、x2与y的关系并不是直接就能通过这种直线进行拟合的，所以需要使用激活函数来将之间变为曲线拟合，这和感知机中激活函数的原理是一样的，另外含有支持向量机中的核函数。</li>
<li>所以我们设 <code>z = w1x1+w2x2+b</code>，<code>h(z) = 1/(1+exp(-z)</code>;将输出结果归一化到0~1之间，同时拟合曲线。</li>
</ul>
<ol start="3">
<li>以下三种情况，分别是梯度下降和随机梯度，以及学习率变化的随机梯度</li>
<li>梯度导数推导：<a href="https://my.oschina.net/tantexian/blog/1359191，这里使用的是对数损失函数" target="_blank" rel="noopener">https://my.oschina.net/tantexian/blog/1359191，这里使用的是对数损失函数</a><br><img src="http://img.blog.csdn.net/20150721231518546?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="enter description here"><br><img src="http://img.blog.csdn.net/20150723231350914?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="enter description here"></li>
</ol>
<p>代码：logRegres.py</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">import math,random</span><br><span class="line">import numpy as np</span><br><span class="line">import matplotlib<span class="selector-class">.pyplot</span> as plt</span><br><span class="line"></span><br><span class="line"># 将文本数据转化为矩阵训练数据</span><br><span class="line">def loadDataSet():</span><br><span class="line">    dataMat = []; labelMat = []</span><br><span class="line">    file = open(<span class="string">'testSet.txt'</span>)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> file.readlines():</span><br><span class="line">        line = line.strip().split()</span><br><span class="line">        dataMat.append([<span class="number">1.0</span>,<span class="attribute">float</span>(line[<span class="number">0</span>]),float(line[<span class="number">1</span>])])</span><br><span class="line">        labelMat.append([<span class="attribute">float</span>(line[<span class="number">2</span>])])</span><br><span class="line">    return dataMat,labelMat</span><br><span class="line"></span><br><span class="line"># 定义sigmoid激活函数</span><br><span class="line">def sigmoid(inX):</span><br><span class="line">    return <span class="number">1.0</span>/(<span class="number">1.0</span>+np.exp(-inX))</span><br><span class="line"></span><br><span class="line"># 实现简单地二分类、梯度下降、最大似然估计</span><br><span class="line">def gradAscent(dataMatrix,classLabels):</span><br><span class="line">    dataMatrix = np.mat(dataMatrix)</span><br><span class="line">    labelMatrix  = np.mat(classLabels)</span><br><span class="line">    m,n = np.shape(dataMatrix)</span><br><span class="line">    alpha = <span class="number">0.001</span></span><br><span class="line">    maxCycles = <span class="number">500</span></span><br><span class="line">    weights = np.ones((n,1)) # n*1</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(maxCycles):</span><br><span class="line">        h = sigmoid(dataMatrix*weights)</span><br><span class="line">        error = labelMatrix - h</span><br><span class="line">        #这里的公式是直接推导出来的即：梯度=XT * (Y-XW)</span><br><span class="line">        weights = weights + dataMatrix.transpose() * error  </span><br><span class="line">    return weights</span><br><span class="line"></span><br><span class="line"># 改进1：随机梯度下降，学习率不变</span><br><span class="line"># 注意：这里实际上并不是随机，只是每次都选一个样本训练，遍历完</span><br><span class="line"># 随机是指，每次多选择部分数据进行训练。</span><br><span class="line">def randomGradAscent(dataMatr,classLabels):</span><br><span class="line">    dataMatrix = np.array(dataMatr)</span><br><span class="line">    m,n = np.shape(dataMatrix)</span><br><span class="line">    alpha = <span class="number">0.01</span></span><br><span class="line">    weights = np.ones(n)</span><br><span class="line">    <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(m):</span><br><span class="line">        h = sigmoid(sum(dataMatrix[i] * weights))</span><br><span class="line">        error = classLabels[i] - h</span><br><span class="line">        weights = weights + alpha * error * dataMatrix[i]</span><br><span class="line">    return np.array(np.mat(weights).transpose()) # 由于这里的weights是横向数组，所以需要转换为统一的竖向数组</span><br><span class="line"></span><br><span class="line"># 改进2：随机梯度下降,学习率变化！</span><br><span class="line"># 注意：通过研究上面的梯度上升效率，发现，在最初是下降时很快的，学习率（即步长）可以适当加快；</span><br><span class="line"># 后期由于误差减小，学习率变化变小；即可以设置学习率随着训练的次数逐渐减小</span><br><span class="line">def randomGradAscentPlus(dataMatr,classLabels,num):</span><br><span class="line">    dataMatrix = np.array(dataMatr)</span><br><span class="line">    m,n = np.shape(dataMatrix)</span><br><span class="line">    alpha = <span class="number">0.01</span></span><br><span class="line">    weights = np.ones(n)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(num):</span><br><span class="line">        dataIndex = list(range(m))</span><br><span class="line">        <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(m):</span><br><span class="line">            alpha = <span class="number">4.0</span>/(<span class="number">1.0</span>+i+j)+<span class="number">0.01</span></span><br><span class="line">            randomIndex = int(random.uniform(<span class="number">0</span>,len(dataIndex)))</span><br><span class="line">            h = sigmoid(sum(dataMatrix[randomIndex]*weights))</span><br><span class="line">            error = classLabels[randomIndex] - h</span><br><span class="line">            weights = weights + alpha * error * dataMatrix[i]</span><br><span class="line">            del(dataIndex[randomIndex])</span><br><span class="line">    return np.array(np.mat(weights).transpose())</span><br><span class="line"></span><br><span class="line"># 画出分类图</span><br><span class="line">def plotBestFit(weightMat):</span><br><span class="line">    weights = np.array(weightMat)</span><br><span class="line">    dataMat,labelMat = loadDataSet()</span><br><span class="line">    n = np.shape(dataMat)[0] # 样本数</span><br><span class="line">    xcord1 = [];ycord1 = []</span><br><span class="line">    xcord2 = [];ycord2 = []</span><br><span class="line">    <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(n):</span><br><span class="line">        # 类别为1</span><br><span class="line">        <span class="keyword">if</span> labelMat[i][<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">            xcord1.append(dataMat[i][3]) # x,y分别对应特征值（看作是坐标）</span><br><span class="line">            ycord1.append(dataMat[i][<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            xcord2.append(dataMat[i][<span class="number">4</span>])</span><br><span class="line">            ycord2.append(dataMat[i][<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">    fig = plt.figure() # 创建一个视图</span><br><span class="line">    ax = fig.add_subplot(1,1,1) # 添加一个面板</span><br><span class="line">    ax.scatter(xcord1,ycord1,s=30,c='red',marker='s') # 创建一个x vs y二维图，s-size of point，c-color,maker-形状、s-square正方形</span><br><span class="line">    ax.scatter(xcord2,ycord2,s=<span class="number">30</span>,c=<span class="string">'green'</span>)</span><br><span class="line">    x = np.arange(-3.0,3.0,0.1) # 坐标轴范围</span><br><span class="line">    y = (-weights[<span class="number">0</span>][<span class="number">0</span>]-weights[<span class="number">1</span>][<span class="number">0</span>]*x)/weights[<span class="number">2</span>][<span class="number">0</span>]</span><br><span class="line">    ax.plot(x,y) # 模拟直线</span><br><span class="line">    plt.xlabel('特征x1');plt.ylabel('特征x2') # 坐标标题</span><br><span class="line">    plt.show() # 显示</span><br><span class="line"></span><br><span class="line"># 从疝气病症预测病马的死亡率</span><br><span class="line"># 处理缺失值</span><br><span class="line"></span><br><span class="line"># 激活函数</span><br><span class="line">def classifyVector(inX,weights):</span><br><span class="line">    dataMatrix = np.array(inX)</span><br><span class="line">    # 这里需要再将weights转化回来</span><br><span class="line">    # np.array(np.mat(weights).transpose())</span><br><span class="line">    w = np.array(np.mat(weights).transpose())[<span class="number">0</span>]</span><br><span class="line">    prop = sigmoid(sum(dataMatrix[<span class="number">0</span>]*w))</span><br><span class="line">    <span class="keyword">if</span> prop &gt; <span class="number">0.5</span>:</span><br><span class="line">        return <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        return <span class="number">0</span></span><br><span class="line"></span><br><span class="line">def colicTest():</span><br><span class="line">    frTrain = open(<span class="string">'horseColicTraining.txt'</span>)</span><br><span class="line">    frTest = open(<span class="string">'horseColicTest.txt'</span>)</span><br><span class="line">    trainingSet = []; trainingLabels = []</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> frTrain.readlines():</span><br><span class="line">        currLine = line.strip().split(<span class="string">'\t'</span>)</span><br><span class="line">        lineArr = []</span><br><span class="line">        <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(<span class="number">21</span>):</span><br><span class="line">            lineArr.append(<span class="attribute">float</span>(currLine[i]))</span><br><span class="line">        trainingSet.append(lineArr)</span><br><span class="line">        trainingLabels.append([<span class="attribute">float</span>(currLine[<span class="number">21</span>])])</span><br><span class="line">    print(trainingSet)</span><br><span class="line">    trainWeights = randomGradAscentPlus(trainingSet,trainingLabels,<span class="number">500</span>)</span><br><span class="line"></span><br><span class="line">    # 测试集</span><br><span class="line">    errorCount = 0;numTestVec = 0;</span><br><span class="line">    <span class="keyword">for</span> testLine <span class="keyword">in</span> frTest.readlines():</span><br><span class="line">        numTestVec = numTestVec+<span class="number">1.0</span></span><br><span class="line">        currLine = testLine.strip().split(<span class="string">'\t'</span>)</span><br><span class="line">        lineArr = []</span><br><span class="line">        <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(<span class="number">21</span>):</span><br><span class="line">            lineArr.append(<span class="attribute">float</span>(currLine[i]))</span><br><span class="line">        print(lineArr)</span><br><span class="line">        <span class="keyword">if</span> int(classifyVector(lineArr,trainWeights)) != int(<span class="attribute">float</span>(currLine[<span class="number">21</span>])):</span><br><span class="line">            errorCount = errorCount+<span class="number">1</span></span><br><span class="line">    errorRate = errorCount / numTestVec</span><br><span class="line">    print("the errorRate is: %f" % errorRate)</span><br><span class="line">    return errorRate</span><br><span class="line"></span><br><span class="line"># 多次测试求平均错误率</span><br><span class="line">def mutiTest():</span><br><span class="line">    numTests = 10;errorSum = 0.0</span><br><span class="line">    <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(numTests):</span><br><span class="line">        errorSum = errorSum + colicTest()</span><br><span class="line">    print("after %d itertions,the errorRate mean is %f" % (numTests,errorSum/numTests))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 补充知识点：</span><br><span class="line"># 1.str.strip([chars]):剥夺，脱去，即去除str中含有的char字符，</span><br><span class="line"># Return a copy of the string with the leading and trailing characters removed.</span><br><span class="line"></span><br><span class="line"># 2.str.split(sep=None, maxsplit=-1),返回一个字符串隔离的list</span><br><span class="line"># Return a list of the words in the string, using sep as the delimiter string.</span><br><span class="line"># \t represents a tab 空格键</span><br><span class="line"># \n represents a new line 换行</span><br><span class="line"># \r represents a carriage return 回车</span><br><span class="line"></span><br><span class="line"># 3.transpose():矩阵转置</span><br><span class="line"></span><br><span class="line"># 4.注意矩阵mat、列表list、np.array之间的区别</span><br><span class="line"># 对mat进行操作，需要先将mat转化为array，再进行操作，否则会出现：x and y must have same first dimension</span><br><span class="line"></span><br><span class="line"># 5.float和str和int之间的转换，出错会：</span><br><span class="line"># TypeError: ufunc 'multiply' did not contain a loop with signature matching types dtype('S32') dtype('S32') dtype('S32')</span><br><span class="line"></span><br><span class="line"># 6.坑是真的多，感觉是在学python而不是机器学习。</span><br></pre></td></tr></table></figure>
<p>测试代码：logTest.py</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"># 出现一些微小的错误，没事迷茫，应该是几个函数库的不同所引起的，比如random函数，math、numpy中的都有，</span><br><span class="line"># 可能有一些区别，但是书上是用python2写的，和python3有些区别</span><br><span class="line"></span><br><span class="line">from unit05 import logRegres</span><br><span class="line">import numpy as np</span><br><span class="line">dataX,labelY = logRegres.loadDataSet()</span><br><span class="line"></span><br><span class="line"># weights1 = logRegres.gradAscent(dataX,labelY)</span><br><span class="line"># logRegres.plotBestFit(weights1)</span><br><span class="line"></span><br><span class="line"># weights2 = logRegres.randomGradAscent(dataX,labelY)</span><br><span class="line"># logRegres.plotBestFit(weights2)</span><br><span class="line"></span><br><span class="line"># weights3 = logRegres.randomGradAscentPlus(dataX,labelY,150)</span><br><span class="line"># logRegres.plotBestFit(weights3)</span><br><span class="line"></span><br><span class="line">logRegres.mutiTest()</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>ML/DL</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>逻辑回归</tag>
      </tags>
  </entry>
  <entry>
    <title>Tensorflow实战Google-第四章深层神经网络知识点</title>
    <url>/2017/10/04/Tensorflow%E5%AE%9E%E6%88%98Google-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E6%B7%B1%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>1.深层神经网络的两个重要参数：多层和非线性</p>
<ul>
<li><p>非线性：</p>
<ul>
<li>相对于以往的神经网络，由于没有使用激活函数，构造出来的函数往往形如：w1x1+w2x2+…+wnxn + b = 0,很显然这种函数只能模拟线性分割。即只能通过直线来划分，一旦分割面是一个圆形，通过这种方式只能尽可能的得到一个多棱角保卫面，而不能拟合成圆形，存在很大的误差。</li>
<li>细想一下，如果我们换一种权重作用方式，比如将w1x1换为x1^w1 或者 w1*e^x1,很显然这种指数函数作用的结果是一种弯曲状态，就能够拟合上面所说的圆形。但是，目前我们采用的方式是直接在输出层外加上一层激活函数（弯曲函数），就能够实现这种方式。激活函数一般有sigmoid、指数函数等，不同的函数作用效果也不一样。</li>
</ul>
</li>
<li><p>多层</p>
<ul>
<li>还是相对于之前的神经网络，由于之前的神经网络没有隐藏层，相当于只有一层权重作用在输入变量上面，这样，w1x1+w2x2+…+wnxn + b = 0函数作用下，无论是几维空间，输出的结果总是为一条直线。</li>
<li>考虑下简单地二维空间，比如进行异或运算。这种方式显然不能够通过一条直线就能够分成两类。再到多维，那将更不可能，一条直线只能分两类，多个类就无法实行。</li>
<li>现在我们想想，既然一层能画一条直线，那我多画几条直线，然后将这两条直线组合一下不就可以了吗？确实是这样，比如进行异或运算，加上一个隐藏层，隐藏层节点为4，这输入到这四个节点的都负责自己的一部分划分，分别划分四个点区域，这样，输出处理时将这四个区域进行组合，就是整个完整的区域。</li>
</ul>
</li>
</ul>
<p>2.损失函数</p>
<ul>
<li>损失函数度量了训练结果和实际结果之间的一种差别，通过这种差别大小来调整神经网络的参数，以此达到优化神经网络的目的。</li>
<li>经典损失函数<br>分类问题的损失函数一般使用交叉熵配合softmax回归；回归问题由于是连续的，一般只有一个输出节点，所以损失函数使用的是均方误差MSE。<ul>
<li>损失函数的计算方式有很多，不同的领域都有各自最优化的方式。经典损失函数就是分类问题和回归问题经常使用到的损失函数。</li>
<li>经典损失函数是一种对训练输出值和实际值相似度的度量，值越小，相似度越大，更准确的解释：经典损失函数（交叉熵）刻画了两个分布概率之间的距离。具体为什么好用，实用就行，暂时不管。</li>
<li>公式：H(p,q)=−∑p(x)logq(x)，这里的p代表真确答案，q代表预测值</li>
<li>显然∑q(x)=1，即概率和等于1。因此，我们需要将输出转化为概率类型。一般而言，我们可以直接计算输出值在整个输出中出现的概率作为计算值，这里我们使用了softmax函数。</li>
<li>softmax回归函数，是将神经网络的输出结果变成概率分布，softmax(yi)=yi’=e^yi/∑e^yj</li>
<li>均方误差函数：MSE(y,y′)=∑(yi−y’i)^2/n</li>
<li>其他损失函数：不同问题不同对待</li>
</ul>
</li>
</ul>
<ol start="3">
<li>神经网络优化-BP算法和梯度下降算法</li>
</ol>
<ul>
<li>梯度下降算法：<ul>
<li>梯度的反方向是函数下降最快的方向，通过这个方式计算，就能够使得函数向着极小值方向迭代，从而达到训练的目的。</li>
<li><strong>学习率</strong>:通过在梯度下降值上加上一个学习率权重，来控制下降的幅度/步长，即控制下降速度的快慢。</li>
<li>几个缺点：<br>  1.只是局部最优解不是全局最优解<br>  2.计算时间长-由于损失函数计算的是所有训练数据上的损失和，所以计算量大<br>  3.为了加快梯度下降，我们可以采用随机梯度下降或者小批量随机下降</li>
</ul>
</li>
</ul>
<ol start="4">
<li>进一步优化</li>
</ol>
<ul>
<li>学习率的优化：在训练初期，差别往往很大，所以这个时候学习率相对较大能够加快训练的速度；但是随着训练的深入，差别减小，为了防止下降跨度太大导致越界，需要降低学习率；这个时候就可以对学习了本进行指数衰减。</li>
<li>过拟合问题：样本不足、样本有噪声、模型结构过于复杂都将导致模型过拟合。<ul>
<li>正则化：为了避免模型复杂导致的过拟合，我们引入了一个思想，即在损失函数中引入/加入衡量模型复杂度的指标，r*R(w),r为正则化系数，R(w)为描述的是模型参数的大小，通过之中方式限制模型参数的大小来限制模型的复杂度。L1、L2正则化</li>
</ul>
</li>
<li>滑动平均模型：为了使得模型更加健壮，即更加稳定。我们使用了滑动平均模型。<ul>
<li>这种模型通过在损失函数中加入一个衰减率decay来，缓冲模型参数变量的变化程度，即不让他变化过大，能走10步的，只让它走一步。</li>
<li>衰减变量：上面这种方式训练速度有点慢，为了让训练初期快，比如走9步，有引入了参数衰减变量，通过训练次数来控制滑动平均的步长大小，越到后期步长越慢。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>ML/DL</category>
      </categories>
      <tags>
        <tag>DNN</tag>
        <tag>CNN</tag>
        <tag>正则化</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习实战-3决策树</title>
    <url>/2017/09/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-3%E5%86%B3%E7%AD%96%E6%A0%91/</url>
    <content><![CDATA[<ul>
<li><p><strong>划分依据</strong><br>决策树的主要依据为信息熵计算，信息熵最大的最为分类依据</p>
</li>
<li><p><strong>流程</strong><br>创建数据集 –&gt; 计算信息熵，最大值作为结点，划分子数据集 –&gt; 递归寻找</p>
</li>
<li><p><strong>代码</strong></p>
</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">from math import log</span><br><span class="line">import operator</span><br><span class="line"><span class="string">''</span><span class="string">'</span></span><br><span class="line"><span class="string">机器学习实战-第三章（决策树）</span></span><br><span class="line"><span class="string">'</span><span class="string">''</span></span><br><span class="line"></span><br><span class="line"># 创建数据集</span><br><span class="line">def createDataSet():</span><br><span class="line">    dataset = [</span><br><span class="line">        [<span class="number">1</span>, <span class="number">1</span>, <span class="string">'yes'</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">0</span>, <span class="string">'no'</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">1</span>, <span class="string">'no'</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">1</span>, <span class="string">'no'</span>]</span><br><span class="line">    ]</span><br><span class="line">    labels = [<span class="string">'good'</span>, <span class="string">'bad'</span>]</span><br><span class="line">    return dataset, labels</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 计算香农熵</span><br><span class="line">def calcShannonEnt(dataset):</span><br><span class="line">    numEntries = len(dataset)</span><br><span class="line">    labelsCount = &#123;&#125;  # 字典相当于java中的map</span><br><span class="line">    <span class="keyword">for</span> featVec <span class="keyword">in</span> dataset:</span><br><span class="line">        currentLabel = featVec[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> currentLabel not <span class="keyword">in</span> labelsCount.keys():</span><br><span class="line">            labelsCount[currentLabel] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            labelsCount[currentLabel] += <span class="number">1</span></span><br><span class="line">    shannonEnt = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> labelsCount:</span><br><span class="line">        prop = labelsCount[key] / numEntries</span><br><span class="line">        shannonEnt -= prop * log(prop, 2)</span><br><span class="line">    return shannonEnt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 划分数据集</span><br><span class="line"># 筛选出第axis个特征的值为value的项，同时删除次特征列</span><br><span class="line">def splitDataSet(dataSet, axis, value):</span><br><span class="line">    retDataSet = []</span><br><span class="line">    <span class="keyword">for</span> featureVec <span class="keyword">in</span> dataSet:</span><br><span class="line">        <span class="keyword">if</span> featureVec[axis] == value:</span><br><span class="line">            reducedFeatVec = featureVec[:axis]</span><br><span class="line">            reducedFeatVec.extend(featureVec[axis + <span class="number">1</span>:])</span><br><span class="line">            retDataSet.append(reducedFeatVec)</span><br><span class="line">    return retDataSet</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 补充：python中，可变的为引用，需要创建副本如列表；不可变的为值传递，如元组</span><br><span class="line"># append和extend的区别，append是将后面一个作为整体一个加入，extend是将后面一个拆开，和之前的元组类型一样的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 计算每一个特征值所对应的信息熵，选出最大的信息熵</span><br><span class="line">def chooseBestFeatureToSplit(dataSet):</span><br><span class="line">    numFeature = len(dataSet[0]) - 1  # 特征数</span><br><span class="line">    bestInfoGain = 0.0;</span><br><span class="line">    bestFeatureIndex = -1;  # 最大的信息增益和所在的特征列，下标</span><br><span class="line">    # 分别对每一列特征进行熵计算（i）</span><br><span class="line">    <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(numFeature):</span><br><span class="line">        featureList = [feature[<span class="number">0</span>] <span class="keyword">for</span> feature <span class="keyword">in</span> dataSet]</span><br><span class="line">        featureSet = set(featureList)  # 将list转化为set集合，提取出每一列的特征项（不重复）</span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> featureSet:</span><br><span class="line">            subDataSet = splitDataSet(dataSet, <span class="selector-tag">i</span>, value)</span><br><span class="line">            prop = len(subDataSet) / <span class="attribute">float</span>(len(dataSet))  # 百分比</span><br><span class="line">            infoGain = 0.0 - prop * calcShannonEnt(subDataSet)</span><br><span class="line">        <span class="keyword">if</span> infoGain &gt; bestFeatureIndex:</span><br><span class="line">            bestFeatureIndex = infoGain</span><br><span class="line">            bestFeatureIndex = i</span><br><span class="line">    return bestFeatureIndex</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 构建决策树</span><br><span class="line">def createTree(dataSet, labels):</span><br><span class="line">    classList = [oneData[-<span class="number">1</span>] <span class="keyword">for</span> oneData <span class="keyword">in</span> dataSet]</span><br><span class="line">    # 类别全部相同，就不用分（即label都相同）</span><br><span class="line">    <span class="keyword">if</span> classList.count(classList[<span class="number">0</span>]) == len(dataSet):</span><br><span class="line">        return classList[<span class="number">0</span>]</span><br><span class="line">    # 由于可能存在没有属性的情况，最后还有几个不能分，此时，可以考虑将数量多的作为最终的结果。</span><br><span class="line">    <span class="keyword">if</span> len(dataSet[<span class="number">0</span>]) == <span class="number">1</span>:</span><br><span class="line">        return majorityCnt(classList)</span><br><span class="line"></span><br><span class="line">    bestFeatureIndex = chooseBestFeatureToSplit(dataSet)</span><br><span class="line">    bestFeatureLabel = labels[bestFeatureIndex]</span><br><span class="line">    myTree = &#123;bestFeatureLabel: &#123;&#125;&#125;  # 通过字典来构建决策树</span><br><span class="line"></span><br><span class="line">    featureList = [feature[<span class="number">0</span>] <span class="keyword">for</span> feature <span class="keyword">in</span> dataSet]</span><br><span class="line">    featureSet = set(featureList)  # 将list转化为set集合，提取出每一列的特征项（不重复）</span><br><span class="line">    del(labels[bestFeatureIndex])</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> featureSet:</span><br><span class="line">        sublabels = labels[:]</span><br><span class="line">        myTree[bestFeatureLabel][value] = createTree(splitDataSet</span><br><span class="line">                                (dataSet, bestFeatureIndex, value), sublabels)</span><br><span class="line">    return myTree</span><br><span class="line"></span><br><span class="line"># 找出最多的项</span><br><span class="line">def majorityCnt(classList):</span><br><span class="line">    countList = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> oneData <span class="keyword">in</span> classList:</span><br><span class="line">        <span class="keyword">if</span> oneData not <span class="keyword">in</span> countList.keys():</span><br><span class="line">            countList[oneData] = <span class="number">0</span></span><br><span class="line">        countList[oneData] += <span class="number">1</span></span><br><span class="line">    # 从大到小排序，并返回最大值</span><br><span class="line">    sortedList = sorted(countList.iteritems(),key=operator.itemgetter(<span class="number">1</span>),reverse=True)</span><br><span class="line">    return sortedList[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dataSet,labels = createDataSet()</span><br><span class="line">myTree = createTree(dataSet,labels)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(myTree)</span></span></span><br></pre></td></tr></table></figure>


<p>欢迎使用 <strong>{小书匠}(xiaoshujiang)编辑器</strong>，您可以通过==设置==里的修改模板来改变新建文章的内容。</p>
]]></content>
      <categories>
        <category>ML/DL</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>决策树</tag>
      </tags>
  </entry>
  <entry>
    <title>大化设计模式-单例模式</title>
    <url>/2017/09/15/%E5%A4%A7%E5%8C%96%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<ul>
<li><strong>原理</strong>：保证一个类只有一个实例对象，提供一个对外的实例创建方法。</li>
</ul>
<hr>
<ul>
<li><strong>好处</strong>：</li>
</ul>
<ol>
<li>数据共享，多个线程可以共用一个实例，共同享用这个实例的资源属性（如数据库连接器）</li>
<li>线程安全，通过线程加锁，可以达到并发访问的目的</li>
<li>节约资源，防止创建过多不必要的对象</li>
</ol>
<hr>
<ul>
<li><strong>结构图</strong><br><img src="./images/1505455194462.jpg" alt="enter description here"></li>
</ul>
<hr>
<ul>
<li><strong>分类</strong></li>
</ul>
<ol>
<li>懒汉式：实例化调用时才实例化，否则就不实例化</li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//懒汉式  </span></span><br><span class="line">class Singleton  &#123;  </span><br><span class="line">    private static Singleton instance;  </span><br><span class="line">   </span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    public static Singleton GetInstance() &#123;  </span><br><span class="line">        <span class="keyword">if</span> (NULL == instance)  &#123;  </span><br><span class="line">            instance = new Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        return instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>多线程单例：多线程下，加锁</li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//多线程情况下：  </span></span><br><span class="line">class Singleton &#123;  </span><br><span class="line">    private static Singleton instance;  </span><br><span class="line">    <span class="comment">//加一个锁  </span></span><br><span class="line">    private static readonly object sync = new object();  </span><br><span class="line">   </span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    public static Singleton GetInstance() &#123;  </span><br><span class="line">    	<span class="comment">//先判断是否存在，再加锁！</span></span><br><span class="line">        <span class="keyword">if</span> (NULL == instance) &#123;  </span><br><span class="line">            lock(sync) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (NULL == instance)&#123;  </span><br><span class="line">                    instance = new Singleton();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        return instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>饿汉式：通过静态修饰，使得在加载时就直接实例化，提前做准备。</li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//饿汉式  </span></span><br><span class="line">public sealed class Singleton &#123;  </span><br><span class="line">    <span class="comment">// 通过static final修饰，进行初始化加载，同时无法更改</span></span><br><span class="line">    private static final Singleton instance = new Singleton();  </span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    public static Singleton GetInstance()&#123;  </span><br><span class="line">        return instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>网站架构</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>大话设计模式-设计模式六大原则</title>
    <url>/2017/09/13/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<p>参考链接：<a href="http://www.uml.org.cn/sjms/201211023.asp#4" target="_blank" rel="noopener">http://www.uml.org.cn/sjms/201211023.asp#4</a><br>参考书：大话设计模式<br>###设计模式原则</p>
<ol>
<li>单一职责原则</li>
<li>开放封闭原则</li>
<li>依赖倒转原则</li>
<li>接口隔离原则</li>
<li>迪米特法原则</li>
<li>里氏替换原则</li>
</ol>
<hr>
<ul>
<li>单一职责原则（做好自己的专业，降低耦合度）：为了后期的便于修改和添加，降低各功能之间的耦合度，在开发的初期就需要将每一个功能单独分离出来，而不是放在一起；</li>
</ul>
<hr>
<ul>
<li>开放封闭原则（少修改多扩展）：扩展开放，修改封闭；即可以添加，但是不能够修改。面对需求，对程序的改动是通过添加新的代码，而不是修改旧的代码，这样便于后期维护。</li>
</ul>
<hr>
<ul>
<li>依赖倒转原则（面向对象：继承接口）：当我们需要实现某个需求时，不要严格地在现有的模块上去开发，这样的话，当现有的模块出现问题，会牵连当前的模块。所以，我们需要开发一种接口，这种接口不涉及具体的细节问题，即不作具体的事，只是提供一个可以继承实现的接口工具，用于调用。抽象不应该依赖具体的细节，细节应该依赖抽象。（接口）</li>
</ul>
<hr>
<ul>
<li>里氏替换原则（面向对象：继承父类）：即子类包括父类的全部属性及功能，可以完全替换父类，而软件单位不发生变化。这样，父类就可以再不修改的情况下，扩展出各种不同的子类。</li>
</ul>
<hr>
<ul>
<li>接口隔离原则：不同的功能应该通过不同的接口来实现，而不是在一个接口内。相当于单一职责。</li>
</ul>
<hr>
<ul>
<li>迪米特法原则：如果两个类之间没有大的关联，就不必要直接相互作用，而是通过第三方来进行作用传递。即降低类之间的耦合度。类之间的耦合度越弱，一个类被修改，就不会对有关的其他类产生影响。</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>网站架构</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>今晚的卫星</title>
    <url>/1993/09/01/%E4%BB%8A%E6%99%9A%E7%9A%84%E5%8D%AB%E6%98%9F/</url>
    <content><![CDATA[<p><em>有时候我希望两个人的交流方式，能够像TCP那样简单，只需要三次交手，但最后往往需要很多次交手，以至于打得不可开交</em></p>
<hr>
<p>就目前的科学发展而言，虽然在很多领域计算机还是无法达到人脑的地步，但是在某些方面，计算机却显现出无比的高效稳定。很多时候人受限于情感，即便是1+1=2这样的解答也有可能会回答错误，更不用说是一般的信息决策和判断，特别是在两个人的相处过程之中，太多的想象导致太多的猜忌，进而偏离航向，而计算机却永远不会，它是设计如此严密，以至于他只能给出百分百的结果，而不是一个猜测信息，要知道有时候，猜测错误所导致的召回率极低会引发重大的后果。</p>
<blockquote>
<p>2018/10/21/2:32</p>
</blockquote>
<p>我实在不想做一个啰嗦之人，但是如今这个情况，我找不到去解决的方式。我怕电话打多了你会把我拉黑，我怕啰嗦多了你会更烦，我怕我会再次说出不该说的话来伤了你的心。但是，我也怕这样的冷漠情况会延续下去，怕这样的相互不理解会越来越多，更怕由于异地而导致某些伤口可能会更加扩大。我不是那种会逗人开心的人，即便是在感情面前，到目前为止，我还是白痴一个，唯一学到的一点知识也只是和你相处的短暂几天，我不太会表达，即便是现在所发的这些信息也只有我想法很小的一部分，很多话，我不知道怎么说，也不知道如何才能让你感受得到。<br>    我曾跟你说过，我对未来想得很远，我会对当前的现状加以判断才会做出我的行为，我一直觉得我们两最大的障碍将是物质基础，这个短时间之内无从改变，但是我也希望通过感情来抵消物质所在的占比，但是异地这个困惑无数情侣的问题，我们始终没能摆脱，他还是让我们两产生了各方面的猜疑和情感交流障碍。但是，如同圣人所言，如果感情足够深，很多事情是不会出现的，但是我们却没有太多的前期相处，很多方面可能根本就没认真的了解过彼此，所以，我只能尽我之力，来填补其他可以弥补之处。</p>
<hr>
<p>在乎，特别是对于我，是一个不会挂在嘴边的东西，对我这样嘴烂的人来说更是如此，即便是想你，很多时候我都是通过亲亲的表情来表达。我真正在乎的是两年之后的我们，是否能解决外在的物质基础，是否能顺利的过上我心中的小康生活，不受困于父母，不劳于子女，不累于工作，我希望尽量避免那种以身体来挣钱而再以金钱养身体的生活，即便是有，我也希望只是我一个人的。你常说我是程序员，我们程序员里面流行一句话，“挣得多，死的早”就是这样的，即便现在我已经不是所谓的程序员，但是这种问题还是困扰着包括我在内的大多数中国人，特别是那种没有家庭背景的。所以，说的俗一点，我现在就想往钱看。</p>
<p>人们常评价一个人成功的标志是爱情事业双丰收，其实就目前而言，虽然我不知道你的想法如何，但是在我心中我其实已经把爱情作为丰收项了，我只是在努力让这个爱情显得更有价值，让别人、让对方在不远的将来不会觉得后悔，要知道失败的滋味一个人体味并不是很苦，如果未来是一个人流泪，我宁愿是一个人。但是成功的快乐两个人感受却会有双倍幸福。</p>
<p>另外相对于我们，我更在乎你，这个“更”字可能会让你觉得我很虚伪，要知道一个人除了父母之外，没有人会百分之百更在乎她，但是，我这里的在乎可能和父母的在乎有一定区别。或许我是真的很爱你很喜欢你，也或许我是已经把你当作未来的老婆来看待，作为我本身而言，可能是一种叫做自尊心的东西，我不希望看到我的亲人以后被人压着，没有自信，毫无自豪感。因而，我希望你以后会更快乐，这种快乐既包括做自己想做的工作，有闲暇时间做自己想做的事情，有一定的条件去做放松自己一切的事情，能够达到别人艳羡的程度，而不仅仅是一个妻子一个未来的母亲，一个可能奔波于各种琐事的劳苦人民。即便是如今的工作，我知道你工作很累我也很多时候对你说过找一个轻松的工作，但是最后我想了想，现阶段，我没实力养活你，我的这些话反倒成了一句句虚话、空(控)话，也就不再说了。最初的时候，我甚至想让你去考研，因为我自己始终觉得女生是不需要提早挣钱的，挣多了你给谁花呀，另外研究生也没有任何负担，三年的时间可能会让你选择一个既喜欢又轻松的工作，到时候的很多都是你选择未来而不是未来选你。</p>
<p>这两天也想了想你的话，你感觉不到我很在乎你，可能我确实对这方面的关心太过随意了，从心理上没有感觉到你是否需要这方面的关心，导致每天晚上我都是完事之后回到宿舍才想到给你打电话，这也就导致很多时候是你主动找的我，这方面确实我的错，我无法将其归罪于我的性格问题，而确确实实是因为我的心没有从往常的身份向男友的身份转变，这方面我会改变，就像做菜一样，我现在很差劲，还希望你能多调教。另外，你每次激我我的反应可能确实让你心冷了，但是这个确实是我当时的心理和你想的有所不同，我心情五味杂粮，又对你的想法猜错有误，才导致我没有做出任何回应，甚至有了糟糕的言行。所以以后这方面我会注意，也会更加在乎你的安慰。但是也请你多体谅你这个在你面前极度自卑的男友，尽量减少这方面的刺激。</p>
<p>我还有很多的话想对你说，但是时间很晚了，蚊子都睡醒了，屁股似乎也肿了，所以我现在只想多抱你几次，不想说太多的无用之语</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>心绪</tag>
      </tags>
  </entry>
</search>
